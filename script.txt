use anyhow::{anyhow, Context, Result};
use base64::{engine::general_purpose, Engine};
use chrono;
use reqwest;
use serde::{Deserialize, Serialize};
use serde_json::json;
use solana_client::{
    rpc_client::RpcClient,
    nonblocking::rpc_client::RpcClient as AsyncRpcClient,
};
use solana_sdk::{
    commitment_config::CommitmentConfig,
    signature::Keypair,
    signer::Signer,
    pubkey::Pubkey,
    system_instruction,
};
use spl_token::solana_program::native_token::lamports_to_sol;
use spl_associated_token_account;
use std::io::{self, Write};
use std::str::FromStr;
use std::panic;
use std::sync::Arc;
use tokio::sync::RwLock;
use tokio::time::{self, Duration, Instant as TokioInstant};
use tokio_tungstenite::{connect_async, tungstenite::protocol::Message};
use futures_util::{SinkExt, StreamExt};
use std::path::PathBuf;
use std::fs;
use bincode;
use std::collections::BTreeMap;
use tokio::sync::RwLock as TokioRwLock;

// ============================================================================
// --- BALANCE VERIFICATION & PRE-TRADE CHECKS ---
// ============================================================================


/// Minimum SOL balance to keep for rent and gas (lamports)
const MIN_SOL_BALANCE_LAMPORTS: u64 = 50_000_000;  // 0.05 SOL

/// Buffer percentage for balance checks (accounts for pending txs)
const BALANCE_BUFFER_PERCENT: f64 = 1.05;  // Require 5% extra buffer

/// Balance verification result
#[derive(Debug, Clone)]
pub struct BalanceVerification {
    pub is_sufficient: bool,
    pub available_balance: u64,
    pub required_balance: u64,
    pub deficit: Option<u64>,
    pub token_symbol: String,
}

impl BalanceVerification {
    pub fn display(&self) {
        if self.is_sufficient {
            println! ("   [OK] {} balance sufficient: {} available, {} required",
                self.token_symbol, self.available_balance, self.required_balance);
        } else {
            println!("   [X] {} balance INSUFFICIENT: {} available, {} required (deficit: {})",
                self. token_symbol, 
                self.available_balance, 
                self.required_balance,
                self.deficit.unwrap_or(0));
        }
    }
}

/// Pre-trade balance verifier
pub struct BalanceVerifier {
    pub min_sol_reserve: u64,
    pub buffer_percent: f64,
}

impl Default for BalanceVerifier {
    fn default() -> Self {
        Self {
            min_sol_reserve: MIN_SOL_BALANCE_LAMPORTS,
            buffer_percent: BALANCE_BUFFER_PERCENT,
        }
    }
}

impl BalanceVerifier {
    /// Verify SOL balance with gas reserve
    pub async fn verify_sol_balance(
        &self,
        rpc: &AsyncRpcClient,
        pubkey: &Pubkey,
        required_amount: u64,
    ) -> Result<BalanceVerification> {
        let current_balance = rpc.get_balance(pubkey).await
            .context("Failed to fetch SOL balance")?;
        
        let required_with_buffer = ((required_amount as f64) * self.buffer_percent) as u64;
        let total_required = required_with_buffer + self.min_sol_reserve;
        
        let is_sufficient = current_balance >= total_required;
        let deficit = if is_sufficient {
            None
        } else {
            Some(total_required - current_balance)
        };
        
        Ok(BalanceVerification {
            is_sufficient,
            available_balance: current_balance. saturating_sub(self.min_sol_reserve),
            required_balance: required_with_buffer,
            deficit,
            token_symbol: "SOL".to_string(),
        })
    }
    
    /// Verify SPL token balance
    pub async fn verify_token_balance(
        &self,
        rpc: &AsyncRpcClient,
        wallet_pubkey: &Pubkey,
        token_mint: &str,
        required_amount: u64,
        token_symbol: &str,
    ) -> Result<BalanceVerification> {
        let mint_pubkey = Pubkey::from_str(token_mint)
            .context("Invalid token mint address")?;
        
        let token_account = spl_associated_token_account::get_associated_token_address(
            wallet_pubkey,
            &mint_pubkey,
        );
        
        let current_balance = match rpc.get_token_account_balance(&token_account). await {
            Ok(balance) => balance. amount. parse::<u64>().unwrap_or(0),
            Err(_) => 0,
        };
        
        let required_with_buffer = ((required_amount as f64) * self.buffer_percent) as u64;
        
        let is_sufficient = current_balance >= required_with_buffer;
        let deficit = if is_sufficient {
            None
        } else {
            Some(required_with_buffer - current_balance)
        };
        
        Ok(BalanceVerification {
            is_sufficient,
            available_balance: current_balance,
            required_balance: required_with_buffer,
            deficit,
            token_symbol: token_symbol. to_string(),
        })
    }
}


// Global cache for token decimals to avoid repeated RPC calls
lazy_static::lazy_static! {
    static ref TOKEN_DECIMALS_CACHE: Arc<TokioRwLock<HashMap<String, u8>>> =
        Arc::new(TokioRwLock::new(HashMap::new()));
}

/// Fetch token decimals from SPL Token mint account
async fn get_token_decimals(rpc: &AsyncRpcClient, mint_str: &str) -> Result<u8> {
    let mint_pubkey = Pubkey::from_str(mint_str)
        .context(format!("Invalid mint address: {}", mint_str))?;
    
    let account = rpc.get_account(&mint_pubkey).await
        .context("Failed to fetch token mint account")?;
    
    // SPL Token Mint layout: decimals at offset 44
    if account.data.len() >= 45 {
        let decimals = account.data[44];
        println!("[INFO] Token {}... has {} decimals", &mint_str[..8], decimals);
        Ok(decimals)
    } else {
        println!("[WARN] Could not read decimals from mint {}, defaulting to 9", &mint_str[..8]);
        Ok(9)
    }
}

// ============================================================================
// --- JUPITER ULTRA TOKEN INFO (Enhanced for Any Token) ---
// ============================================================================

#[derive(Debug, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct JupiterUltraTokenInfo {
    pub id: String,
    pub name: String,
    pub symbol: String,
    #[serde(default)]
    pub icon: Option<String>,
    pub decimals: u32,
    
    #[serde(default)]
    pub usd_price: Option<f64>,
    #[serde(default)]
    pub liquidity: Option<f64>,
    #[serde(default)]
    pub fdv: Option<f64>,
    #[serde(default)]
    pub mcap: Option<f64>,
    #[serde(default)]
    pub circ_supply: Option<f64>,
    #[serde(default)]
    pub total_supply: Option<f64>,
    #[serde(default)]
    pub first_pool: Option<FirstPoolInfo>,
    #[serde(default)]
    pub is_verified: bool,
    #[serde(default)]
    pub tags: Vec<String>,
    #[serde(default)]
    pub holder_count: Option<u64>,
    #[serde(default)]
    pub audit: Option<AuditInfo>,
    #[serde(rename = "stats5m", default)]
    pub stats_5m: Option<TokenStats>,
    #[serde(rename = "stats1h", default)]
    pub stats_1h: Option<TokenStats>,
    #[serde(rename = "stats24h", default)]
    pub stats_24h: Option<TokenStats>,
}

#[derive(Debug, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct FirstPoolInfo {
    pub id: String,
    #[serde(default)]
    pub created_at: Option<String>,
}

#[derive(Debug, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct AuditInfo {
    #[serde(default)]
    pub mint_authority_disabled: bool,
    #[serde(default)]
    pub freeze_authority_disabled: bool,
    #[serde(default)]
    pub top_holders_percentage: Option<f64>,
}

#[derive(Debug, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct TokenStats {
    #[serde(default)]
    pub price_change: Option<f64>,
    #[serde(default)]
    pub volume_change: Option<f64>,
    #[serde(default)]
    pub buy_volume: Option<f64>,
    #[serde(default)]
    pub sell_volume: Option<f64>,
    #[serde(default)]
    pub num_buys: Option<u64>,
    #[serde(default)]
    pub num_sells: Option<u64>,
    #[serde(default)]
    pub num_traders: Option<u64>,
}

/// Context for analyzing any token pair
#[derive(Debug, Clone)]
struct TokenPairContext {
    base_token: JupiterUltraTokenInfo,
    quote_token: JupiterUltraTokenInfo,
    expected_price: Option<f64>,
    pair_name: String,
}

/// Fetch token decimals with caching
async fn get_token_decimals_cached(rpc: &AsyncRpcClient, mint_str: &str) -> Result<u8> {
    // Check cache first
    {
        let cache = TOKEN_DECIMALS_CACHE.read().await;
        if let Some(&decimals) = cache.get(mint_str) {
            return Ok(decimals);
        }
    }
    
    // Fetch from chain
    let decimals = get_token_decimals(rpc, mint_str).await?;
    
    // Store in cache
    {
        let mut cache = TOKEN_DECIMALS_CACHE.write().await;
        cache.insert(mint_str.to_string(), decimals);
    }
    
    Ok(decimals)
}

/// Helper to get decimals for both tokens in a pair
async fn get_token_pair_decimals(
    rpc: &AsyncRpcClient,
    token_a_mint: &str,
    token_b_mint: &str,
) -> (u8, u8) {
    let decimals_a = get_token_decimals_cached(rpc, token_a_mint).await.unwrap_or(9);
    let decimals_b = get_token_decimals_cached(rpc, token_b_mint).await.unwrap_or(6);
    
    println!("[INFO] Token pair decimals: {} / {}", decimals_a, decimals_b);
    (decimals_a, decimals_b)
}

/// Get dynamic price bounds based on reserve ratios (not hardcoded)
fn get_dynamic_price_bounds(reserve_a: f64, reserve_b: f64) -> (f64, f64) {
    if reserve_a <= 0.0 || reserve_b <= 0.0 {
        return (0.00001, 1_000_000.0);
    }
    
    // Calculate expected price from reserves
    let estimated_price = reserve_b / reserve_a;
    
    // Allow 99x deviation from estimated price (very permissive)
    let min_bound = (estimated_price * 0.01).max(0.00001); // At least $0.00001
    let max_bound = (estimated_price * 100.0).min(1_000_000.0); // Max $1M
    
    (min_bound, max_bound)
}


/// Debug function to scan Meteora pool data for reserve pairs
fn debug_meteora_pool_data(data: &[u8], decimals_a: u8, decimals_b: u8, _dex_name: &str, pool_address: &str) {    
    println!("\n+============================================================");
    println!("| METEORA POOL DATA SCANNER");
    println!("+============================================================");
    println!("| Pool: {}...", &pool_address[..16.min(pool_address.len())]);
    println!("| Data length: {} bytes", data.len());
    println!("| Discriminator: {:02x?}", &data[0..8.min(data.len())]);
    println!("| Token decimals: {} / {}", decimals_a, decimals_b);
    println!("+============================================================\n");
    
    println!("[SCAN] Scanning for u64 reserve pairs...\n");
    
    let mut candidates: Vec<(usize, f64, f64, f64)> = Vec::new();
    
    for offset in (8..data.len().saturating_sub(16)).step_by(8) {
        if let (Some(val_a), Some(val_b)) = (read_u64_le(data, offset), read_u64_le(data, offset + 8)) {
            if val_a < 1_000_000 || val_b < 1_000_000 {
                continue;
            }
            
            let reserve_a = val_a as f64 / 10_f64.powi(decimals_a as i32);
            let reserve_b = val_b as f64 / 10_f64.powi(decimals_b as i32);
            
            let price_normal = if reserve_a > 0.0 { reserve_b / reserve_a } else { 0.0 };
            let price_inverse = if reserve_b > 0.0 { reserve_a / reserve_b } else { 0.0 };
            
            let is_reasonable = reserve_a > 10.0 && reserve_a < 10_000_000.0 &&
                               reserve_b > 100.0 && reserve_b < 100_000_000.0;
            
            if is_reasonable {
                candidates.push((offset, reserve_a, reserve_b, price_normal));
                
                println!("[POS] Offset {:3} (0x{:03x}):", offset, offset);
                println!("   Raw values: val_a={}, val_b={}", val_a, val_b);
                println!("   Adjusted:   A={:>12.4} tokens, B={:>12.4} tokens", reserve_a, reserve_b);
                println!("   Price:      ${:.6} (normal) | ${:.6} (inverted)", price_normal, price_inverse);
                
                if decimals_a == 6 && decimals_b == 6 {
                    if (0.2..=1.0).contains(&price_normal) {
                        println!("   [*] LIKELY CANDIDATE for MET/USDC (price in $0.20-$1.00 range)");
                    } else if (0.2..=1.0).contains(&price_inverse) {
                        println!("   [*] LIKELY CANDIDATE for USDC/MET (inverse price in range)");
                    }
                } else if decimals_a == 9 && decimals_b == 6 {
                    if (50.0..=500.0).contains(&price_normal) {
                        println!("   [*] LIKELY CANDIDATE for SOL/USDC");
                    } else if (50.0..=500.0).contains(&price_inverse) {
                        println!("   [*] LIKELY CANDIDATE for USDC/SOL (inverted)");
                    }
                }
                println!();
            }
        }
    }
    
    println!("+============================================================");
    println!("| SCAN SUMMARY");
    println!("+============================================================");
    println!("| Found {} potential reserve pairs", candidates.len());
    
    if !candidates.is_empty() {
        println!("|");
        println!("| Top 5 by liquidity (Reserve A x Reserve B):");
        
        candidates.sort_by(|a, b| {
            let liq_a = a.1 * a.2;
            let liq_b = b.1 * b.2;
            liq_b.partial_cmp(&liq_a).unwrap()
        });
        
        for (i, (offset, reserve_a, reserve_b, price)) in candidates.iter().take(5).enumerate() {
            let liquidity_proxy = reserve_a * reserve_b;
            println!("| {}. Offset {:3}: A={:>10.2}, B={:>10.2}, Price=${:.4}, Liq~{:.0}", 
                i + 1, offset, reserve_a, reserve_b, price, liquidity_proxy);
        }
    }
    
    println!("+============================================================\n");
}



/// Debug scanner for DLMM pools
fn debug_meteora_dlmm_data(data: &[u8], _dex_name: &str, pool_address: &str) {    
    println!("\n+============================================================");
    println!("| METEORA DLMM DATA SCANNER");
    println!("+============================================================");
    println!("| Pool: {}...", &pool_address[..16.min(pool_address.len())]);
    println!("| Data length: {} bytes", data.len());
    println!("| Discriminator: {:02x?}", &data[0..8.min(data.len())]);
    println!("+============================================================\n");
    
    println!("[SCAN] Scanning for bin_step (u16) and active_id (i32)...\n");
    
    println!("[INFO] Potential bin_step values (u16, expected 1-1000):");
    let mut bin_step_candidates: Vec<(usize, u16)> = Vec::new();
    
    for offset in (8..200).step_by(2) {
        if let Some(val) = read_u16_le(data, offset) {
            if val > 0 && val < 10000 {
                bin_step_candidates.push((offset, val));
                println!("   Offset {:3} (0x{:03x}): {}", offset, offset, val);
            }
        }
    }
    
    println!("\n[INFO] Potential active_id values (i32, expected -50000 to 50000):");
    
    for offset in (8..200).step_by(4) {
        if let Some(val) = read_i32_le(data, offset) {
            if val != 0 && val.abs() < 100000 {
                println!("   Offset {:3} (0x{:03x}): {}", offset, offset, val);
            }
        }
    }
    
    println!("\n[TEST] Testing bin_step + active_id combinations:");
    for (bs_offset, bin_step) in &bin_step_candidates {
        for offset_id in ((*bs_offset + 2)..(*bs_offset + 20)).step_by(4) {
            if let Some(active_id) = read_i32_le(data, offset_id) {
                if active_id != 0 && active_id.abs() < 100000 {
                    let bin_step_decimal = *bin_step as f64 / 10000.0;
                    let price_raw = (1.0 + bin_step_decimal).powi(active_id);
                    
                    for multiplier in [1.0, 10.0, 100.0, 1000.0, 0.1, 0.01] {
                        let price = price_raw * multiplier;
                        
                        if (0.001..=10000.0).contains(&price) {
                            println!("   bin_step@{}: {}, active_id@{}: {}", 
                                bs_offset, bin_step, offset_id, active_id);
                            println!("      -> price_raw={:.6}, mult={}, final_price=${:.4}",
                                price_raw, multiplier, price);
                            
                            if (50.0..=500.0).contains(&price) {
                                println!("      [*] LIKELY CANDIDATE for SOL price");
                            } else if (0.2..=2.0).contains(&price) {
                                println!("      [*] LIKELY CANDIDATE for MET price");
                            }
                        }
                    }
                }
            }
        }
    }
    
    println!("\n+============================================================\n");
}


// ============================================================================
// --- DEX FAILURE TRACKING & HEALTH MANAGEMENT ---
// ============================================================================

use std::collections::{HashMap, HashSet};

#[derive(Debug, Clone)]
struct DexHealthTracker {
    consecutive_failures: HashMap<String, u32>,
    last_success: HashMap<String, std::time::Instant>,
    permanently_disabled: HashSet<String>,
}

impl DexHealthTracker {
    fn new() -> Self {
        Self {
            consecutive_failures: HashMap::new(),
            last_success: HashMap::new(),
            permanently_disabled: HashSet::new(),
        }
    }
    
    /// Record a successful price fetch
    fn record_success(&mut self, dex: &str) {
        self.consecutive_failures.insert(dex.to_string(), 0);
        self.last_success.insert(dex.to_string(), std::time::Instant::now());
        self.permanently_disabled.remove(dex);
    }
    
    /// Record a failed price fetch
    fn record_failure(&mut self, dex: &str) {
        let count = self.consecutive_failures.entry(dex.to_string()).or_insert(0);
        *count += 1;
    }
    
    /// Check if DEX should be queried this iteration
    fn should_query(&self, dex: &str, iteration: u32) -> bool {
        // Never query permanently disabled DEXs
        if self.permanently_disabled.contains(dex) {
            return false;
        }
        
        let failures = self.consecutive_failures.get(dex).unwrap_or(&0);
        
        match *failures {
            0..=2 => true,                          // 0-2 failures: query every time
            3..=5 => iteration % 5 == 0,            // 3-5 failures: every 5 iterations (2.5s)
            6..=10 => iteration % 20 == 0,          // 6-10 failures: every 20 iterations (10s)
            _ => iteration % 60 == 0,               // 11+ failures: every 60 iterations (30s)
        }
    }
    
    /// Check if DEX should be shown in display
    fn should_display(&self, dex: &str, iteration: u32) -> bool {
        if self.permanently_disabled.contains(dex) {
            return iteration % 40 == 0; // Show disabled status occasionally
        }
        
        let failures = self.consecutive_failures.get(dex).unwrap_or(&0);
        
        match *failures {
            0..=3 => true,                          // Always show if working or recently failed
            4..=10 => iteration % 10 == 0,          // Show status every 10 iterations
            _ => iteration % 40 == 0,               // Show status every 40 iterations
        }
    }
    
    /// Permanently disable a DEX (e.g., invalid pool address)
    fn disable_permanently(&mut self, dex: &str) {
        self.permanently_disabled.insert(dex.to_string());
    }
    
    /// Get status emoji for display
    fn get_status(&self, dex: &str) -> &str {
        if self.permanently_disabled.contains(dex) {
            return "";
        }
        
        let failures = self.consecutive_failures.get(dex).unwrap_or(&0);
        
        match *failures {
            0 => "",
            1..=2 => "",
            3..=5 => "",
            _ => "",
        }
    }
    
    /// Get health percentage (0-100)
    fn get_health_percentage(&self, dex: &str) -> u8 {
        if self.permanently_disabled.contains(dex) {
            return 0;
        }
        
        let failures = self.consecutive_failures.get(dex).unwrap_or(&0);
        
        match *failures {
            0 => 100,
            1 => 80,
            2 => 60,
            3..=5 => 40,
            6..=10 => 20,
            _ => 10,
        }
    }
    
    /// Get summary statistics (healthy, degraded, failed counts)
    fn get_summary(&self) -> (usize, usize, usize) {
        let healthy = self.consecutive_failures.values().filter(|&&v| v <= 2).count();
        let degraded = self.consecutive_failures.values().filter(|&&v| v > 2 && v <= 10).count();
        let failed = self.consecutive_failures.values().filter(|&&v| v > 10).count() 
                     + self.permanently_disabled.len();
        
        (healthy, degraded, failed)
    }
}


// ============================================================================
// --- PRICE VALIDATION & SAFETY SYSTEM ---
// ============================================================================

/// Price validation configuration
struct PriceValidationConfig {
    /// Maximum allowed deviation from reference price (percentage)
    max_deviation_percent: f64,
    /// Minimum number of reference sources required for validation
    min_reference_sources: usize,
    /// Maximum age for price data to be considered valid (milliseconds)
    max_price_age_ms: u128,
    /// Maximum allowed spread between any two sources (percentage)
    max_spread_percent: f64,
    /// Optional price bounds (min, max) in USD - None means no bounds checking
    price_bounds: Option<(f64, f64)>,
}

impl Default for PriceValidationConfig {
    fn default() -> Self {
        Self {
            max_deviation_percent: 5.0,
            min_reference_sources: 1,
            max_price_age_ms: 30_000,
            max_spread_percent: 10.0,
            price_bounds: None,  // No bounds by default
        }
    }
}

impl PriceValidationConfig {
    /// Create config with SOL-specific bounds
    fn for_sol() -> Self {
        Self {
            price_bounds: Some((50.0, 500.0)),
            ..Default::default()
        }
    }
    
    /// Create config for custom tokens (no bounds, more lenient)
    fn for_custom_token() -> Self {
        Self {
            max_deviation_percent: 10.0,  // More lenient for low-liquidity tokens
            .. Default::default()
        }
    }
}


/// Price validation result
#[derive(Debug, Clone)]
enum ValidationResult {
    Valid,
    InvalidDeviation { price: f64, reference: f64, deviation: f64 },
    InvalidSpread { spread: f64, max_allowed: f64 },
    InvalidBounds { price: f64, min: f64, max: f64 },
    NoReferencePrices,
    Stale { age_ms: u128, max_age_ms: u128 },
}

/// Price validator that cross-checks against other sources
struct PriceValidator {
    config: PriceValidationConfig,
}

impl PriceValidator {
    fn new() -> Self {
        Self {
            config: PriceValidationConfig::default(),
        }
    }

    fn with_config(config: PriceValidationConfig) -> Self {
        Self { config }
    }

    /// Validate a price against Jupiter reference
    /// FIXED: Now handles non-USDC quote tokens correctly
    async fn validate_price(
        &self,
        dex_name: &str,
        price: f64,
        _price_cache: &EnhancedPriceCache,
        base_token_mint: &str,
        quote_token_mint: &str,
    ) -> ValidationResult {
        // Step 1: Check price bounds (sanity check) - only if configured
        if let Some((min, max)) = self.config.price_bounds {
            if price < min || price > max {
                println!("[{}]  Price {:.6} outside bounds ({:.6}-{:.6})",
                    dex_name, price, min, max);
                return ValidationResult::InvalidBounds {
                    price,
                    min,
                    max,
                };
            }
        }

        // Step 2: Get Jupiter reference prices for BOTH tokens
        let base_usd_price = get_jupiter_token_price(base_token_mint).await;
        let quote_usd_price = get_jupiter_token_price(quote_token_mint).await;
        
        if base_usd_price <= 0.0 {
            println!("[{}]  Could not get Jupiter price for base token, accepting", dex_name);
            return ValidationResult::NoReferencePrices;
        }
        
        if quote_usd_price <= 0.0 {
            println!("[{}]  Could not get Jupiter price for quote token, accepting", dex_name);
            return ValidationResult::NoReferencePrices;
        }

        // Step 3: Calculate expected price ratio
        // KEY FIX: base_usd / quote_usd gives expected ratio
        let expected_price = base_usd_price / quote_usd_price;
        
        println!("[{}]  Validation:", dex_name);
        println!("[{}]    Parsed Price: {:.8}", dex_name, price);
        println!("[{}]    Base USD: ${:.8}", dex_name, base_usd_price);
        println!("[{}]    Quote USD: ${:.8}", dex_name, quote_usd_price);
        println!("[{}]    Expected Ratio: {:.8}", dex_name, expected_price);

        // Step 4: Check deviation from expected ratio
        let deviation = ((price - expected_price).abs() / expected_price) * 100.0;
        println!("[{}]    Deviation: {:.2}% (max: {:.1}%)",
            dex_name, deviation, self.config.max_deviation_percent);

        if deviation > self.config.max_deviation_percent {
            println!("[{}]  Price REJECTED: {:.2}% deviation from expected ratio",
                dex_name, deviation);
            return ValidationResult::InvalidDeviation {
                price,
                reference: expected_price,
                deviation,
            };
        }

        println!("[{}]  Price VALIDATED: {:.8} (within {:.2}% of expected {:.8})",
            dex_name, price, deviation, expected_price);
        ValidationResult::Valid
    }

    /// Check if price data is stale
    fn check_staleness(&self, age_ms: u128) -> ValidationResult {
        if age_ms > self.config.max_price_age_ms {
            return ValidationResult::Stale {
                age_ms,
                max_age_ms: self.config.max_price_age_ms,
            };
        }
        ValidationResult::Valid
    }
}

// Global validator instance
lazy_static::lazy_static! {
    static ref PRICE_VALIDATOR: PriceValidator = PriceValidator::new();
}

/// Raydium AMM V4 Pool State
/// Total size: ~752 bytes
/// Documentation: https://github.com/raydium-io/raydium-sdk
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RaydiumAmmV4 {
    pub status: u64,
    pub nonce: u64,
    pub order_num: u64,
    pub depth: u64,
    pub coin_decimals: u64,
    pub pc_decimals: u64,
    pub state: u64,
    pub reset_flag: u64,
    pub min_size: u64,
    pub vol_max_cut_ratio: u64,
    pub amount_wave_ratio: u64,
    pub coin_lot_size: u64,
    pub pc_lot_size: u64,
    pub min_price_multiplier: u64,
    pub max_price_multiplier: u64,
    pub system_decimal_value: u64,
    pub min_separate_numerator: u64,
    pub min_separate_denominator: u64,
    pub trade_fee_numerator: u64,
    pub trade_fee_denominator: u64,
    pub pnl_numerator: u64,
    pub pnl_denominator: u64,
    pub swap_fee_numerator: u64,
    pub swap_fee_denominator: u64,
    pub need_take_pnl_coin: u64,
    pub need_take_pnl_pc: u64,
    pub total_pnl_pc: u64,
    pub total_pnl_coin: u64,
    pub pool_total_deposit_pc: u128,
    pub pool_total_deposit_coin: u128,
    pub swap_coin_in_amount: u128,
    pub swap_pc_out_amount: u128,
    pub swap_coin2pc_fee: u64,
    pub swap_pc_in_amount: u128,
    pub swap_coin_out_amount: u128,
    pub swap_pc2coin_fee: u64,
    // ... remaining fields
}







/// Raydium CLMM Pool State
/// Uses concentrated liquidity with sqrt price
#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct RaydiumClmmPool {
    // First 8 bytes: discriminator
    pub bump: [u8; 1],
    pub amm_config: [u8; 32],
    pub owner: [u8; 32],
    pub token_mint_0: [u8; 32],
    pub token_mint_1: [u8; 32],
    pub token_vault_0: [u8; 32],
    pub token_vault_1: [u8; 32],
    pub observation_key: [u8; 32],
    pub mint_decimals_0: u8,
    pub mint_decimals_1: u8,
    pub tick_spacing: u16,
    pub liquidity: u128,
    pub sqrt_price_x64: u128,
    pub tick_current: i32,
    pub padding3: u16,
    pub padding4: u16,
    pub fee_growth_global_0_x64: u128,
    pub fee_growth_global_1_x64: u128,
    pub protocol_fees_token_0: u64,
    pub protocol_fees_token_1: u64,
    pub swap_in_amount_token_0: u128,
    pub swap_out_amount_token_1: u128,
    pub swap_in_amount_token_1: u128,
    pub swap_out_amount_token_0: u128,
    pub status: u8,
    pub padding: [u8; 7],
    pub reward_infos: [[u8; 200]; 3],
    pub tick_array_bitmap: [u64; 16],
    pub total_fees_token_0: u64,
    pub total_fees_claimed_token_0: u64,
    pub total_fees_token_1: u64,
    pub total_fees_claimed_token_1: u64,
    pub fund_fees_token_0: u64,
    pub fund_fees_token_1: u64,
    pub open_time: u64,
    pub padding1: [u64; 25],
    pub padding2: [u64; 32],
}


// ============================================================================
// --- JUPITER ULTRA API FUNCTIONS (Universal Token Support) ---
// ============================================================================

/// Fetch token info from Jupiter Ultra API - works for ANY Solana token
async fn fetch_token_info_ultra(mint_address: &str) -> Result<JupiterUltraTokenInfo> {
    let url = format!(
        "https://lite-api.jup.ag/ultra/v1/search?query={}",
        urlencoding::encode(mint_address)
    );
    
    let mut headers = reqwest::header::HeaderMap::new();
    headers.insert(
        "x-api-key",
        reqwest::header::HeaderValue::from_static(JUPITER_API_KEY),
    );
    
    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(10))
        .default_headers(headers)
        .build()?;
    
    let response = client.get(&url). send().await?;
    
    if !response. status().is_success() {
        return Err(anyhow! ("Jupiter Ultra API error: {}", response. status()));
    }
    
    let tokens: Vec<JupiterUltraTokenInfo> = response.json().await?;
    
    if tokens.is_empty() {
        return Err(anyhow!("Token not found: {}", mint_address));
    }
    
    // Find exact match by address
    let mint_lower = mint_address. to_lowercase();
    for token in &tokens {
        if token.id.to_lowercase() == mint_lower {
            return Ok(token.clone());
        }
    }
    
    Ok(tokens. into_iter().next(). unwrap())
}

/// Create fallback token info when API fails
fn create_fallback_token_info(mint: &str, default_decimals: u32) -> JupiterUltraTokenInfo {
    JupiterUltraTokenInfo {
        id: mint.to_string(),
        name: format!("Unknown ({}... )", &mint[..8.min(mint.len())]),
        symbol: "??? ".to_string(),
        icon: None,
        decimals: default_decimals,
        usd_price: None,
        liquidity: None,
        fdv: None,
        mcap: None,
        circ_supply: None,
        total_supply: None,
        first_pool: None,
        is_verified: false,
        tags: vec![],
        holder_count: None,
        audit: None,
        stats_5m: None,
        stats_1h: None,
        stats_24h: None,
    }
}

/// Calculate expected price ratio from USD prices
/// Works for ANY token pair (SOL/USDC, BONK/SOL, JUP/USDC, etc.)
fn calculate_expected_price(
    base: &JupiterUltraTokenInfo, 
    quote: &JupiterUltraTokenInfo
) -> Option<f64> {
    match (base.usd_price, quote. usd_price) {
        (Some(base_usd), Some(quote_usd)) if quote_usd > 0.0 => {
            // Price = how many quote tokens for 1 base token
            // Example: SOL=$138, USDC=$1 -> price = 138
            // Example: BONK=$0.00002, USDC=$1 -> price = 0.00002
            Some(base_usd / quote_usd)
        }
        (Some(base_usd), None) => {
            // Quote has no price, assume $1 (stablecoin)
            println!("    Quote token has no USD price, assuming $1.00");
            Some(base_usd)
        }
        _ => None
    }
}

/// Display comprehensive token info from Jupiter Ultra
fn display_token_info_ultra(info: &JupiterUltraTokenInfo) {
    println!("\n");
    println!("            TOKEN INFORMATION (Jupiter Ultra)             ");
    println!("");
    
    println!(" Name:        {:<45} ", info.name);
    println!(" Symbol:      {:<45} ", info.symbol);
    println!(" Decimals:    {:<45} ", info.decimals);
    
    let addr_display = if info.id.len() > 20 {
        format!("{}... {}", &info. id[..8], &info.id[info.id.len()-6..])
    } else {
        info.id.clone()
    };
    println!(" Address:     {:<45} ", addr_display);
    
    let verified_status = if info. is_verified { " Verified" } else { " Unverified" };
    println!(" Status:      {:<45} ", verified_status);
    
    if ! info.tags.is_empty() {
        let tags_str = info. tags.iter().take(4).cloned().collect::<Vec<_>>(). join(", ");
        println!(" Tags:        {:<45} ", tags_str);
    }
    
    println!("");
    
    if let Some(price) = info.usd_price {
        // Format based on price magnitude
        let price_str = if price < 0.0001 {
            format! ("${:.10}", price)
        } else if price < 1.0 {
            format! ("${:.6}", price)
        } else {
        format!("${:.2}", price)
        };
        println!("  Price:    {:<45} ", price_str);
    }
    
    if let Some(liq) = info. liquidity {
        println!("  Liquidity: ${:<43} ", format_number_with_commas(liq));
    }
    
    if let Some(mcap) = info. mcap {
        println!("  Mcap:      ${:<43} ", format_number_with_commas(mcap));
    }
    
    if let Some(holders) = info.holder_count {
        println!("  Holders:   {:<44} ", format_number_with_commas(holders as f64));
    }
    
    if let Some(audit) = &info.audit {
        println!("");
        let mint_status = if audit.mint_authority_disabled { " Disabled" } else { " Enabled" };
        let freeze_status = if audit.freeze_authority_disabled { " Disabled" } else { " Enabled" };
        println!(" Mint Auth:   {:<45} ", mint_status);
        println!(" Freeze Auth: {:<45} ", freeze_status);
    }
    
    if let Some(pool) = &info. first_pool {
        println!("");
        let pool_display = if pool.id.len() > 30 {
            format!("{}...{}", &pool.id[..16], &pool.id[pool.id. len()-8..])
        } else {
            pool.id.clone()
        };
        println! (" First Pool:  {:<45} ", pool_display);
    }
    
    if let Some(stats) = &info. stats_24h {
        println!("");
        println!("                    24H STATISTICS                        ");
        if let Some(change) = stats.price_change {
            let arrow = if change >= 0.0 { "" } else { "" };
        println!(" Price Change: {} {:>41.2}% ", arrow, change);
        }
        if let Some(traders) = stats.num_traders {
            println!(" Traders:      {:<44} ", format_number_with_commas(traders as f64));
        }
    }
    
    println! ("");
}

/// Orca Whirlpool State
/// Similar to Raydium CLMM
#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct OrcaWhirlpool {
    pub whirlpools_config: [u8; 32],
    pub whirlpool_bump: [u8; 1],
    pub tick_spacing: u16,
    pub tick_spacing_seed: [u8; 2],
    pub fee_rate: u16,
    pub protocol_fee_rate: u16,
    pub liquidity: u128,
    pub sqrt_price: u128,
    pub tick_current_index: i32,
    pub protocol_fee_owed_a: u64,
    pub protocol_fee_owed_b: u64,
    pub token_mint_a: [u8; 32],
    pub token_vault_a: [u8; 32],
    pub fee_growth_global_a: u128,
    pub token_mint_b: [u8; 32],
    pub token_vault_b: [u8; 32],
    pub fee_growth_global_b: u128,
    pub reward_last_updated_timestamp: u64,
    pub reward_infos: [[u8; 128]; 3],
}




/// Meteora DLMM Pool Structure (Dynamic Liquidity Market Maker)
/// Size: ~1112 bytes
#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct MeteoraDlmmPoolState {
    // Discriminator (8 bytes)
    pub parameters: [u8; 32],       // offset 8
    pub v_parameters: [u8; 32],     // offset 40
    pub bump_seed: [u8; 1],         // offset 72
    pub bin_step: u16,              // offset 73
    pub pair_type: u8,              // offset 75
    pub active_id: i32,             // offset 76 - CRITICAL: current bin
    pub bin_step_numerator: u64,    // offset 80
    pub protocol_fee_x: u64,        // offset 88
    pub protocol_fee_y: u64,        // offset 96
    pub padding: [u8; 7],           // offset 104
    pub reserve_x: [u8; 32],        // offset 111 - token vault X
    pub reserve_y: [u8; 32],        // offset 143 - token vault Y
    pub token_x_mint: [u8; 32],     // offset 175
    pub token_y_mint: [u8; 32],     // offset 207
    pub oracle: [u8; 32],           // offset 239
    // Bin array and other data follows...
}







// ============================================================================
// --- BINARY PARSING UTILITIES ---
// ============================================================================

/// Safely read u64 from bytes at offset
fn read_u64_le(data: &[u8], offset: usize) -> Option<u64> {
    if offset + 8 > data.len() {
        return None;
    }
    Some(u64::from_le_bytes(data[offset..offset + 8].try_into().ok()?))
}

/// Safely read u128 from bytes at offset
fn read_u128_le(data: &[u8], offset: usize) -> Option<u128> {
    if offset + 16 > data.len() {
        return None;
    }
    Some(u128::from_le_bytes(data[offset..offset + 16].try_into().ok()?))
}

/// Safely read i32 from bytes at offset
fn read_i32_le(data: &[u8], offset: usize) -> Option<i32> {
    if offset + 4 > data.len() {
        return None;
    }
    Some(i32::from_le_bytes(data[offset..offset + 4].try_into().ok()?))
}

/// Safely read u16 from bytes at offset
fn read_u16_le(data: &[u8], offset: usize) -> Option<u16> {
    if offset + 2 > data.len() {
        return None;
    }
    Some(u16::from_le_bytes(data[offset..offset + 2].try_into().ok()?))
}

// ============================================================================
// --- UNIFIED CONSTANTS & BASE SETTINGS ---
// ============================================================================
const HARDCODED_RPC_URL: &str = "https://black-convincing-mound.solana-mainnet.quiknode.pro/1af3d322a56b1e0f0c5985ef59976ae2b2553805";
const QUICKNODE_WS_URL: &str = "wss://black-convincing-mound.solana-mainnet.quiknode.pro/1af3d322a56b1e0f0c5985ef59976ae2b2553805";
const QUICKNODE_RPC_URL: &str = "https://black-convincing-mound.solana-mainnet.quiknode.pro/1af3d322a56b1e0f0c5985ef59976ae2b2553805";
const SOL_MINT: &str = "So11111111111111111111111111111111111111112";
const USDC_MINT: &str = "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v";
const USDC_DECIMALS: u32 = 6;
const LAMPORTS_PER_SOL: u64 = 1_000_000_000;
const COMPARISON_AMOUNT_SOL: u64 = LAMPORTS_PER_SOL;

// --- VOLATILE / LESS EFFICIENT TARGETS ---
const JUP_MINT: &str = "JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN";
const BONK_MINT: &str = "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263";
const WIF_MINT: &str = "EKpQGSJtjMFqKZ9KQanSqErztk606A2cGSjSenpDwQ9";
const PYTH_MINT: &str = "HZ1JovNiVvGrGNiiYv3XW5KKge5JCg27a1kCNM6PHOS";
const RAY_MINT: &str = "4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R";

// Display refresh settings (add to existing constants)
const DISPLAY_REFRESH_INTERVAL_MS: u64 = 200;
const RETRY_FAILED_DEX_INTERVAL: u32 = 5;  // Retry every 20 iterations (10s)
const MAX_CONSECUTIVE_FAILURES_DEX: u32 = 10;   // Disable after 15 failures

// --- SCAN INTERVALS ---
// Reduced from 20s to 2s for high-frequency scanning
const SCAN_INTERVAL_NO_OPPORTUNITY_MS: u64 = 2000; 
const SCAN_INTERVAL_ERROR_MS: u64 = 1000;

// Jupiter Ultra API with Authentication
const JUPITER_ULTRA_API: &str = "https://api.jup.ag/ultra/v1/";
const JUPITER_API_KEY: &str = "111e08df-273e-4828-a38b-bc88ddaedec1";
const JUPITER_ORDER_API_URL: &str = "https://api.jup.ag/ultra/v1/order";
const JUPITER_SEARCH_API_URL: &str = "https://lite-api.jup.ag/ultra/v1/search";

// Rate limiting
const JUPITER_DELAY_BETWEEN_CALLS_MS: u64 = 200;
const BATCH_SIZE: usize = 10;
const DELAY_BETWEEN_BATCHES_MS: u64 = 1000;
const MAX_RATE_LIMIT_RETRIES: u32 = 3;
const INITIAL_BACKOFF_MS: u64 = 1000;

// Jito constants
const JITO_BUNDLE_URLS: &[&str] = &[
    "https://mainnet.block-engine.jito.wtf/api/v1/bundles",
    "https://amsterdam.mainnet.block-engine.jito.wtf/api/v1/bundles",
    "https://frankfurt.mainnet.block-engine.jito.wtf/api/v1/bundles",
    "https://ny.mainnet.block-engine.jito.wtf/api/v1/bundles",
    "https://tokyo.mainnet.block-engine.jito.wtf/api/v1/bundles",
];

static JITO_ENDPOINT_INDEX: std::sync::atomic::AtomicUsize = std::sync::atomic::AtomicUsize::new(0);

// Jito Tip Accounts - Fetched dynamically from Jito API with fallback to known addresses
const JITO_TIP_ACCOUNTS_FALLBACK: [&str; 8] = [
    "96gYZGLnJYVFmbjzopPSU6QiEV5fGqZNyN9nmNhvrZU5",
    "HFqU5x63VTqvQss8hp11i4wVV8bD44PvwucfZ2bU7gRe",
    "Cw8CFyM9FkoMi7K7Crf6HNQqf4uEMzpKw6QNghXLvLkY",
    "ADaUMid9yfUytqMBgopwjb2DTLSokTSzL1zt6iGPaS49",
    "DfXygSm4jCyNCybVYYK6DwvWqjKee8pbDmJGcLWNDXjh",
    "ADuUkR4vqLUMWXxW9gh6D6L8pMSawimctcNZ5pGwDcEt",
    "DttWaMuVvTiduZRnguLF7jNxTgiMBZ1hyAumKUiL2KRL",
    "3AVi9Tg9Uo68tJfuvoKvqKNWKkC5wPdSSdeBnizKZ6jT",
];

// Jito API endpoint for fetching tip accounts
const JITO_TIP_ACCOUNTS_API: &str = "https://mainnet.block-engine.jito.wtf/api/v1/bundles/tip_accounts";

// Cache for dynamically fetched tip accounts
lazy_static::lazy_static! {
    static ref JITO_TIP_ACCOUNTS_CACHE: Arc<TokioRwLock<Option<Vec<String>>>> = 
        Arc::new(TokioRwLock::new(None));
    static ref JITO_TIP_ACCOUNTS_LAST_FETCH: Arc<TokioRwLock<Option<std::time::Instant>>> = 
        Arc::new(TokioRwLock::new(None));
}

// How often to refresh tip accounts (1 hour)
const JITO_TIP_ACCOUNTS_CACHE_TTL_SECS: u64 = 3600;

// Arbitrage Settings
const TARGET_TRADE_AMOUNT_SOL: f64 = 0.2;
const MAX_TRADE_AMOUNT_USD: f64 = 40.0;
const DESIRED_NET_PROFIT_USD: f64 = 0.05;
const BASE_PRIORITY_FEE_MICRO_LAMPORTS: u64 = 50_000;
const JITO_TIP_LAMPORTS: u64 = 10_000;
const MAX_RETRIES: u32 = 2;
const MAX_DAILY_LOSS_USD: f64 = 50.0;
const MAX_CONSECUTIVE_FAILURES: u32 = 3;
const CIRCUIT_BREAKER_COOLDOWN_MINUTES: u64 = 30;
const MAX_DAILY_TRADES: u32 = 1000;
const JITO_CONFIRM_TIMEOUT_SECONDS: u64 = 60;

// Telegram Alerting (set these via environment variables)
// TELEGRAM_BOT_TOKEN: Your bot token from @BotFather
// TELEGRAM_CHAT_ID: Your chat/channel ID (can be negative for groups)
const TELEGRAM_ENABLED: bool = true;
const TELEGRAM_MIN_PROFIT_ALERT: f64 = 0.10;  // Minimum profit (USD) to send alert

// Persistent State Settings
const STATE_FILE_PATH: &str = "arbitrage_state.json";
const STATE_SAVE_INTERVAL_SECS: u64 = 60;

// WebSocket settings
const WS_RECONNECT_DELAY_MS: u64 = 5000;
const WS_HEARTBEAT_INTERVAL_SECS: u64 = 30;
const WS_STALE_TIMEOUT_SECS: u64 = 60;
const PRICE_STALENESS_MS: u128 = 5000;
const CACHE_REFRESH_MS: u64 = 500;

// Scanner constants
const PARALLEL_BATCH_SIZE: usize = 20;
const MIN_LIQUIDITY_USD: f64 = 1000.0;
const SPREAD_ALERT_THRESHOLD: f64 = 0.3;

// Active DEXs

const ACTIVE_DEXS: [&str; 13] = [
    "Raydium",
    "Raydium CLMM",
    "Orca",
    "Orca V2",
    "Meteora",
    "Meteora DLMM",
    "Phoenix",   // Added: On-chain Orderbook (Fast execution)
    "Lifinity",  // Added: Proactive Market Maker (Low slippage)
    "OpenBook",  // Added: CLOB
    "Invariant",
    "GooseFX",
    "StepN",
    "Cropper",
];


// ============================================================================
// --- QUOTE FRESHNESS & STALENESS DETECTION ---
// ============================================================================

/// Maximum age for quotes before they're considered stale (milliseconds)
const MAX_QUOTE_AGE_MS: u128 = 2000;  // 2 seconds - aggressive for arbitrage

/// Maximum age for WebSocket price feeds (milliseconds)
const MAX_WS_PRICE_AGE_MS: u128 = 3000;  // 3 seconds for WS feeds

/// Slot-based staleness threshold (Solana-specific)
const MAX_SLOT_STALENESS: u64 = 2;  // Quotes older than 2 slots are stale

/// Quote with full freshness tracking
#[derive(Debug, Clone)]
pub struct TimestampedQuote {
    pub quote: OrderResponse,
    pub timestamp_ms: u128,
    pub slot: Option<u64>,
    pub dex_name: String,
    pub is_stale: bool,
}

impl TimestampedQuote {
    pub fn new(quote: OrderResponse, dex_name: &str, slot: Option<u64>) -> Self {
        let timestamp_ms = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis();
        
        Self {
            quote,
            timestamp_ms,
            slot,
            dex_name: dex_name.to_string(),
            is_stale: false,
        }
    }
    
    /// Check if quote has expired based on time
    pub fn is_expired(&self) -> bool {
        let now_ms = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis();
        
        (now_ms - self.timestamp_ms) > MAX_QUOTE_AGE_MS
    }
    
    /// Check if quote is stale based on slot
    pub fn is_slot_stale(&self, current_slot: u64) -> bool {
        match self.slot {
            Some(quote_slot) => current_slot > quote_slot + MAX_SLOT_STALENESS,
            None => false, // If no slot info, rely on time-based staleness
        }
    }
    
    /// Get age in milliseconds
    pub fn age_ms(&self) -> u128 {
        let now_ms = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis();
        
        now_ms. saturating_sub(self.timestamp_ms)
    }
    
    /// Comprehensive freshness check
    pub fn is_fresh(&self, current_slot: Option<u64>) -> bool {
        if self.is_expired() {
            return false;
        }
        
        if let Some(slot) = current_slot {
            if self.is_slot_stale(slot) {
                return false;
            }
        }
        
        true
    }
}

/// Quote freshness validator
pub struct QuoteFreshnessValidator {
    pub max_age_ms: u128,
    pub max_slot_staleness: u64,
}

impl Default for QuoteFreshnessValidator {
    fn default() -> Self {
        Self {
            max_age_ms: MAX_QUOTE_AGE_MS,
            max_slot_staleness: MAX_SLOT_STALENESS,
        }
    }
}

impl QuoteFreshnessValidator {
    /// Validate a quote pair before execution
    pub async fn validate_quote_pair(
        &self,
        sell_quote: &TimestampedQuote,
        buy_quote: &TimestampedQuote,
        rpc: &AsyncRpcClient,
    ) -> Result<bool, String> {
        // Get current slot for slot-based validation
        let current_slot = match rpc.get_slot().await {
            Ok(slot) => Some(slot),
            Err(_) => None,
        };
        
        // Check sell quote freshness
        if !sell_quote.is_fresh(current_slot) {
            let age = sell_quote.age_ms();
            return Err(format!(
                "Sell quote from {} is stale (age: {}ms, max: {}ms)",
                sell_quote. dex_name, age, self.max_age_ms
            ));
        }
        
        // Check buy quote freshness
        if !buy_quote.is_fresh(current_slot) {
            let age = buy_quote. age_ms();
            return Err(format!(
                "Buy quote from {} is stale (age: {}ms, max: {}ms)",
                buy_quote. dex_name, age, self.max_age_ms
            ));
        }
        
        // Check combined age (both quotes should be obtained close together)
        let age_diff = if sell_quote.timestamp_ms > buy_quote.timestamp_ms {
            sell_quote.timestamp_ms - buy_quote.timestamp_ms
        } else {
            buy_quote.timestamp_ms - sell_quote.timestamp_ms
        };
        
        if age_diff > 1000 {
            // Quotes obtained more than 1 second apart
            return Err(format!(
                "Quote pair age difference too high: {}ms (quotes may not be comparable)",
                age_diff
            ));
        }
        
        Ok(true)
    }
    
    /// Pre-execution freshness check with re-fetch option
    pub async fn ensure_fresh_or_refetch<F, Fut>(
        &self,
        quote: &TimestampedQuote,
        current_slot: Option<u64>,
        refetch_fn: F,
    ) -> Result<TimestampedQuote, anyhow::Error>
    where
        F: FnOnce() -> Fut,
        Fut: std::future::Future<Output = Result<TimestampedQuote, anyhow::Error>>,
    {
        if quote. is_fresh(current_slot) {
            println!("   [FRESH] Quote from {} is fresh (age: {}ms)", 
                quote.dex_name, quote.age_ms());
            return Ok(quote.clone());
        }
        
        println!("   [STALE] Quote from {} is stale (age: {}ms), re-fetching...", 
            quote. dex_name, quote.age_ms());
        
        refetch_fn().await
    }
}

// ============================================================================
// --- DYNAMIC SLIPPAGE CALCULATION (FIX 2) ---
// ============================================================================

/// Configuration for dynamic slippage calculation
#[derive(Debug, Clone)]
pub struct DynamicSlippageConfig {
    /// Minimum slippage in basis points (floor)
    pub min_slippage_bps: u32,
    /// Maximum slippage in basis points (ceiling)
    pub max_slippage_bps: u32,
    /// Base slippage for normal conditions
    pub base_slippage_bps: u32,
    /// Liquidity threshold below which we increase slippage (USD)
    pub low_liquidity_threshold_usd: f64,
    /// Liquidity threshold above which we can decrease slippage (USD)
    pub high_liquidity_threshold_usd: f64,
    /// Price impact threshold for additional slippage (percentage)
    pub price_impact_threshold_pct: f64,
    /// Volatility lookback period (number of price updates)
    pub volatility_window: usize,
}

impl Default for DynamicSlippageConfig {
    fn default() -> Self {
        Self {
            min_slippage_bps: 10,       // 0.1% minimum
            max_slippage_bps: 300,      // 3.0% maximum
            base_slippage_bps: 50,      // 0.5% default
            low_liquidity_threshold_usd: 50_000.0,
            high_liquidity_threshold_usd: 500_000.0,
            price_impact_threshold_pct: 0.5,
            volatility_window: 10,
        }
    }
}

/// Volatility tracker for dynamic slippage adjustment
struct VolatilityTracker {
    price_history: std::collections::VecDeque<(std::time::Instant, f64)>,
    max_history_size: usize,
}

impl VolatilityTracker {
    fn new(max_size: usize) -> Self {
        Self {
            price_history: std::collections::VecDeque::with_capacity(max_size),
            max_history_size: max_size,
        }
    }
    
    fn add_price(&mut self, price: f64) {
        let now = std::time::Instant::now();
        self.price_history.push_back((now, price));
        
        // Remove old entries
        while self.price_history.len() > self.max_history_size {
            self.price_history.pop_front();
        }
        
        // Also remove entries older than 5 minutes
        let cutoff = now - std::time::Duration::from_secs(300);
        while let Some((time, _)) = self.price_history.front() {
            if *time < cutoff {
                self.price_history.pop_front();
            } else {
                break;
            }
        }
    }
    
    /// Calculate volatility as percentage standard deviation
    fn calculate_volatility(&self) -> f64 {
        if self.price_history.len() < 2 {
            return 0.0;
        }
        
        let prices: Vec<f64> = self.price_history.iter().map(|(_, p)| *p).collect();
        let mean = prices.iter().sum::<f64>() / prices.len() as f64;
        
        if mean == 0.0 {
            return 0.0;
        }
        
        let variance = prices.iter()
            .map(|p| {
                let diff = (p - mean) / mean * 100.0; // Percentage diff
                diff * diff
            })
            .sum::<f64>() / prices.len() as f64;
        
        variance.sqrt()
    }
}

// Global volatility tracker
lazy_static::lazy_static! {
    static ref VOLATILITY_TRACKER: Arc<TokioRwLock<VolatilityTracker>> = 
        Arc::new(TokioRwLock::new(VolatilityTracker::new(50)));
    static ref DYNAMIC_SLIPPAGE_CONFIG: DynamicSlippageConfig = 
        DynamicSlippageConfig::default();
}

/// Calculate dynamic slippage based on pool liquidity, price impact, and market volatility
/// 
/// # Arguments
/// * `liquidity_usd` - Pool liquidity in USD
/// * `trade_amount_usd` - Trade size in USD
/// * `price_impact_pct` - Expected price impact percentage
/// * `current_price` - Current token price (for volatility tracking)
/// 
/// # Returns
/// Calculated slippage in basis points (bps)
pub async fn calculate_dynamic_slippage(
    liquidity_usd: Option<f64>,
    trade_amount_usd: f64,
    price_impact_pct: Option<f64>,
    current_price: Option<f64>,
) -> u32 {
    let config = &*DYNAMIC_SLIPPAGE_CONFIG;
    let mut slippage_bps = config.base_slippage_bps;
    
    // Update volatility tracker with current price
    if let Some(price) = current_price {
        let mut tracker = VOLATILITY_TRACKER.write().await;
        tracker.add_price(price);
    }
    
    // Get current volatility
    let volatility = {
        let tracker = VOLATILITY_TRACKER.read().await;
        tracker.calculate_volatility()
    };
    
    // =========================================================================
    // Factor 1: Liquidity-based adjustment
    // Lower liquidity = higher slippage needed
    // =========================================================================
    if let Some(liquidity) = liquidity_usd {
        if liquidity < config.low_liquidity_threshold_usd {
            // Low liquidity: increase slippage proportionally
            let liquidity_factor = (config.low_liquidity_threshold_usd / liquidity.max(1000.0)).min(3.0);
            let liquidity_adjustment = ((liquidity_factor - 1.0) * 50.0) as u32;
            slippage_bps += liquidity_adjustment;
            
            if liquidity_adjustment > 0 {
                println!("   [SLIPPAGE] Low liquidity adjustment: +{} bps (liq: ${:.0})", 
                    liquidity_adjustment, liquidity);
            }
        } else if liquidity > config.high_liquidity_threshold_usd {
            // High liquidity: can afford tighter slippage
            let reduction = ((liquidity / config.high_liquidity_threshold_usd).min(2.0) - 1.0) * 10.0;
            slippage_bps = slippage_bps.saturating_sub(reduction as u32);
            
            if reduction > 0.0 {
                println!("   [SLIPPAGE] High liquidity reduction: -{:.0} bps (liq: ${:.0})", 
                    reduction, liquidity);
            }
        }
    }
    
    // =========================================================================
    // Factor 2: Trade size relative to liquidity
    // Larger trades need more slippage protection
    // =========================================================================
    if let Some(liquidity) = liquidity_usd {
        if liquidity > 0.0 {
            let trade_ratio = trade_amount_usd / liquidity;
            
            if trade_ratio > 0.01 {
                // Trade is > 1% of pool liquidity
                let size_adjustment = ((trade_ratio * 100.0).min(10.0) * 10.0) as u32;
                slippage_bps += size_adjustment;
                
                println!("   [SLIPPAGE] Trade size adjustment: +{} bps (ratio: {:.2}%)", 
                    size_adjustment, trade_ratio * 100.0);
            }
        }
    }
    
    // =========================================================================
    // Factor 3: Price impact adjustment
    // Higher expected price impact = need more slippage buffer
    // =========================================================================
    if let Some(impact) = price_impact_pct {
        let impact_abs = impact.abs();
        
        if impact_abs > config.price_impact_threshold_pct {
            // Add slippage proportional to price impact above threshold
            let impact_excess = impact_abs - config.price_impact_threshold_pct;
            let impact_adjustment = (impact_excess * 50.0).min(100.0) as u32;
            slippage_bps += impact_adjustment;
            
            println!("   [SLIPPAGE] Price impact adjustment: +{} bps (impact: {:.2}%)", 
                impact_adjustment, impact_abs);
        }
    }
    
    // =========================================================================
    // Factor 4: Volatility adjustment
    // Higher market volatility = need more slippage
    // =========================================================================
    if volatility > 0.5 {
        // Volatility above 0.5% standard deviation
        let volatility_adjustment = ((volatility - 0.5) * 30.0).min(50.0) as u32;
        slippage_bps += volatility_adjustment;
        
        println!("   [SLIPPAGE] Volatility adjustment: +{} bps (vol: {:.2}%)", 
            volatility_adjustment, volatility);
    }
    
    // =========================================================================
    // Clamp to configured bounds
    // =========================================================================
    let final_slippage = slippage_bps.clamp(config.min_slippage_bps, config.max_slippage_bps);
    
    if final_slippage != slippage_bps {
        println!("   [SLIPPAGE] Clamped from {} to {} bps", slippage_bps, final_slippage);
    }
    
    final_slippage
}

/// Simplified slippage calculation for quick quotes
/// Uses conservative defaults when detailed data isn't available
pub fn calculate_quick_slippage(
    liquidity_usd: Option<f64>,
    trade_amount_usd: f64,
) -> u32 {
    let config = &*DYNAMIC_SLIPPAGE_CONFIG;
    let mut slippage_bps = config.base_slippage_bps;
    
    // Simple liquidity-based adjustment
    if let Some(liquidity) = liquidity_usd {
        if liquidity < 25_000.0 {
            slippage_bps = 150; // Very low liquidity
        } else if liquidity < 50_000.0 {
            slippage_bps = 100; // Low liquidity
        } else if liquidity < 100_000.0 {
            slippage_bps = 75;  // Medium-low liquidity
        } else if liquidity > 1_000_000.0 {
            slippage_bps = 30;  // High liquidity
        }
        
        // Additional adjustment for trade size
        let trade_ratio = trade_amount_usd / liquidity;
        if trade_ratio > 0.005 {
            slippage_bps += 25;
        }
        if trade_ratio > 0.01 {
            slippage_bps += 25;
        }
    }
    
    slippage_bps.clamp(config.min_slippage_bps, config.max_slippage_bps)
}

// ============================================================================
// --- TELEGRAM ALERTING ---
// ============================================================================

/// Send a Telegram alert message
async fn send_telegram_alert(message: &str) {
    if !TELEGRAM_ENABLED {
        return;
    }
    
    let bot_token = match std::env::var("TELEGRAM_BOT_TOKEN") {
        Ok(token) => token,
        Err(_) => {
            // Silently skip if not configured
            return;
        }
    };
    
    let chat_id = match std::env::var("TELEGRAM_CHAT_ID") {
        Ok(id) => id,
        Err(_) => {
            return;
        }
    };
    
    let url = format!("https://api.telegram.org/bot{}/sendMessage", bot_token);
    
    let client = reqwest::Client::new();
    let payload = json!({
        "chat_id": chat_id,
        "text": message,
        "parse_mode": "HTML"
    });
    
    match client.post(&url).json(&payload).send().await {
        Ok(resp) => {
            if !resp.status().is_success() {
                eprintln!("[Telegram] Failed to send alert: HTTP {}", resp.status());
            }
        }
        Err(e) => {
            eprintln!("[Telegram] Failed to send alert: {}", e);
        }
    }
}

/// Send opportunity alert
async fn alert_opportunity_found(
    sell_dex: &str,
    buy_dex: &str,
    spread_pct: f64,
    net_profit_usd: f64,
    confidence: f64,
    token_symbol: &str,
) {
    if net_profit_usd < TELEGRAM_MIN_PROFIT_ALERT {
        return;
    }
    
    let message = format!(
        " <b>Arbitrage Opportunity</b>\n\n\
         Spread: <b>{:.3}%</b>\n\
         Est. Profit: <b>${:.3}</b>\n\
         Confidence: <b>{:.1}%</b>\n\n\
         Sell: <b>{}</b>\n\
         Buy: <b>{}</b>\n\
         Token: <b>{}</b>\n\n\
         {}",
        spread_pct, net_profit_usd, confidence,
        sell_dex, buy_dex, token_symbol,
        chrono::Local::now().format("%H:%M:%S")
    );
    
    send_telegram_alert(&message).await;
}

/// Send trade execution alert
async fn alert_trade_executed(
    success: bool,
    actual_pnl: f64,
    tx1: &str,
    tx2: &str,
    token_symbol: &str,
) {
    let emoji = if success { "" } else { "" };
    let status = if success { "SUCCESS" } else { "FAILED" };
    
    let message = format!(
        "{} <b>Trade {}</b>\n\n\
         P&L: <b>${:.3}</b>\n\
         Token: {}\n\n\
         Tx1: <code>{}</code>\n\
         Tx2: <code>{}</code>\n\n\
         {}",
        emoji, status, actual_pnl, token_symbol,
        &tx1[..16.min(tx1.len())],
        &tx2[..16.min(tx2.len())],
        chrono::Local::now().format("%H:%M:%S")
    );
    
    send_telegram_alert(&message).await;
}

/// Send circuit breaker alert
async fn alert_circuit_breaker(reason: &str, until: &str) {
    let message = format!(
        " <b>CIRCUIT BREAKER ACTIVATED</b>\n\n\
         Reason: {}\n\
         Active until: {}\n\n\
        Bot trading is paused.",
        reason, until
    );
    
    send_telegram_alert(&message).await;
}

/// Send daily summary alert
async fn alert_daily_summary(
    daily_pnl: f64,
    trades_count: u32,
    success_rate: f64,
) {
    let emoji = if daily_pnl >= 0.0 { "" } else { "" };
    
    let message = format!(
        " <b>Daily Summary</b>\n\n\
        {} P&L: <b>${:.2}</b>\n\
         Trades: <b>{}</b>\n\
         Success Rate: <b>{:.1}%</b>\n\n\
         {}",
        emoji, daily_pnl, trades_count, success_rate,
        chrono::Local::now().format("%Y-%m-%d %H:%M")
    );
    
    send_telegram_alert(&message).await;
}

// ============================================================================
// --- PERSISTENT STATE ---
// ============================================================================

/// Persistent state that survives restarts
#[derive(Debug, Clone, Serialize, Deserialize)]
struct PersistentState {
    daily_pnl: f64,
    trades_today: u32,
    consecutive_failures: u32,
    last_reset_date: String,  // ISO date string
    total_profit_all_time: f64,
    total_trades_all_time: u32,
    successful_trades_all_time: u32,
    circuit_breaker_until: Option<String>,  // ISO datetime string
    last_saved: String,  // ISO datetime
}

impl PersistentState {
    fn new() -> Self {
        PersistentState {
            daily_pnl: 0.0,
            trades_today: 0,
            consecutive_failures: 0,
            last_reset_date: chrono::Local::now().format("%Y-%m-%d").to_string(),
            total_profit_all_time: 0.0,
            total_trades_all_time: 0,
            successful_trades_all_time: 0,
            circuit_breaker_until: None,
            last_saved: chrono::Local::now().to_rfc3339(),
        }
    }
    
    fn load() -> Self {
        match fs::read_to_string(STATE_FILE_PATH) {
            Ok(content) => {
                match serde_json::from_str(&content) {
                    Ok(state) => {
                        println!(" Loaded persistent state from {}", STATE_FILE_PATH);
                        state
                    }
                    Err(e) => {
                        eprintln!(" Failed to parse state file: {}, starting fresh", e);
                        PersistentState::new()
                    }
                }
            }
            Err(_) => {
                println!(" No existing state file, starting fresh");
                PersistentState::new()
            }
        }
    }
    
    fn save(&mut self) {
        self.last_saved = chrono::Local::now().to_rfc3339();
        
        match serde_json::to_string_pretty(self) {
            Ok(content) => {
                if let Err(e) = fs::write(STATE_FILE_PATH, content) {
                    eprintln!(" Failed to save state: {}", e);
                }
            }
            Err(e) => {
                eprintln!(" Failed to serialize state: {}", e);
            }
        }
    }
    
    fn check_daily_reset(&mut self) {
        let today = chrono::Local::now().format("%Y-%m-%d").to_string();
        if today != self.last_reset_date {
            // Send daily summary before resetting
            let success_rate = if self.trades_today > 0 {
                (self.successful_trades_all_time as f64 / self.total_trades_all_time as f64) * 100.0
            } else {
                0.0
            };
            
            // Spawn alert (don't await to avoid blocking)
            let pnl = self.daily_pnl;
            let trades = self.trades_today;
            tokio::spawn(async move {
                alert_daily_summary(pnl, trades, success_rate).await;
            });
            
            println!("\n Daily Reset - Previous day P&L: ${:.2}", self.daily_pnl);
            self.daily_pnl = 0.0;
            self.trades_today = 0;
            self.last_reset_date = today;
            self.save();
        }
    }
}

// ============================================================================
// --- ENHANCED WEBSOCKET STRUCTURES ---
// ============================================================================

/// Data source indicator for price updates
#[derive(Debug, Clone)]
enum DataSource {
    WebSocket,
    API,
}

/// Enhanced price update with complete metadata
#[derive(Debug, Clone)]
struct EnhancedPriceUpdate {
    dex: String,
    token_pair: String,
    price: f64,
    timestamp: TokioInstant,
    liquidity: Option<f64>,
    data_source: DataSource,
    pool_address: String,
    reserve_token_a: Option<u64>,
    reserve_token_b: Option<u64>,
}

type EnhancedPriceCache = Arc<RwLock<HashMap<String, EnhancedPriceUpdate>>>;

fn create_enhanced_price_cache() -> EnhancedPriceCache {
    Arc::new(RwLock::new(HashMap::new()))
}

// ============================================================================
// --- PRICE CALCULATION FUNCTIONS ---
// ============================================================================

/// Calculate price from constant product AMM (x * y = k)
/// Returns price as quote_token / base_token
fn calculate_price_from_constant_product(
    reserve_a: u64,
    reserve_b: u64,
    decimals_a: u8,
    decimals_b: u8,
) -> f64 {
    if reserve_a == 0 {
        return 0.0;
    }
    
    let reserve_a_f64 = reserve_a as f64 / 10_f64.powi(decimals_a as i32);
    let reserve_b_f64 = reserve_b as f64 / 10_f64.powi(decimals_b as i32);
    reserve_b_f64 / reserve_a_f64
}

/// Calculate price from sqrt_price_x64 (used in CLMM/concentrated liquidity pools)
/// Formula: price = (sqrt_price / 2^64)^2
fn calculate_price_from_sqrt_price_x64(
    sqrt_price_x64_str: &str,
    decimals_a: u8,
    decimals_b: u8,
) -> Option<f64> {
    let sqrt_price_x64: u128 = sqrt_price_x64_str.parse().ok()?;
    let sqrt_price = sqrt_price_x64 as f64 / (1u128 << 64) as f64;
    let price = sqrt_price * sqrt_price;
    
    // Adjust for decimal differences
    let decimal_adjustment = 10_f64.powi((decimals_b as i32) - (decimals_a as i32));
    Some(price * decimal_adjustment)
}

/// Calculate total liquidity in USD
fn calculate_liquidity_usd(
    reserve_a: u64,
    reserve_b: u64,
    price_a_usd: f64,
    decimals_a: u8,
    decimals_b: u8,
) -> f64 {
    if reserve_a == 0 || reserve_b == 0 {
        return 0.0;
    }
    
    let reserve_a_f64 = reserve_a as f64 / 10_f64.powi(decimals_a as i32);
    let reserve_b_f64 = reserve_b as f64 / 10_f64.powi(decimals_b as i32);
    
    let value_a_usd = reserve_a_f64 * price_a_usd;
    let price = reserve_b_f64 / reserve_a_f64;
    let price_b_usd = price_a_usd * price;
    let value_b_usd = reserve_b_f64 * price_b_usd;
    
    value_a_usd + value_b_usd
}

// ============================================================================
// --- WEBSOCKET FEED SUBSCRIPTION (ENHANCED & FIXED) ---
// ============================================================================
/// Connect to WebSocket and monitor pool account updates (FIXED)

/// Shared WebSocket connection that multiplexes all pool subscriptions
async fn connect_and_monitor_pools_shared(
    subscriptions: Vec<(String, String)>,  // Vec of (dex_name, pool_address)
    price_cache: EnhancedPriceCache,
    token_a_mint: &str, // NEW PARAMETER
    token_b_mint: &str, // NEW PARAMETER
) -> anyhow::Result<()> {
    // Create RPC client for fetching token decimals
    let rpc = AsyncRpcClient::new_with_commitment(
        QUICKNODE_RPC_URL.to_string(),
        CommitmentConfig::confirmed(),
    );
    
    let (ws_stream, _) = connect_async(QUICKNODE_WS_URL).await?;
    let (mut write, mut read) = ws_stream.split();
    
    // Map subscription IDs to (dex_name, pool_address)
    let mut subscription_map: HashMap<u64, (String, String)> = HashMap::new();
    
    println!(" Single WebSocket connection established");
    println!(" Subscribing to {} pools...\n", subscriptions.len());
    
    // Send subscription requests for ALL pools on this single connection
    for (idx, (dex_name, pool_address)) in subscriptions.iter().enumerate() {
        let request_id = (idx + 1) as u64;
        
        let subscribe_msg = json!({
            "jsonrpc": "2.0",
            "id": request_id,
            "method": "accountSubscribe",
            "params": [
                pool_address,
                {
                    "encoding": "base64",
                    "commitment": "confirmed"
                }
            ]
        });
        
        write.send(Message::Text(subscribe_msg.to_string())).await?;
        println!("   [{}] Subscribed to pool {}... (id: {})", dex_name, &pool_address[..12], request_id);
        
        // Store mapping: request_id -> (dex_name, pool_address)
        subscription_map.insert(request_id, (dex_name.clone(), pool_address.clone()));
        
        // Small delay between subscriptions to avoid rate limiting
        tokio::time::sleep(Duration::from_millis(100)).await;
    }
    
    println!("\n All {} subscriptions sent on single connection", subscriptions.len());
    
    // Map subscription result IDs to pool info
    let mut result_id_to_pool: HashMap<u64, (String, String)> = HashMap::new();
    
    let mut ping_interval = tokio::time::interval(Duration::from_secs(WS_HEARTBEAT_INTERVAL_SECS));
    let mut last_update = TokioInstant::now();
    let mut update_count = 0u32;
    let mut message_count = 0u32;
    let mut confirmed_subscriptions = 0usize;
    
    loop {
        tokio::select! {
            _ = ping_interval.tick() => {
                if write.send(Message::Ping(vec![])).await.is_err() {
                    println!(" Ping failed, reconnecting...");
                    break;
                }
                
                if last_update.elapsed().as_secs() > WS_STALE_TIMEOUT_SECS {
                    println!(" No updates for {}s, reconnecting...", WS_STALE_TIMEOUT_SECS);
                    break;
                }
                
                // Get cache stats
                let cache = price_cache.read().await;
                let active_prices = cache.len();
                drop(cache);
                
                println!(" Heartbeat | Subs: {}/{} | Msgs: {} | Updates: {} | Cache: {} | Age: {}s", 
                    confirmed_subscriptions, subscriptions.len(),
                    message_count, update_count, active_prices,
                    last_update.elapsed().as_secs());
            }
            msg = read.next() => {
                match msg {
                    Some(Ok(Message::Text(text))) => {
                        message_count += 1;
                        
                        if let Ok(data) = serde_json::from_str::<serde_json::Value>(&text) {
                            // Handle subscription confirmation
                            if let Some(result) = data.get("result") {
                               if let (Some(request_id), Some(sub_id)) = (data.get("id").and_then(|i| i.as_u64()), result.as_u64()) {
                                  if let Some((dex_name, pool_address)) = subscription_map.get(&request_id) {
                                    result_id_to_pool.insert(sub_id, (dex_name.clone(), pool_address.clone()));
                                    confirmed_subscriptions += 1;
                                      println!("    [{}] Subscription confirmed (request_id: {} -> sub_id: {})", 
                                        dex_name, request_id, sub_id);
                                           println!("    [{}] Mapped: sub_id {} -> pool {}...", 
                                            dex_name, sub_id, &pool_address[..12]);
                                           } else {
                                  println!("    Received subscription confirmation for unknown request_id: {}", request_id);
        }
    }
    continue;
} 
                    

// Handle account notification
if data.get("method").and_then(|m| m.as_str()) == Some("accountNotification") {
    if let Some(params) = data.get("params") {
        println!(" Received notification for sub_id: {:?}", params.get("subscription"));
        
        // Get subscription ID to identify which pool this is for
        if let Some(sub_id) = params.get("subscription").and_then(|s| s.as_u64()) {
            println!("   -> Subscription ID: {}", sub_id);
            
            if let Some((dex_name, pool_address)) = result_id_to_pool.get(&sub_id) {
                println!("   -> Routed to: {} (pool: {}...)", dex_name, &pool_address[..12]);
                
                //  FIX: Pass price_cache instead of cache
                if let Some(price_update) = parse_account_update_shared(
                    &data, 
                    dex_name, 
                    pool_address, 
                    price_cache.clone(),  //  Changed from 'cache' to 'price_cache'
                    token_a_mint,
                    token_b_mint,
                    &rpc,
                ).await {
                    // Use dynamic cache key based on DEX + pool address for uniqueness
                    // Format: "Orca-Czfq3xZZ-So111111/EPjFWdd5"
                    let pool_prefix = &pool_address[..8.min(pool_address.len())];
                    let key = format!("{}-{}", dex_name, pool_prefix);
                    price_cache.write().await.insert(key.clone(), price_update);
                    last_update = TokioInstant::now();
                    update_count += 1;
                    
                    if update_count <= 10 || update_count % 50 == 0 {
                        println!("    [{}] Price updated -> {} (total: {})", dex_name, key, update_count);
                    }
                }
            } else {
                println!("    No mapping found for sub_id: {}", sub_id);
                println!("   Available mappings:");
                for (sid, (dex, pool)) in result_id_to_pool.iter() {
                    println!("      {} -> {} ({}...)", sid, dex, &pool[..12]);
                }
            }
        } else {
            println!("    Notification missing subscription field");
        }
    }
}
}
                    }
                    Some(Ok(Message::Pong(_))) => {
                        // Silent
                    }
                    Some(Ok(Message::Close(reason))) => {
                        println!(" WebSocket closed: {:?}", reason);
                        break;
                    }
                    None => {
                        println!(" WebSocket stream ended");
                        break;
                    }
                    Some(Err(e)) => {
                        eprintln!(" WebSocket error: {}", e);
                        break;
                    }
                    _ => {}
                }
            }
        }
    }
    
    println!(" Connection stats: Messages: {}, Updates: {}, Confirmed: {}/{}", 
        message_count, update_count, confirmed_subscriptions, subscriptions.len());
    Ok(())
}


// ============================================================================
// --- PRICE DIRECTION CORRECTION ---
// ============================================================================

/// Correct price direction using Jupiter reference price
/// This handles cases where pools store tokens in different orders (A/B vs B/A)
/// Returns the corrected price (either original or inverted)
/// Correct price direction using Jupiter reference price
/// Returns None if the price is more than 50% off expected (likely bad data)
async fn correct_price_direction(
    raw_price: f64,
    dex_name: &str,
    base_token_mint: &str,
    quote_token_mint: &str,
) -> Option<f64> {
    // Skip correction for SOL/USDC pairs (usually correct)
    if (base_token_mint == SOL_MINT && quote_token_mint == USDC_MINT) ||
       (base_token_mint == USDC_MINT && quote_token_mint == SOL_MINT) {
        return Some(raw_price);
    }
    
    // Get Jupiter prices for both tokens to calculate expected ratio
    let base_usd_price = get_jupiter_token_price(base_token_mint).await;
    let quote_usd_price = get_jupiter_token_price(quote_token_mint).await;
    
    if base_usd_price <= 0.0 || quote_usd_price <= 0.0 {
        println!("[{}] [PRICE_CORRECT] Cannot get Jupiter prices, using raw price", dex_name);
        return Some(raw_price);
    }
    
    // Expected price = base_usd / quote_usd
    let expected_price = base_usd_price / quote_usd_price;
    let reciprocal_price = if raw_price > 0.0 { 1.0 / raw_price } else { 0.0 };
    
    // Calculate deviations
    let raw_deviation = if expected_price > 0.0 {
        ((raw_price - expected_price) / expected_price).abs()
    } else {
        f64::MAX
    };
    
    let reciprocal_deviation = if expected_price > 0.0 {
        ((reciprocal_price - expected_price) / expected_price).abs()
    } else {
        f64::MAX
    };
    
    println!("[{}] [PRICE_CORRECT] Raw: {:.8}, Reciprocal: {:.8}, Expected: {:.8}", 
        dex_name, raw_price, reciprocal_price, expected_price);
    println!("[{}] [PRICE_CORRECT] Raw deviation: {:.2}%, Reciprocal deviation: {:.2}%", 
        dex_name, raw_deviation * 100.0, reciprocal_deviation * 100.0);
    
    // Determine the best price and its deviation
    let (best_price, best_deviation, direction) = if reciprocal_deviation < raw_deviation {
        (reciprocal_price, reciprocal_deviation, "RECIPROCAL")
    } else {
        (raw_price, raw_deviation, "RAW")
    };
    
    // =========================================================================
    // IMPROVED THRESHOLD LOGIC (FIX 3)
    // =========================================================================
    // Different pools can have different reserve ratios due to:
    //   - Arbitrage lag between pools
    //   - Different fee structures  
    //   - Price impact from recent large trades
    //
    // Tiered acceptance:
    //   - < 25% deviation: HIGH confidence
    //   - 25-50% deviation: MEDIUM confidence
    //   - 50-75% deviation: LOW confidence (still accept)
    //   - > 75% deviation: REJECT
    // =========================================================================
    
    const HIGH_CONFIDENCE_THRESHOLD: f64 = 0.25;   // 25%
    const MEDIUM_CONFIDENCE_THRESHOLD: f64 = 0.50; // 50%
    const LOW_CONFIDENCE_THRESHOLD: f64 = 0.75;    // 75% (INCREASED from 50%)
    
    if best_deviation <= HIGH_CONFIDENCE_THRESHOLD {
        println!("[{}] [PRICE_CORRECT] HIGH CONFIDENCE: Using {} price ({:.1}% deviation)", 
            dex_name, direction, best_deviation * 100.0);
        return Some(best_price);
    }
    
    if best_deviation <= MEDIUM_CONFIDENCE_THRESHOLD {
        println!("[{}] [PRICE_CORRECT] MEDIUM CONFIDENCE: Using {} price ({:.1}% deviation)", 
            dex_name, direction, best_deviation * 100.0);
        return Some(best_price);
    }
    
    if best_deviation <= LOW_CONFIDENCE_THRESHOLD {
        // Check if one direction is significantly better than the other
        let direction_ratio = if raw_deviation > 0.0 && reciprocal_deviation > 0.0 {
            (raw_deviation / reciprocal_deviation).max(reciprocal_deviation / raw_deviation)
        } else {
            1.0
        };
        
        // If one direction is at least 10x better, use it with confidence
        if direction_ratio >= 10.0 {
            println!("[{}] [PRICE_CORRECT] LOW CONFIDENCE (clear direction): Using {} price ({:.1}% deviation)", 
                dex_name, direction, best_deviation * 100.0);
            return Some(best_price);
        }
        
        // Otherwise, still accept but with warning
        println!("[{}] [PRICE_CORRECT] LOW CONFIDENCE: Accepting {} price ({:.1}% deviation)", 
            dex_name, direction, best_deviation * 100.0);
        println!("[{}] [PRICE_CORRECT] Note: Reserve ratio may differ from market price", dex_name);
        return Some(best_price);
    }
    
    // > 75% deviation - reject
    println!("[{}] [PRICE_CORRECT] REJECTED: Best price {:.8} is {:.1}% off expected {:.8}", 
        dex_name, best_price, best_deviation * 100.0, expected_price);
    println!("[{}] [PRICE_CORRECT] This pool likely has wrong token order or stale reserves", dex_name);
    None
}

/// Get token price from Jupiter API
async fn get_jupiter_token_price(mint: &str) -> f64 {
    // Handle known tokens with special mints
    if mint == SOL_MINT {
        // Fetch SOL price
        if let Ok(info) = search_token_by_address(mint).await {
            if let Some(price) = info.usd_price {
                return price;
            }
        }
        return 0.0;
    }
    
    // For other tokens, use Jupiter API
    match search_token_by_address(mint).await {
        Ok(info) => info.usd_price.unwrap_or(0.0),
        Err(_) => 0.0,
    }
}


/// Parse account update for shared WebSocket - WITH VALIDATION

async fn parse_account_update_shared(
    data: &serde_json::Value,
    dex_name: &str,
    pool_address: &str,
    price_cache: EnhancedPriceCache,  //  Add this parameter
    token_a_mint: &str, // NEW PARAMETER
    token_b_mint: &str, // NEW PARAMETER
    rpc: &AsyncRpcClient, // NEW PARAMETER
) -> Option<EnhancedPriceUpdate> {
    let params = data.get("params")?;
    let result = params.get("result")? ;
    let value = result.get("value")? ;
    let account_data = value.get("data")?;

    let base64_str = if let Some(arr) = account_data.as_array() {
        arr.get(0).and_then(|v| v.as_str())?
    } else if let Some(s) = account_data.as_str() {
        s
    } else {
        println!("[{}]  Invalid account data format (pool: {})", dex_name, &pool_address[..12]);
        return None;
    };

    let decoded = match general_purpose::STANDARD.decode(base64_str) {
        Ok(d) => d,
        Err(e) => {
            println! ("[{}]  Base64 decode error: {} (pool: {})", dex_name, e, &pool_address[..12]);
            return None;
        }
    };

    let data_len = decoded.len();
    println!("[{}]  Received update: {} bytes (pool: {}... )",
        dex_name, data_len, &pool_address[..12]);

    // Parse based on DEX type
    let dex_lower = dex_name.to_lowercase();

    let price_update = if dex_lower.contains("raydium") {
        println!("[{}]  Routing to Raydium parser...", dex_name);

        if data_len >= 1544 {
            println!("[{}] -> Attempting CLMM parse", dex_name);
            parse_raydium_clmm_binary(&decoded, dex_name, pool_address). await
        } else {
            println!("[{}] -> Attempting AMM parse", dex_name);
            parse_raydium_amm_binary(&decoded, dex_name, pool_address).await
        }

    } else if dex_lower.contains("orca") {
        println!("[{}]  Routing to Orca Whirlpool parser", dex_name);
        // FIXED: Fetch decimals from cache first, then pass to parser
        let (dec_a, dec_b) = get_token_pair_decimals(rpc, token_a_mint, token_b_mint).await;
        // Now passing u8 decimals instead of Option<&str> mints
        parse_orca_whirlpool_binary(&decoded, dex_name, pool_address, dec_a, dec_b).await
    } else if dex_lower.contains("meteora") {
        println!("[{}]  Routing to Meteora parser", dex_name);
        parse_meteora_binary(&decoded, dex_name, pool_address, token_a_mint, token_b_mint, rpc).await
    } else if dex_lower.contains("pumpswap") || dex_lower.contains("pump") {
        println!("[{}]  Routing to PumpSwap parser", dex_name);
        parse_pumpswap_binary(&decoded, dex_name, pool_address, token_a_mint, token_b_mint, rpc).await
    } else {
        println!("[{}]  Unknown DEX type", dex_name);
        None
    }?;

    // === PRICE DIRECTION CORRECTION ===
    // Correct inverted prices using Jupiter reference
    // Returns None if price is >50% off expected (bad data)
    let corrected_price = match correct_price_direction(
        price_update.price,
        dex_name,
        token_a_mint,
        token_b_mint,
    ). await {
        Some(price) => price,
        None => {
            println!("[{}] [REJECTED] Price rejected by direction correction (>50% deviation)", dex_name);
            return None;
        }
    };

    // Create corrected price update
    let mut price_update = price_update;
    if (corrected_price - price_update.price).abs() > 0.0001 {
        println!("[{}] [CORRECTED] Price changed from {:.8} to {:.8}",
            dex_name, price_update.price, corrected_price);
        price_update.price = corrected_price;
    }

    //  VALIDATE PRICE BEFORE RETURNING

    // === DYNAMIC VALIDATION BASED ON TOKEN TYPE ===
    let is_sol_pair = (token_a_mint == SOL_MINT && token_b_mint == USDC_MINT) ||
                      (token_a_mint == USDC_MINT && token_b_mint == SOL_MINT);

    if is_sol_pair {
        // SOL/USDC: Use strict validation with bounds
        let sol_validator = PriceValidator {
            config: PriceValidationConfig::for_sol(),
        };

        let validation_result = sol_validator.validate_price(
            dex_name,
            price_update.price,
            &price_cache,
            token_a_mint,
            token_b_mint,
        ).await;

        match validation_result {
            ValidationResult::Valid => {
                println!("[{}]  SOL price validation passed", dex_name);
                Some(price_update)
            },
            ValidationResult::InvalidDeviation { price, reference, deviation } => {
                println!("[{}]  Price REJECTED by validation", dex_name);
                println!("[{}]    Price: ${:.6}", dex_name, price);
                println!("[{}]    Reference: ${:.6}", dex_name, reference);
                println!("[{}]    Deviation: {:.2}%", dex_name, deviation);
                None
            },
            ValidationResult::InvalidSpread { spread, max_allowed } => {
                println!("[{}]  CIRCUIT BREAKER TRIGGERED", dex_name);
                println!("[{}]    Spread: {:.2}%", dex_name, spread);
                println!("[{}]    Max allowed: {:.1}%", dex_name, max_allowed);
                None
            },
            ValidationResult::InvalidBounds { price, min, max } => {
                println!("[{}]  SOL price outside bounds", dex_name);
                println!("[{}]    Price: ${:.2}", dex_name, price);
                println!("[{}]    Bounds: ${:.0} - ${:.0}", dex_name, min, max);
                None
            },
            ValidationResult::NoReferencePrices => {
                println!("[{}]  No reference prices yet, accepting", dex_name);
                Some(price_update)
            },
            ValidationResult::Stale { age_ms, max_age_ms } => {
                println!("[{}]  Price data is stale", dex_name);
                println!("[{}]    Age: {}ms (max: {}ms)", dex_name, age_ms, max_age_ms);
                None
            },
        }
    } else {
        // Custom token: Skip bounds, only check deviation if references exist
        let cache = price_cache.read().await;
        let has_references = ! cache.is_empty();
        drop(cache);

        if ! has_references {
            // First price for this custom token - accept it
            println!("[{}]  First price for custom token, accepting: ${:.6}",
                dex_name, price_update.price);
            Some(price_update)
        } else {
            // Validate deviation only (no bounds check)
            let custom_validator = PriceValidator {
                config: PriceValidationConfig::for_custom_token(),
            };

            let validation_result = custom_validator.validate_price(
                dex_name,
                price_update.price,
                &price_cache,
                token_a_mint,
                token_b_mint,
            ).await;

            match validation_result {
                ValidationResult::Valid => {
                    println!("[{}]  Custom token price validated", dex_name);
                    Some(price_update)
                },
                ValidationResult::InvalidDeviation { price, reference, deviation } => {
                    println! ("[{}]  Custom token deviation too high: {:.2}%", dex_name, deviation);
                    println!("[{}]    Price: ${:.6}, Ref: ${:.6}", dex_name, price, reference);
                    // Accept anyway for custom tokens with lenient threshold
                    if deviation < 20.0 {
                        println!("[{}]  Accepting despite deviation (< 20%)", dex_name);
                        Some(price_update)
                    } else {
                        None
                    }
                },
                ValidationResult::NoReferencePrices => {
                    println!("[{}]  Accepting custom token price (no refs)", dex_name);
                    Some(price_update)
                },
                _ => {
                    // Accept most validation results for custom tokens
                    println!("[{}]  Custom token validation passed", dex_name);
                    Some(price_update)
                }
            }
        }
    }
}  // <-- THIS WAS THE MISSING CLOSING BRACE

/// Parse account data directly from RPC fetch (not WebSocket notification)
async fn parse_account_update_from_bytes(
    data: &[u8],
    dex_name: &str,
    pool_address: &str,
    _price_cache: EnhancedPriceCache,
    token_a_mint: &str,
    token_b_mint: &str,
    rpc: &AsyncRpcClient,
) -> Option<EnhancedPriceUpdate> {
    let data_len = data.len();
    
    println!("[{}] [RPC] Parsing {} bytes from {}...", dex_name, data_len, &pool_address[..12]);
    
    // Route to correct parser based on DEX name and data size
    if dex_name.to_lowercase().contains("orca") {
        // FIX: Fetch decimals from cache
        let (dec_a, dec_b) = get_token_pair_decimals(rpc, token_a_mint, token_b_mint).await;
        parse_orca_whirlpool_binary(data, dex_name, pool_address, dec_a, dec_b).await
    } else if dex_name.to_lowercase().contains("raydium") {
        if data_len >= 1544 {
            parse_raydium_clmm_binary(data, dex_name, pool_address). await
        } else {
            parse_raydium_amm_binary(data, dex_name, pool_address).await
        }
    } else if dex_name.to_lowercase().contains("meteora") {
        parse_meteora_binary(data, dex_name, pool_address, token_a_mint, token_b_mint, rpc).await
    } else if dex_name.to_lowercase().contains("pumpswap") || dex_name.to_lowercase().contains("pump") {
        parse_pumpswap_binary(data, dex_name, pool_address, token_a_mint, token_b_mint, rpc).await
    } else {
        println!("[{}] [RPC] Unknown DEX type for parsing", dex_name);
        None
    }
}


// ============================================================================
// --- FIXED RAYDIUM AMM PARSER (with validation) ---
// ============================================================================

async fn parse_raydium_amm_binary(
    data: &[u8],
    dex_name: &str,
    pool_address: &str,
) -> Option<EnhancedPriceUpdate> {
    println!("[{}] [PARSE] AMM parse start: {} bytes", dex_name, data.len());
    
    if data.len() < 700 {
        println!("[{}] [X] Data too small for AMM: {} < 700", dex_name, data.len());
        return None;
    }

    // Raydium AMM V4 layout
    let offset = match data.len() {
        700..=799 => {
            println!("[{}] -> Compact AMM V4 layout (700-799 bytes)", dex_name);
            8
        },
        _ => {
            println!("[{}] -> Standard AMM V4 layout (752+ bytes)", dex_name);
            8
        }
    };

    // Read swap amounts (these are cumulative values)
    let swap_coin_in = read_u128_le(data, offset + 216)?;
    let swap_pc_out = read_u128_le(data, offset + 232)?;
    let swap_pc_in = read_u128_le(data, offset + 256)?;
    let swap_coin_out = read_u128_le(data, offset + 272)?;

    println!("[{}] [STAT] Swap amounts:", dex_name);
    println!("[{}]    coin_in: {}, pc_out: {}", dex_name, swap_coin_in, swap_pc_out);
    println!("[{}]    pc_in: {}, coin_out: {}", dex_name, swap_pc_in, swap_coin_out);

    // Calculate current reserves from swap deltas
    let reserve_a = (swap_coin_in.wrapping_sub(swap_coin_out)) as u64;
    let reserve_b = (swap_pc_in.wrapping_sub(swap_pc_out)) as u64;

    let reserve_a_f64 = reserve_a as f64 / 1e9;
    let reserve_b_f64 = reserve_b as f64 / 1e6;

    println!("[{}] [CALC] Price calculation:", dex_name);
    println!("[{}]    Reserve A: {} ({:.4} SOL)", dex_name, reserve_a, reserve_a_f64);
    println!("[{}]    Reserve B: {} ({:.2} USDC)", dex_name, reserve_b, reserve_b_f64);

    // *** ADD VALIDATION HERE ***
    // Check for unrealistic reserve sizes (indicates wrong pool)
    if reserve_a_f64 > 100_000_000.0 || reserve_b_f64 > 10_000_000_000.0 {
        println!("[{}] [X] Reserves unrealistic - likely wrong token pair", dex_name);
        println!("[{}]    Reserve A: {:.2} SOL (expected < 100M)", dex_name, reserve_a_f64);
        println!("[{}]    Reserve B: {:.2} USDC (expected < 10B)", dex_name, reserve_b_f64);
        println!("[{}]    Pool: {}", dex_name, pool_address);
        return None;
    }
    
    // Check for minimum realistic liquidity
    if reserve_a_f64 < 1.0 || reserve_b_f64 < 100.0 {
        println!("[{}] [X] Reserves too small (A: {:.2} SOL, B: {:.2} USDC)", 
            dex_name, reserve_a_f64, reserve_b_f64);
        return None;
    }

    let price = calculate_price_from_constant_product(reserve_a, reserve_b, 9, 6);
    
    println!("[{}]    Calculated price: ${:.6}", dex_name, price);

    // Sanity check price
    if !(50.0..=500.0).contains(&price) {
        println!("[{}] [X] Price out of range: ${:.6}", dex_name, price);
        return None;
    }

    let liquidity = calculate_liquidity_usd(reserve_a, reserve_b, price, 9, 6);

    println!("[{}] [OK] AMM parse successful: ${:.4} | Liq: ${:.2}", 
        dex_name, price, liquidity);

    Some(EnhancedPriceUpdate {
        dex: dex_name.to_string(),
        token_pair: "SOL/USDC".to_string(),
        price,
        timestamp: TokioInstant::now(),
        liquidity: Some(liquidity),
        data_source: DataSource::WebSocket,
        pool_address: pool_address.to_string(),
        reserve_token_a: Some(reserve_a),
        reserve_token_b: Some(reserve_b),
    })
}


/// Parse Raydium CLMM from binary data (ENHANCED with logging)

async fn parse_raydium_clmm_binary(
    data: &[u8],
    dex_name: &str,
    pool_address: &str,
) -> Option<EnhancedPriceUpdate> {
    println!("[{}]  CLMM parse start: {} bytes", dex_name, data. len());
    
    if data.len() < 1544 {
        println!("[{}]  Data too small for CLMM: {} < 1544", dex_name, data.len());
        return None;
    }

    let offset = 8;
    
    // Read decimals from pool account (always correct from on-chain data)
    let decimals_0 = data.get(offset + 225).copied(). unwrap_or(9) as i32;
    let decimals_1 = data.get(offset + 226).copied().unwrap_or(6) as i32;
    
    println! ("[{}]  Decimals: token0={}, token1={}", dex_name, decimals_0, decimals_1);
    
    // Read liquidity
    let liquidity = match read_u128_le(data, offset + 229) {
        Some(liq) => {
            println!("[{}]  Liquidity: {}", dex_name, liq);
            liq
        },
        None => {
            println!("[{}]  Failed to read liquidity", dex_name);
            0
        }
    };

    // Read sqrt_price (Q64.64 fixed point)
    let sqrt_price_x64 = match read_u128_le(data, offset + 245) {
        Some(sp) => {
            println!("[{}]  sqrt_price_x64: {}", dex_name, sp);
            sp
        },
        None => {
            println!("[{}]  Failed to read sqrt_price", dex_name);
            return None;
        }
    };

    if sqrt_price_x64 == 0 {
        println! ("[{}]  Zero sqrt_price - pool may be inactive", dex_name);
        return None;
    }

        // Convert Q64. 64 to float and square it
        
    let sqrt_price = sqrt_price_x64 as f64 / ((1_u128 << 64) as f64);
    let raw_price = sqrt_price * sqrt_price;
    
    println!("[{}]  Calculation steps:", dex_name);
    println!("[{}]    sqrt_price_x64: {}", dex_name, sqrt_price_x64);
    println! ("[{}]    sqrt_price: {:.10}", dex_name, sqrt_price);
    println!("[{}]    raw_price: {:.10}", dex_name, raw_price);
    
    // Try normal direction first
    let decimal_adjustment = 10_f64.powi(decimals_0 - decimals_1);
    let price_normal = raw_price * decimal_adjustment;

    println!("[{}]  Final price: ${:.6} (adj: {})", dex_name, price_normal, decimal_adjustment);

    // Add inverse logic with tighter range check
    let price = if (0.000001..=100_000_000.0).contains(&price_normal) {
        // Normal direction looks reasonable
        println!("[{}]  Using normal price direction", dex_name);
        price_normal
    } else {
        // Try inverse direction
        println!("[{}]  CLMM price out of range: ${:.6}", dex_name, price_normal);
        
        let decimal_adjustment_inv = 10_f64.powi(decimals_1 - decimals_0);
        let inverse_price = if raw_price > 0.0 {
            (1.0 / raw_price) * decimal_adjustment_inv
        } else {
            0.0
        };
        
        println!("[{}]    Trying inverse: ${:.6}", dex_name, inverse_price);
        
        if (0.01..=100_000.0).contains(&inverse_price) {
            println!("[{}]    Using inverted price", dex_name);
            inverse_price
        } else {
            println!("[{}]    Both directions failed - invalid price", dex_name);
            return None;
        }
    };
    
    // Calculate liquidity in USD
    let liquidity_usd = (liquidity as f64 / 1e12) * price;

    println!("[{}]  CLMM parse successful: ${:.4} | Liq: ${:.2}",
    dex_name, price, liquidity_usd);
    Some(EnhancedPriceUpdate {
        dex: dex_name.to_string(),
        token_pair: "CUSTOM".to_string(),
        price,
        timestamp: TokioInstant::now(),
        liquidity: Some(liquidity_usd),
        data_source: DataSource::WebSocket,
        pool_address: pool_address.to_string(),
        reserve_token_a: None,
        reserve_token_b: None,
    })
}

/// Parse Raydium CLMM from already-parsed JSON (FIXED)
async fn parse_raydium_clmm_from_parsed(
    parsed: &serde_json::Value,
    dex_name: &str,
    pool_address: &str,
) -> Option<EnhancedPriceUpdate> {
    let info = parsed.get("info")?;
    
    let sqrt_price_x64 = info.get("sqrtPriceX64")
        .or_else(|| info.get("currentSqrtPrice"))
        .or_else(|| info.get("sqrtPrice"))
        .and_then(|v| v.as_str())?;
        
    let liquidity_str = info.get("liquidity")
        .and_then(|v| v.as_str())?;
    let liquidity: u64 = liquidity_str.parse().ok()?;
    
    let price = calculate_price_from_sqrt_price_x64(sqrt_price_x64, 9, 6)?;
    let liquidity_usd = (liquidity as f64 / LAMPORTS_PER_SOL as f64) * 100.0;
    
    println!("[{}]  Parsed CLMM price: ${:.6}", dex_name, price);
    
    Some(EnhancedPriceUpdate {
        dex: dex_name.to_string(),
        token_pair: "SOL/USDC".to_string(),
        price,
        timestamp: TokioInstant::now(),
        liquidity: Some(liquidity_usd),
        data_source: DataSource::WebSocket,
        pool_address: pool_address.to_string(),
        reserve_token_a: None,
        reserve_token_b: None,
    })
}

/// Parse Orca Whirlpool from already-parsed JSON (FIXED)
async fn parse_orca_whirlpool_from_parsed(
    parsed: &serde_json::Value,
    dex_name: &str,
    pool_address: &str,
) -> Option<EnhancedPriceUpdate> {
    let info = parsed.get("info")?;
    
    let sqrt_price = info.get("sqrtPrice")
        .or_else(|| info.get("sqrtPriceX64"))
        .and_then(|v| v.as_str())?;
    let liquidity_str = info.get("liquidity")
        .and_then(|v| v.as_str())?;
    let liquidity: u64 = liquidity_str.parse().ok()?;
    
    let price = calculate_price_from_sqrt_price_x64(sqrt_price, 9, 6)?;
    let liquidity_usd = (liquidity as f64 / LAMPORTS_PER_SOL as f64) * 100.0;
    
    println!("[{}]  Parsed Whirlpool price: ${:.6}", dex_name, price);
    
    Some(EnhancedPriceUpdate {
        dex: dex_name.to_string(),
        token_pair: "SOL/USDC".to_string(),
        price,
        timestamp: TokioInstant::now(),
        liquidity: Some(liquidity_usd),
        data_source: DataSource::WebSocket,
        pool_address: pool_address.to_string(),
        reserve_token_a: None,
        reserve_token_b: None,
    })
}



/// Parse Orca Whirlpool from binary data (ENHANCED with cached decimals)
async fn parse_orca_whirlpool_binary(
    data: &[u8],
    dex_name: &str,
    pool_address: &str,
    decimals_a: u8, // CHANGED: Now accepts cached decimals directly
    decimals_b: u8, // CHANGED: Now accepts cached decimals directly
) -> Option<EnhancedPriceUpdate> {    
    println!("[{}]  Whirlpool parse start: {} bytes", dex_name, data.len());
    
    if data.len() < 261 {
        println!("[{}]  Data too small for Whirlpool: {} < 261", dex_name, data.len());
        return None;
    }

    let offset = 8; // Skip discriminator
   
    // Read liquidity at offset 49 (8 + 41)
    let liquidity = match read_u128_le(data, offset + 41) {
        Some(liq) => {
            // println!("[{}]  Liquidity: {}", dex_name, liq);
            liq
        },
        None => {
            println!("[{}]  Failed to read liquidity", dex_name);
            return None;
        }
    };
    
    // Read sqrt_price at offset 65 (8 + 57)
    let sqrt_price_x64 = match read_u128_le(data, offset + 57) {
        Some(sp) => sp,
        None => {
            println!("[{}]  Failed to read sqrt_price", dex_name);
            return None;
        }
    };
    
    // Read tick for validation
    let tick_current = read_i32_le(data, offset + 73).unwrap_or(0);

    if sqrt_price_x64 == 0 {
        println!("[{}]  Zero sqrt_price in Whirlpool - pool inactive", dex_name);
        return None;
    }

    // CORRECT calculation for sqrt_price (Q64.64 fixed point)
    let sqrt_price = sqrt_price_x64 as f64 / ((1_u128 << 64) as f64);
    let raw_price = sqrt_price * sqrt_price;
    
    // println!("[{}]  Calculation:", dex_name);
    // println!("[{}]    sqrt_price: {:.10}", dex_name, sqrt_price);
    // println!("[{}]    raw_price: {:.10}", dex_name, raw_price);
    
    // Use cached decimals passed from caller
    println!("[{}]  Token decimals: A={}, B={} (Cached)", dex_name, decimals_a, decimals_b);

    // Calculate price with decimal adjustment
    // Try both decimal adjustment directions (token order in pool may vary)
    let decimal_adj_normal = 10_f64.powi(decimals_a as i32 - decimals_b as i32);
    let price_normal = raw_price * decimal_adj_normal;

    let decimal_adj_inverse = 10_f64.powi(decimals_b as i32 - decimals_a as i32);
    let price_inverse = raw_price * decimal_adj_inverse;

    // Choose whichever price is in a reasonable range for trading pairs
    let price_1_valid = (0.0001..=100_000.0).contains(&price_normal);
    let price_2_valid = (0.0001..=100_000.0).contains(&price_inverse);
    
    let price = if price_1_valid && price_2_valid {
        if price_normal >= price_inverse { price_normal } else { price_inverse }
    } else if price_2_valid {
        price_inverse
    } else if price_1_valid {
        price_normal
    } else {
        // Fallback reciprocals
        let reciprocal_1 = if price_normal > 0.0 { 1.0 / price_normal } else { 0.0 };
        let reciprocal_2 = if price_inverse > 0.0 { 1.0 / price_inverse } else { 0.0 };

        if (0.01..=100_000.0).contains(&reciprocal_2) {
            reciprocal_2
        } else if (0.01..=100_000.0).contains(&reciprocal_1) {
            reciprocal_1
        } else {
            println!("[{}]  All directions failed", dex_name);
            return None;
        }
    }; 

    let liquidity_usd = (liquidity as f64 / 1e12) * price;

    println!("[{}]  Whirlpool parse successful: ${:.4} | Tick: {}", dex_name, price, tick_current);

    Some(EnhancedPriceUpdate {
        dex: dex_name.to_string(),
        token_pair: "SOL/USDC".to_string(),
        price,
        timestamp: TokioInstant::now(),
        liquidity: Some(liquidity_usd),
        data_source: DataSource::WebSocket,
        pool_address: pool_address.to_string(),
        reserve_token_a: None,
        reserve_token_b: None,
    })
}


// ============================================================================
// --- METEORA PARSING FUNCTIONS (PRODUCTION-READY WITH VALIDATION) ---
// ============================================================================

/// Main Meteora router with DLMM enabled and dynamic decimals

async fn parse_meteora_binary(
    data: &[u8],
    dex_name: &str,
    pool_address: &str,
    token_a_mint: &str,
    token_b_mint: &str,
    rpc: &AsyncRpcClient,
) -> Option<EnhancedPriceUpdate> {
    let data_len = data.len();

    println!("[{}] [PARSE] Meteora parse start: {} bytes (pool: {}... )",
        dex_name, data_len, &pool_address[..12]);

    if data_len < 200 {
        println!("[{}] [X] Data too small: {} < 200 bytes", dex_name, data_len);
        return None;
    }

    // Get decimals once
    let (decimals_a, decimals_b) = get_token_pair_decimals(rpc, token_a_mint, token_b_mint). await;

    // Debug mode for specific pools (optional - can be removed in production)
    let debug_pools = vec![
        "5hbf9JP8k5zdrZp9pokPypFQoBse5mGCmW6nqodurGcd",  // MET/USDC AMM
        "8X5yDboAEtV1SeoZoG3issAc9zB6qGSe5ZCtJyUz2S5W",  // MET/USDC DLMM
        "8Pm2kZpnxD3hoMmt4bjStX2Pw2Z9abpbHzZxMPqxPmie",  // SOL/USDC DLMM v2
        "BGm1tav58oGcsQJehL9WXBFXF7D27vZsKefj4xJKD5Y",   // SOL/USDC DLMM v1/AMM
    ];

    if debug_pools.iter(). any(|p| pool_address.starts_with(p)) {
        if data_len >= 8 {
            let discriminator = &data[0..8];

            if discriminator == [0x21, 0x0b, 0x31, 0x62, 0xb5, 0x65, 0xb1, 0x0d] {
                println!("\n[DEBUG] DEBUG MODE: Scanning AMM pool {}...", &pool_address[..16.min(pool_address.len())]);
                debug_meteora_pool_data(data, decimals_a, decimals_b, dex_name, pool_address);
            } else if discriminator == [0xf1, 0x9a, 0x6d, 0x04, 0x11, 0xb1, 0x6d, 0xbc] {
                println!("\n[DEBUG] DEBUG MODE: Scanning DLMM pool {}...", &pool_address[..16.min(pool_address.len())]);
                debug_meteora_dlmm_data(data, dex_name, pool_address);
            }
        }
    }

    // Check discriminator to route to correct parser
    if data_len >= 8 {
        let discriminator = &data[0..8];

        println!("[{}] [INFO] Discriminator: {:02x?}", dex_name, discriminator);

        // Route based on discriminator
        match discriminator {
            // Meteora DLMM v2 (sqrt_price based)
            [0xf1, 0x9a, 0x6d, 0x04, 0x11, 0xb1, 0x6d, 0xbc] => {
                println!("[{}] -> Routing to DLMM v2 parser (sqrt_price)", dex_name);
                return parse_meteora_dlmm_binary(data, dex_name, pool_address, decimals_a, decimals_b). await;
            }

            // Meteora DLMM v1 (bin-based) - Owner: LBUZKhRxPF3XUpBCjp4YzTKgLccjZhTSDM9YuVaPwxo
            [0x21, 0x0b, 0x31, 0x62, 0xb5, 0x65, 0xb1, 0x0d] => {
                println!("[{}] -> Detected DLMM v1 (bin-based pricing)", dex_name);

                // Get reference price from Jupiter for validation
                let reference_price = match get_token_price_in_usdc(token_a_mint, 10u64.pow(decimals_a as u32)).await {
                    Ok(p) if p > 0.0 => Some(p),
                    _ => None,
                };

                if let Some(ref_price) = reference_price {
                    println!("[{}]    Reference price from Jupiter: {:.6}", dex_name, ref_price);
                }

                // Use FIXED v2 bin-based pricing with smart reserve fallback
                // The parser now handles its own fallback for unusual pools (large active_id)
                if let Some(result) = parse_meteora_dlmm_v1_bin_price(
                    data,
                    dex_name,
                    pool_address,
                    decimals_a,
                    decimals_b,
                    reference_price,
                ){
                    println!("[{}] [OK] DLMM v1 pricing successful", dex_name);
                    return Some(result);
                }

                println!("[{}] [X] DLMM v1 pricing failed completely", dex_name);
                return None;
            }

            // Orca Whirlpool (sometimes misclassified as Meteora)
            [0x3f, 0x95, 0xd1, 0x0c, 0xe1, 0x80, 0x63, 0x09] => {
                println!("[{}] Detected Orca Whirlpool, rerouting", dex_name);
                let (dec_a, dec_b) = get_token_pair_decimals(rpc, token_a_mint, token_b_mint).await;
                return parse_orca_whirlpool_binary(data, dex_name, pool_address, dec_a, dec_b).await;
            }

            _ => {
                println! ("[{}] [WARN] Unknown discriminator, using size-based detection", dex_name);
            }
        }
    }

    // Fallback: Route based on pool size (less reliable)
    match data_len {
        // Meteora AMM pools (~904 bytes)
        800..=950 => {
            println!("[{}] -> Routing to AMM parser (by size: {} bytes)", dex_name, data_len);
            parse_meteora_amm_binary(data, dex_name, pool_address, decimals_a, decimals_b, token_a_mint).await
        },
        // Meteora DLMM pools (~1112 bytes)
        1000..=1200 => {
            println!("[{}] -> Routing to DLMM parser (by size: {} bytes)", dex_name, data_len);
            parse_meteora_dlmm_binary(data, dex_name, pool_address, decimals_a, decimals_b). await
        },
        // Unknown size - try AMM first
        _ => {
            println!("[{}] [WARN] Unexpected size: {} bytes, trying AMM", dex_name, data_len);
            parse_meteora_amm_binary(data, dex_name, pool_address, decimals_a, decimals_b, token_a_mint).await
        }
    }
}

/// Parse Meteora DLMM v1 with proper token identification
async fn parse_meteora_dlmm_v1_verified(
    data: &[u8],
    dex_name: &str,
    pool_address: &str,
    base_mint: &str,      // AVICI mint
    quote_mint: &str,     // USDC mint
    base_decimals: u8,
    quote_decimals: u8,
    rpc: &AsyncRpcClient,
) -> Option<EnhancedPriceUpdate> {
    println!("[{}] [DLMM v1] Parsing with token verification.. .", dex_name);
    
    // Read mint addresses from pool data
    // Based on Meteora DLMM structure:
    // token_x_mint: offset 88 (32 bytes)
    // token_y_mint: offset 120 (32 bytes)
    // reserve_x: offset 152 (32 bytes) 
    // reserve_y: offset 184 (32 bytes)
    
    if data.len() < 216 {
        println!("[{}] [X] Data too small", dex_name);
        return None;
    }
    
    // Read token mints
    let token_x_mint = Pubkey::try_from(&data[88..120]).ok()?;
    let token_y_mint = Pubkey::try_from(&data[120..152]).ok()?;
    
    println!("[{}] token_x_mint: {}", dex_name, token_x_mint);
    println!("[{}] token_y_mint: {}", dex_name, token_y_mint);
    
    // Read reserve vault pubkeys
    let reserve_x_pk = Pubkey::try_from(&data[152..184]). ok()?;
    let reserve_y_pk = Pubkey::try_from(&data[184.. 216]).ok()? ;
    
    // Fetch vault balances
    let balance_x = rpc.get_token_account_balance(&reserve_x_pk). await.ok()? 
        .amount. parse::<u64>().unwrap_or(0);
    let balance_y = rpc.get_token_account_balance(&reserve_y_pk). await.ok()? 
        .amount. parse::<u64>().unwrap_or(0);
    
    println! ("[{}] reserve_x ({}) balance: {}", dex_name, reserve_x_pk, balance_x);
    println! ("[{}] reserve_y ({}) balance: {}", dex_name, reserve_y_pk, balance_y);
    
    // Determine which is base (AVICI) and which is quote (USDC)
    let token_x_str = token_x_mint.to_string();
    let token_y_str = token_y_mint.to_string();
    
    let (base_balance, quote_balance, base_dec, quote_dec) = 
        if token_x_str.starts_with(&base_mint[..8]) {
            // token_x is base (AVICI), token_y is quote (USDC)
            println!("[{}] Token X is BASE (AVICI)", dex_name);
            (balance_x, balance_y, base_decimals, quote_decimals)
        } else if token_y_str.starts_with(&base_mint[..8]) {
            // token_y is base (AVICI), token_x is quote (USDC)
            println!("[{}] Token Y is BASE (AVICI)", dex_name);
            (balance_y, balance_x, base_decimals, quote_decimals)
        } else {
            println!("[{}] [X] Could not match token mints", dex_name);
            return None;
        };
    
    // For DLMM, we need to use bin-based pricing, not reserve ratios
    // Read bin_step and active_id
    // Meteora DLMM v1 structure (LBPair):
// bin_step is at offset 8-9 (u16) based on actual data analysis
let bin_step_offset = 8;
let bin_step = u16::from_le_bytes([data[bin_step_offset], data[bin_step_offset + 1]]);
    let active_id = i32::from_le_bytes([data[24], data[25], data[26], data[27]]);
    
    println!("[{}] bin_step: {}, active_id: {}", dex_name, bin_step, active_id);
    
    // Try bin-based pricing first
    if bin_step > 0 && bin_step <= 500 && active_id. abs() < 50000 {
        let bin_step_decimal = bin_step as f64 / 10000.0;
        let price = (1.0 + bin_step_decimal). powi(active_id);
        
        // Adjust for decimals
        let decimal_adj = 10_f64.powi((base_dec as i32) - (quote_dec as i32));
        let adjusted_price = price * decimal_adj;
        
        println! ("[{}] Bin-based price: {:.8}", dex_name, adjusted_price);
        
        if adjusted_price > 0.001 && adjusted_price < 100000.0 {
            return Some(EnhancedPriceUpdate {
                dex: dex_name.to_string(),
                token_pair: "CUSTOM".to_string(),
                price: adjusted_price,
                timestamp: TokioInstant::now(),
                liquidity: None,
                data_source: DataSource::WebSocket,
                pool_address: pool_address.to_string(),
                reserve_token_a: Some(base_balance),
                reserve_token_b: Some(quote_balance),
            });
        }
    }
    
    // Fallback: Use reserve ratio (less accurate for DLMM but better than nothing)
    let base_f = base_balance as f64 / 10_f64.powi(base_dec as i32);
    let quote_f = quote_balance as f64 / 10_f64. powi(quote_dec as i32);
    
    if base_f == 0.0 {
        return None;
    }
    
    let price = quote_f / base_f;
    println!("[{}] Reserve-based price (fallback): {:.8}", dex_name, price);
    
    Some(EnhancedPriceUpdate {
        dex: dex_name. to_string(),
        token_pair: "CUSTOM".to_string(),
        price,
        timestamp: TokioInstant::now(),
        liquidity: Some(quote_f * 2.0),
        data_source: DataSource::WebSocket,
        pool_address: pool_address.to_string(),
        reserve_token_a: Some(base_balance),
        reserve_token_b: Some(quote_balance),
    })
}

/// Parse Meteora DLMM v1 by fetching vault balances
/// This is the most reliable method for DLMM pools
async fn parse_meteora_dlmm_v1_with_vaults(
    data: &[u8],
    dex_name: &str,
    pool_address: &str,
    base_decimals: u8,
    quote_decimals: u8,
    rpc: &AsyncRpcClient,
) -> Option<EnhancedPriceUpdate> {
    println!("[{}] [DLMM v1] Fetching vault balances...", dex_name);
    
    if data.len() < 200 {
        println!("[{}] [X] Data too small", dex_name);
        return None;
    }
    
    // Meteora DLMM LbPair structure:
    // The reserve vaults (token accounts) are stored at specific offsets
    // We need to find reserve_x and reserve_y pubkeys
    
    // Based on Meteora DLMM IDL, the reserve accounts are at:
    // reserve_x: offset 136 (32 bytes)
    // reserve_y: offset 168 (32 bytes)
    
    let reserve_x_offset = 136;
    let reserve_y_offset = 168;
    
    if reserve_y_offset + 32 > data.len() {
        println!("[{}] [X] Data too small for vault addresses", dex_name);
        return None;
    }
    
    let reserve_x_bytes = &data[reserve_x_offset..reserve_x_offset + 32];
    let reserve_y_bytes = &data[reserve_y_offset..reserve_y_offset + 32];
    
    let reserve_x_pubkey = match Pubkey::try_from(reserve_x_bytes) {
        Ok(pk) if pk != Pubkey::default() => pk,
        _ => {
            println!("[{}] [X] Invalid reserve_x pubkey", dex_name);
            return None;
        }
    };
    
    let reserve_y_pubkey = match Pubkey::try_from(reserve_y_bytes) {
        Ok(pk) if pk != Pubkey::default() => pk,
        _ => {
            println!("[{}] [X] Invalid reserve_y pubkey", dex_name);
            return None;
        }
    };
    
    println!("[{}] reserve_x: {}", dex_name, reserve_x_pubkey);
    println!("[{}] reserve_y: {}", dex_name, reserve_y_pubkey);
    
    // Fetch token account balances
    let balance_x = match rpc.get_token_account_balance(&reserve_x_pubkey). await {
        Ok(bal) => bal. amount. parse::<u64>().unwrap_or(0),
        Err(e) => {
            println!("[{}] [X] Failed to fetch reserve_x balance: {}", dex_name, e);
            return None;
        }
    };
    
    let balance_y = match rpc.get_token_account_balance(&reserve_y_pubkey).await {
        Ok(bal) => bal.amount. parse::<u64>().unwrap_or(0),
        Err(e) => {
            println!("[{}] [X] Failed to fetch reserve_y balance: {}", dex_name, e);
            return None;
        }
    };
    
    if balance_x == 0 || balance_y == 0 {
        println! ("[{}] [X] Zero balance in reserves", dex_name);
        return None;
    }
    
    // Calculate price
    let reserve_x_f = balance_x as f64 / 10_f64.powi(base_decimals as i32);
    let reserve_y_f = balance_y as f64 / 10_f64.powi(quote_decimals as i32);
    let price = reserve_y_f / reserve_x_f;
    
    println! ("[{}] reserve_x: {:.6} tokens", dex_name, reserve_x_f);
    println!("[{}] reserve_y: {:.6} tokens", dex_name, reserve_y_f);
    println!("[{}] price: {:.8}", dex_name, price);
    
    // Validate price is reasonable
    if price <= 0.0 || price. is_nan() || price.is_infinite() {
        println!("[{}] [X] Invalid price calculated", dex_name);
        return None;
    }
    
    let liquidity = reserve_x_f * price * 2.0;
    
    println!("[{}] [OK] DLMM v1 vault-based parse successful: {:.8}", dex_name, price);
    
    Some(EnhancedPriceUpdate {
        dex: dex_name. to_string(),
        token_pair: "CUSTOM".to_string(),
        price,
        timestamp: TokioInstant::now(),
        liquidity: Some(liquidity),
        data_source: DataSource::WebSocket,
        pool_address: pool_address.to_string(),
        reserve_token_a: Some(balance_x),
        reserve_token_b: Some(balance_y),
    })
}


/// Helper to calculate bin-based price with automatic direction detection - FIXED VERSION
/// Key fixes:
/// 1. Tries more price direction combinations
/// 2. Relaxed tolerance from 15% to 25%
/// 3. Better handling of edge cases
fn calculate_dlmm_bin_price_with_inversion(
    active_id: i32,
    bin_step_basis_points: u16,
    reference_price: f64,
    decimal_adj: f64,
) -> Option<(f64, f64)> {
    let bin_step_decimal = bin_step_basis_points as f64 / 10000.0;
    let base = 1.0 + bin_step_decimal;
    
    // Use absolute value for exponent calculation
    let abs_id = active_id.abs();
    
    // Prevent overflow for large exponents
    if abs_id > 50000 {
        return None;
    }
    
    // Calculate base power
    let power = base.powi(abs_id);
    let inv_power = 1.0 / power;
    
    // Try all reasonable price interpretations
    let candidates = [
        ("pos*adj", power * decimal_adj),
        ("inv*adj", inv_power * decimal_adj),
        ("pos/adj", power / decimal_adj),
        ("inv/adj", inv_power / decimal_adj),
        ("adj/pos", decimal_adj / power),
        ("adj/inv", decimal_adj / inv_power),
        ("adj*pos", decimal_adj * power),
        ("adj*inv", decimal_adj * inv_power),
    ];
    
    let mut best_price = power * decimal_adj;
    let mut best_deviation = f64::MAX;
    let mut best_method = "pos*adj";
    
    for (method, price) in &candidates {
        // Skip invalid prices
        if *price <= 0.0 || price.is_nan() || price.is_infinite() {
            continue;
        }
        if *price < 0.0000001 || *price > 1_000_000_000.0 {
            continue;
        }
        
        let deviation = ((price - reference_price) / reference_price).abs();
        if deviation < best_deviation {
            best_deviation = deviation;
            best_price = *price;
            best_method = method;
        }
    }
    
    println!(
        "[Meteora] [BIN_CALC] active_id={}, bin_step={}, best_method={}, price={:.8}, dev={:.2}%",
        active_id, bin_step_basis_points, best_method, best_price, best_deviation * 100.0
    );
    
    // FIXED: Relaxed tolerance from 15% to 25%
    if best_deviation > 0.25 {
        return None;
    }
    
    Some((best_price, best_deviation))
}

/// Parse Meteora DLMM v1 using bin-based pricing - FIXED VERSION v2
/// Key fixes:
/// 1. Exhaustive bin_step search from 1-100 (not just specific values)
/// 2. Uses absolute value of active_id for calculation
/// 3. Relaxed tolerance from 15% to 25%
/// 4. Falls back to reserve-based pricing when active_id is unreasonably large
/// 5. Better logging for debugging
fn parse_meteora_dlmm_v1_bin_price(
    data: &[u8],
    dex_name: &str,
    pool_address: &str,
    base_decimals: u8,
    quote_decimals: u8,
    reference_price: Option<f64>,
) -> Option<EnhancedPriceUpdate> {
    println!("[{}] [DLMM v1] Parsing bin-based price (FIXED v2)...", dex_name);
    
    if data.len() < 224 {
        println!("[{}] [X] Data too small: {} bytes", dex_name, data.len());
        return None;
    }
    
    // Read active_id at offset 24
    let active_id_raw = i32::from_le_bytes([data[24], data[25], data[26], data[27]]);
    
    println!("[{}]    active_id (raw): {}", dex_name, active_id_raw);
    
    // Decimal adjustment for price
    let decimal_adj = 10_f64.powi((quote_decimals as i32) - (base_decimals as i32));
    
    // Reference price for validation
    let ref_price = reference_price.unwrap_or(1.0);
    println!("[{}]    reference_price: {:.6}", dex_name, ref_price);
    println!("[{}]    decimal_adj: {} (base={}, quote={})", dex_name, decimal_adj, base_decimals, quote_decimals);
    
    // =========================================================================
    // CHECK: If active_id is unreasonably large, use reserve-based pricing
    // Some DLMM pools (like SOL/USDC BGm1tav...) have active_id values that
    // are too large for bin calculations (e.g., -43690 causes overflow)
    // =========================================================================
    if active_id_raw.abs() > 10000 {
        println!("[{}] [WARN] active_id {} is too large for bin calculation, trying reserve-based pricing", 
            dex_name, active_id_raw);
        
        // Try reserve-based pricing at offset 216 (found via diagnostic scan)
        if let Some(result) = try_reserve_based_pricing(
            data, dex_name, pool_address, base_decimals, quote_decimals, ref_price
        ) {
            return Some(result);
        }
    }
    
    // =========================================================================
    // STEP 1: Try to read bin_step from known offsets first
    // =========================================================================
    let potential_bin_steps: Vec<u16> = vec![
        u16::from_le_bytes([data[10], data[11]]),  // offset 10
        u16::from_le_bytes([data[12], data[13]]),  // offset 12
        u16::from_le_bytes([data[80], data[81]]),  // offset 80
        u16::from_le_bytes([data[82], data[83]]),  // offset 82
    ];
    
    // Filter to reasonable bin_step values (1-100 bps typically)
    let valid_from_offsets: Vec<u16> = potential_bin_steps
        .into_iter()
        .filter(|&bs| bs >= 1 && bs <= 100)
        .collect();
    
    if !valid_from_offsets.is_empty() {
        println!("[{}]    bin_step candidates from offsets: {:?}", dex_name, valid_from_offsets);
    }
    
    // =========================================================================
    // STEP 2: Try values from offsets first, then exhaustive search
    // =========================================================================
    let mut best_match: Option<(f64, u16, f64, String)> = None; // (price, bin_step, deviation, method)
    
    // First try values read from offsets (if any are valid)
    for bin_step in &valid_from_offsets {
        if let Some((price, deviation)) = calculate_dlmm_bin_price_with_inversion(
            active_id_raw,
            *bin_step,
            ref_price,
            decimal_adj,
        ) {
            if best_match.is_none() || deviation < best_match.as_ref().unwrap().2 {
                best_match = Some((price, *bin_step, deviation, "from_offset".to_string()));
                
                // If we found an excellent match, use it
                if deviation < 0.05 {
                    println!("[{}]    Found excellent match from offset: bin_step={}", dex_name, bin_step);
                    break;
                }
            }
        }
    }
    
    // If no good match from offsets, do exhaustive search 1-100
    if best_match.is_none() || best_match.as_ref().unwrap().2 > 0.10 {
        println!("[{}]    Performing exhaustive bin_step search (1-100)...", dex_name);
        
        for bin_step in 1u16..=100 {
            if let Some((price, deviation)) = calculate_dlmm_bin_price_with_inversion(
                active_id_raw,
                bin_step,
                ref_price,
                decimal_adj,
            ) {
                // Found excellent match - stop early
                if deviation < 0.03 {
                    best_match = Some((price, bin_step, deviation, "exhaustive".to_string()));
                    println!("[{}]    Found excellent match: bin_step={}, dev={:.2}%", 
                        dex_name, bin_step, deviation * 100.0);
                    break;
                }
                
                if best_match.is_none() || deviation < best_match.as_ref().unwrap().2 {
                    best_match = Some((price, bin_step, deviation, "exhaustive".to_string()));
                }
            }
        }
    }
    
    // =========================================================================
    // STEP 3: Return best match if within tolerance (25%)
    // =========================================================================
    if let Some((price, bin_step, deviation, method)) = best_match {
        if deviation <= 0.25 {
            let status = if deviation < 0.01 { "Excellent" }
                else if deviation < 0.05 { "Good" }
                else if deviation < 0.15 { "Acceptable" }
                else { "Marginal" };
            
            println!("[{}] [OK] DLMM v1 price: {:.8} (bin_step={}, method={}, dev={:.2}% - {})",
                dex_name, price, bin_step, method, deviation * 100.0, status);
            
            return Some(EnhancedPriceUpdate {
                dex: dex_name.to_string(),
                token_pair: "CUSTOM".to_string(),
                price,
                timestamp: TokioInstant::now(),
                liquidity: None,
                data_source: DataSource::WebSocket,
                pool_address: pool_address.to_string(),
                reserve_token_a: None,
                reserve_token_b: None,
            });
        } else {
            println!("[{}] [WARN] Best match deviation {:.2}% exceeds 25% threshold (bin_step={})",
                dex_name, deviation * 100.0, bin_step);
        }
    }
    
    // =========================================================================
    // STEP 4: Last resort - try reserve-based pricing
    // =========================================================================
    println!("[{}] [WARN] Bin-based pricing failed, trying reserve-based fallback...", dex_name);
    if let Some(result) = try_reserve_based_pricing(
        data, dex_name, pool_address, base_decimals, quote_decimals, ref_price
    ) {
        return Some(result);
    }
    
    println!("[{}] [X] Could not determine bin-based price", dex_name);
    None
}

/// Try reserve-based pricing at known offsets (fallback for unusual DLMM pools)
fn try_reserve_based_pricing(
    data: &[u8],
    dex_name: &str,
    pool_address: &str,
    base_decimals: u8,
    quote_decimals: u8,
    reference_price: f64,
) -> Option<EnhancedPriceUpdate> {
    println!("[{}] [RESERVE] Trying reserve-based pricing...", dex_name);
    
    // Known reserve offsets for DLMM v1 pools
    let reserve_offsets = vec![
        (216, 224),  // Primary location (found via diagnostic)
        (40, 48),    // Alternative location
        (152, 160),  // Vault-style location
    ];
    
    let mut best_result: Option<(f64, f64, u64, u64, usize)> = None; // (price, deviation, res_a, res_b, offset)
    
    for (offset_a, offset_b) in reserve_offsets {
        if offset_b + 8 > data.len() {
            continue;
        }
        
        let reserve_a = u64::from_le_bytes(data[offset_a..offset_a + 8].try_into().unwrap());
        let reserve_b = u64::from_le_bytes(data[offset_b..offset_b + 8].try_into().unwrap());
        
        // Skip if reserves are zero or suspiciously small
        if reserve_a < 1000 || reserve_b < 1000 {
            continue;
        }
        
        // Adjust for decimals
        let reserve_a_adj = reserve_a as f64 / 10_f64.powi(base_decimals as i32);
        let reserve_b_adj = reserve_b as f64 / 10_f64.powi(quote_decimals as i32);
        
        // Skip if adjusted reserves are too small
        if reserve_a_adj < 0.001 || reserve_b_adj < 0.001 {
            continue;
        }
        
        // Calculate price both ways
        let price_normal = reserve_b_adj / reserve_a_adj;
        let price_inverted = reserve_a_adj / reserve_b_adj;
        
        // Check which direction matches reference price better
        let dev_normal = ((price_normal - reference_price) / reference_price).abs();
        let dev_inverted = ((price_inverted - reference_price) / reference_price).abs();
        
        let (price, deviation) = if dev_normal <= dev_inverted {
            (price_normal, dev_normal)
        } else {
            (price_inverted, dev_inverted)
        };
        
        println!("[{}] [RESERVE] Offset {}: res_a={:.4}, res_b={:.4}, price={:.6}, dev={:.2}%",
            dex_name, offset_a, reserve_a_adj, reserve_b_adj, price, deviation * 100.0);
        
        // Track best result
        if deviation < 0.25 {  // Accept up to 25% deviation
            if best_result.is_none() || deviation < best_result.as_ref().unwrap().1 {
                best_result = Some((price, deviation, reserve_a, reserve_b, offset_a));
            }
        }
    }
    
    if let Some((price, deviation, reserve_a, reserve_b, offset)) = best_result {
        let status = if deviation < 0.03 { "Excellent" }
            else if deviation < 0.10 { "Good" }
            else { "Acceptable" };
        
        println!("[{}] [OK] Reserve-based price: {:.8} (offset={}, dev={:.2}% - {})",
            dex_name, price, offset, deviation * 100.0, status);
        
        // Calculate liquidity
        let reserve_a_adj = reserve_a as f64 / 10_f64.powi(base_decimals as i32);
        let liquidity = reserve_a_adj * price * 2.0;
        
        return Some(EnhancedPriceUpdate {
            dex: dex_name.to_string(),
            token_pair: "CUSTOM".to_string(),
            price,
            timestamp: TokioInstant::now(),
            liquidity: Some(liquidity),
            data_source: DataSource::WebSocket,
            pool_address: pool_address.to_string(),
            reserve_token_a: Some(reserve_a),
            reserve_token_b: Some(reserve_b),
        });
    }
    
    println!("[{}] [X] Reserve-based pricing failed", dex_name);
    None
}

// ============================================================================
// --- FIXED METEORA AMM PARSER ---
// ============================================================================

/// Parse Meteora AMM pools with dynamic decimals (ENHANCED for v1 DLMM)
async fn parse_meteora_amm_binary(
    data: &[u8],
    dex_name: &str,
    pool_address: &str,
    decimals_a: u8,
    decimals_b: u8,
    base_token_mint: &str,
) -> Option<EnhancedPriceUpdate> {
    println!("[{}] [PARSE] AMM parse start: {} bytes", dex_name, data.len());
    println!("[{}] [INFO] Using decimals: token_a={}, token_b={}", dex_name, decimals_a, decimals_b);
    
    if data.len() < 800 {
        println!("[{}] [X] Data too small for AMM: {} < 800", dex_name, data.len());
        return None;
    }

    // Check discriminator to determine which offset strategy to use
    let discriminator = &data[0..8];
    
    let offset_strategies = match discriminator {
        // DLMM v1/AMM hybrid (pool BGm1tav...)
        [0x21, 0x0b, 0x31, 0x62, 0xb5, 0x65, 0xb1, 0x0d] => {
            println!("[{}] -> Using DLMM v1/AMM offsets", dex_name);
            vec![
                (216, 224, "DLMM v1 (diagnostic found)"),
                (176, 184, "Strategy 1 (original)"),
                (200, 208, "Strategy 2 (aligned)"),
            ]
        }
        // Standard Meteora AMM
        _ => {
            println!("[{}] -> Using standard AMM offsets", dex_name);
            vec![
                (176, 184, "Strategy 1 (original)"),
                (200, 208, "Strategy 2 (aligned)"),
                (216, 224, "Strategy 3 (padded)"),
                (184, 192, "Strategy 4 (shifted)"),
                (192, 200, "Strategy 5 (alt)"),
            ]
        }
    };

    let mut candidates = Vec::new();

    for (offset_a, offset_b, strategy_name) in offset_strategies {
        if let (Some(reserve_a), Some(reserve_b)) =
            (read_u64_le(data, offset_a), read_u64_le(data, offset_b)) {
            
            // Use dynamic decimals
            let reserve_a_adjusted = reserve_a as f64 / 10_f64.powi(decimals_a as i32);
            let reserve_b_adjusted = reserve_b as f64 / 10_f64.powi(decimals_b as i32);

            println!("[{}] {} -> A: {:.4} tokens, B: {:.4} tokens",
                dex_name, strategy_name, reserve_a_adjusted, reserve_b_adjusted);

            // Filter unrealistic values
            if reserve_a_adjusted > 1_000_000_000.0 || reserve_b_adjusted > 100_000_000_000.0 {
                println!("[{}] [X] Reserves too large (unrealistic)", dex_name);
                continue;
            }

            if reserve_a_adjusted < 1.0 || reserve_b_adjusted < 100.0 {
                println! ("[{}] [X] Reserves too small", dex_name);
                continue;
            }

            let price = calculate_price_from_constant_product(reserve_a, reserve_b, decimals_a, decimals_b);
            println!("[{}] Price: ${:.6}", dex_name, price);

            // Use dynamic price bounds
            let (min_bound, max_bound) = get_dynamic_price_bounds(reserve_a_adjusted, reserve_b_adjusted);
            println!("[{}] Price bounds: ${:.6} - ${:.6}", dex_name, min_bound, max_bound);

            if (min_bound..=max_bound).contains(&price) {
                let liquidity = calculate_liquidity_usd(reserve_a, reserve_b, price, decimals_a, decimals_b);
                println!("[{}] [OK] Valid price, liquidity: ${:.2}", dex_name, liquidity);
                candidates.push((price, reserve_a, reserve_b, liquidity, strategy_name));
            }
        }
    }


    if candidates.is_empty() {
        println!("[{}] [!] Direct offsets failed, starting reserve scan...", dex_name);
        // Pass base_token_mint here
        return scan_for_meteora_reserves(data, dex_name, pool_address, decimals_a, decimals_b, base_token_mint).await;
    }

    // Sort by closest to median price
    candidates.sort_by(|a, b| a.0.partial_cmp(&b.0).unwrap());
    let median_price = candidates[candidates. len() / 2].0;
    candidates.sort_by(|a, b| {
        let dist_a = (a.0 - median_price).abs();
        let dist_b = (b.0 - median_price).abs();
        dist_a.partial_cmp(&dist_b).unwrap()
    });

    let (price, reserve_a, reserve_b, liquidity, strategy) = &candidates[0];

    println!("[{}] [OK] AMM parse successful using {}: ${:.6}", dex_name, strategy, price);

    Some(EnhancedPriceUpdate {
        dex: dex_name.to_string(),
        token_pair: "CUSTOM".to_string(),
        price: *price,
        timestamp: TokioInstant::now(),
        liquidity: Some(*liquidity),
        data_source: DataSource::WebSocket,
        pool_address: pool_address.to_string(),
        reserve_token_a: Some(*reserve_a),
        reserve_token_b: Some(*reserve_b),
    })
}


// ============================================================================
// --- METEORA DAMM V1 PARSER (Reserves at Offset 216) ---
// ============================================================================


/// Parse Meteora DAMM V1 pools using dynamic scanning for reserves
/// This fixes "Bad Math" errors where the pool structure differs from the standard layout
async fn parse_meteora_damm_v1_reserves(
    data: &[u8],
    dex_name: &str,
    pool_address: &str,
    decimals_a: u8,
    decimals_b: u8,
    base_token_mint: &str,
) -> Option<EnhancedPriceUpdate> {
    let data_len = data.len();
    // println!("[{}] [PARSE] DAMM V1 dynamic parse start: {} bytes", dex_name, data_len);

    if data_len < 200 {
        return None;
    }

    // 1. Get Jupiter Reference Price (Critical for validation)
    let jupiter_ref_price = match get_token_price_in_usdc(base_token_mint, 1_000_000).await {
        Ok(p) if p > 0.0 => Some(p),
        _ => None,
    };

    if let Some(ref_price) = jupiter_ref_price {
        // println!("[{}] [INFO] Jupiter reference price: ${:.6}", dex_name, ref_price);
    } else {
        println!("[{}] [WARN] No Jupiter reference price available for validation", dex_name);
    }

    // 2. Scan entire data buffer for candidate reserve pairs
    // We look for two adjacent u64s that yield a price close to the reference
    let mut best_candidate: Option<(f64, f64, u64, u64)> = None; // (deviation, price, res_a, res_b)
    let mut lowest_deviation = f64::MAX;

    // Start after discriminator (8 bytes), scan in 8-byte steps
    for offset in (8..data.len().saturating_sub(16)).step_by(8) {
        if let (Some(val_a), Some(val_b)) = (read_u64_le(data, offset), read_u64_le(data, offset + 8)) {
            
            // Filter noise: Reserves must be significant numbers
            if val_a < 1_000_000 || val_b < 1_000_000 { continue; }
            
            // Filter crazy values (u64 max or near max)
            if val_a > 1_000_000_000_000_000 || val_b > 1_000_000_000_000_000 { continue; }

            // Adjust for decimals
            let res_a_adj = val_a as f64 / 10_f64.powi(decimals_a as i32);
            let res_b_adj = val_b as f64 / 10_f64.powi(decimals_b as i32);

            // Calculate price (Normal: B/A)
            let price_normal = res_b_adj / res_a_adj;
            
            // Calculate price (Inverted: A/B)
            let price_inverted = res_a_adj / res_b_adj;

            // Validate against reference
            if let Some(ref_price) = jupiter_ref_price {
                // Check Normal Direction
                let dev_norm = ((price_normal - ref_price).abs() / ref_price) * 100.0;
                if dev_norm < lowest_deviation && dev_norm < 50.0 { // < 50% deviation allowed
                    lowest_deviation = dev_norm;
                    best_candidate = Some((dev_norm, price_normal, val_a, val_b));
                    // println!("[{}] [SCAN] Found valid reserves at offset {}: Price=${:.4} (Dev: {:.2}%)", dex_name, offset, price_normal, dev_norm);
                }

                // Check Inverted Direction
                let dev_inv = ((price_inverted - ref_price).abs() / ref_price) * 100.0;
                if dev_inv < lowest_deviation && dev_inv < 50.0 {
                    lowest_deviation = dev_inv;
                    best_candidate = Some((dev_inv, price_inverted, val_b, val_a)); // Note: Swapped reserves for consistency
                    // println!("[{}] [SCAN] Found valid reserves at offset {} (Inv): Price=${:.4} (Dev: {:.2}%)", dex_name, offset, price_inverted, dev_inv);
                }
            } else {
                // Fallback if no reference: Look for standard DAMM V1 offsets (216)
                if offset == 216 {
                     // Heuristic: Prefer the direction that gives a price in $0.0001 - $1M range
                     if price_normal > 0.0001 && price_normal < 1_000_000.0 {
                         best_candidate = Some((0.0, price_normal, val_a, val_b));
                     }
                }
            }
        }
    }

    // 3. Return best result
    if let Some((deviation, price, res_a, res_b)) = best_candidate {
        // Calculate liquidity in USD (approximate using price)
        let res_a_adj = res_a as f64 / 10_f64.powi(decimals_a as i32);
        let liquidity = res_a_adj * price * 2.0;

        if deviation < 5.0 {
             println!("[{}] [OK] DAMM V1 Dynamic Parse: ${:.4} (Dev: {:.2}%, Liq: ${:.0})", dex_name, price, deviation, liquidity);
        } else {
             println!("[{}] [WARN] DAMM V1 Dynamic Parse: ${:.4} (Dev: {:.2}%) - Low Confidence", dex_name, price, deviation);
        }

        Some(EnhancedPriceUpdate {
            dex: dex_name.to_string(),
            token_pair: "CUSTOM".to_string(),
            price,
            timestamp: TokioInstant::now(),
            liquidity: Some(liquidity),
            data_source: DataSource::WebSocket,
            pool_address: pool_address.to_string(),
            reserve_token_a: Some(res_a),
            reserve_token_b: Some(res_b),
        })
    } else {
        // Only print failure if we had a reference price to compare against
        if jupiter_ref_price.is_some() {
            println!("[{}] [X] Failed to find valid reserve offsets matching reference price", dex_name);
        }
        None
    }
}

/// Enhanced pool type detection using discriminator
fn detect_meteora_pool_type_enhanced(data: &[u8]) -> &'static str {
    if data.len() < 8 {
        return "unknown";
    }
    
    let discriminator = &data[0..8];
    
    match discriminator {
        [0xf1, 0x9a, 0x6d, 0x04, 0x11, 0xb1, 0x6d, 0xbc] => "Meteora DLMM v2 (sqrt_price)",
        [0x21, 0x0b, 0x31, 0x62, 0xb5, 0x65, 0xb1, 0x0d] => "Meteora DAMM V1 (reserves)",
        [0x3f, 0x95, 0xd1, 0x0c, 0xe1, 0x80, 0x63, 0x09] => "Orca Whirlpool (misclassified)",
        _ => {
            // Fallback to size-based detection
            match data.len() {
                800..=950 => "Meteora AMM (by size)",
                1000..=1200 => "Meteora DLMM (by size)",
                _ => "Unknown Meteora Type",
            }
        }
    }
}

/// Fallback scanner for Meteora reserves with Reference Price Validation
async fn scan_for_meteora_reserves(
    data: &[u8],
    dex_name: &str,
    pool_address: &str,
    decimals_a: u8,
    decimals_b: u8,
    base_token_mint: &str, // NEW PARAMETER
) -> Option<EnhancedPriceUpdate> {
    // println!("[{}] [SCAN] Scanning for reserve pairs with reference validation...", dex_name);

    // 1. Fetch Reference Price
    let jupiter_ref_price = match get_token_price_in_usdc(base_token_mint, 1_000_000).await {
        Ok(p) if p > 0.0 => Some(p),
        _ => None,
    };

    if jupiter_ref_price.is_none() {
        println!("[{}] [WARN] No reference price, scan may be unreliable", dex_name);
    }

    let mut best_candidate: Option<(f64, f64, u64, u64)> = None; // (deviation, price, res_a, res_b)
    let mut lowest_deviation = f64::MAX;

    // 2. Scan Buffer
    for offset in (8..data.len().saturating_sub(16)).step_by(8) {
        if let (Some(val_a), Some(val_b)) = (read_u64_le(data, offset), read_u64_le(data, offset + 8)) {
            // Basic noise filtering
            if val_a < 1_000_000 || val_b < 1_000_000 { continue; }
            if val_a > 1_000_000_000_000_000 || val_b > 1_000_000_000_000_000 { continue; }

            // Adjust for decimals
            let res_a_adj = val_a as f64 / 10_f64.powi(decimals_a as i32);
            let res_b_adj = val_b as f64 / 10_f64.powi(decimals_b as i32);

            // Calculate prices
            let price_normal = res_b_adj / res_a_adj;
            let price_inverse = res_a_adj / res_b_adj;

            if let Some(ref_price) = jupiter_ref_price {
                // Check Normal
                let dev_norm = ((price_normal - ref_price).abs() / ref_price) * 100.0;
                if dev_norm < lowest_deviation && dev_norm < 50.0 {
                    lowest_deviation = dev_norm;
                    best_candidate = Some((dev_norm, price_normal, val_a, val_b));
                }

                // Check Inverse
                let dev_inv = ((price_inverse - ref_price).abs() / ref_price) * 100.0;
                if dev_inv < lowest_deviation && dev_inv < 50.0 {
                    lowest_deviation = dev_inv;
                    best_candidate = Some((dev_inv, price_inverse, val_b, val_a)); // Swapped
                }
            } else {
                // Blind Heuristic (only if no reference)
                // Prefer price in "sane" range of $0.0001 to $1M
                if price_normal > 0.0001 && price_normal < 1_000_000.0 && best_candidate.is_none() {
                     best_candidate = Some((0.0, price_normal, val_a, val_b));
                }
            }
        }
    }

    // 3. Return best match
    if let Some((deviation, price, res_a, res_b)) = best_candidate {
        // Calculate liquidity
        let res_a_adj = res_a as f64 / 10_f64.powi(decimals_a as i32);
        let liquidity = res_a_adj * price * 2.0;

        println!("[{}] [OK] AMM Scan: ${:.4} (Dev: {:.2}%, Offset match)", dex_name, price, deviation);

        Some(EnhancedPriceUpdate {
            dex: dex_name.to_string(),
            token_pair: "CUSTOM".to_string(),
            price,
            timestamp: TokioInstant::now(),
            liquidity: Some(liquidity),
            data_source: DataSource::WebSocket,
            pool_address: pool_address.to_string(),
            reserve_token_a: Some(res_a),
            reserve_token_b: Some(res_b),
        })
    } else {
        println!("[{}] [X] No reserves matched reference price", dex_name);
        None
    }
}

// ============================================================================
// --- FIXED METEORA DLMM PARSER ---
// ============================================================================

/// Parse Meteora DLMM with corrected offsets based on discriminator

/// Parse Meteora DLMM with corrected offsets based on discriminator

async fn parse_meteora_dlmm_binary(
    data: &[u8],
    dex_name: &str,
    pool_address: &str,
    base_decimals: u8,   // ADDED
    quote_decimals: u8,  // ADDED
) -> Option<EnhancedPriceUpdate> {
    println!("[{}] [PARSE] DLMM parse start: {} bytes", dex_name, data.len());
    
    if data.len() < 200 {
        println!("[{}] [X] Data too small for DLMM: {} < 200", dex_name, data.len());
        return None;
    }

    // Check discriminator to identify DLMM version
    if data. len() < 8 {
        println!("[{}] [X] Data too small to read discriminator", dex_name);
        return None;
    }
    
    let discriminator = &data[0..8];
    
    println!("[{}] [INFO] Discriminator: {:02x? }", dex_name, discriminator);
    
    // Route based on discriminator
    match discriminator {
        // Meteora DLMM v2 (sqrt_price based)
        [0xf1, 0x9a, 0x6d, 0x04, 0x11, 0xb1, 0x6d, 0xbc] => {
            println!("[{}] -> Routing to DLMM v2 parser (sqrt_price)", dex_name);
            return parse_meteora_dlmm_v2_sqrt(data, dex_name, pool_address, base_decimals, quote_decimals);
        }
        
        // Meteora DLMM v1 (bin-based) - FIXED: removed duplicate match arm
        [0x21, 0x0b, 0x31, 0x62, 0xb5, 0x65, 0xb1, 0x0d] => {
            println! ("[{}] -> Detected DLMM v1 (bin-based pricing)", dex_name);
            
            // Try bin-based pricing first (most accurate for DLMM)
            if let Some(result) = parse_meteora_dlmm_v1_bin_price(
                data,
                dex_name,
                pool_address,
                base_decimals,
                quote_decimals,
                None, // No reference price available here
            ) {
                println!("[{}] [OK] Bin-based pricing successful", dex_name);
                return Some(result);
            }
            
            println!("[{}] [WARN] Bin pricing failed, using fallback", dex_name);
            return parse_meteora_dlmm_fallback(data, dex_name, pool_address);
        }
        
        // Orca Whirlpool (sometimes misclassified as Meteora)
        [0x3f, 0x95, 0xd1, 0x0c, 0xe1, 0x80, 0x63, 0x09] => {
            println!("[{}] Detected Orca Whirlpool, rerouting", dex_name);
            return parse_orca_whirlpool_binary(data, dex_name, pool_address, base_decimals, quote_decimals). await;
        }
        
        _ => {
            println!("[{}] [WARN] Unknown discriminator, using size-based detection", dex_name);
        }
    }

    // Fallback: Route based on pool size (less reliable)
    match data.len() {
        // Meteora AMM pools (~904 bytes)
        800..=950 => {
            println!("[{}] -> Routing to AMM parser (by size: {} bytes)", dex_name, data.len());
            parse_meteora_amm_binary(data, dex_name, pool_address, base_decimals, quote_decimals, "").await
        },
        // Meteora DLMM pools (~1112 bytes)
        1000..=1200 => {
            println!("[{}] -> Routing to DLMM parser (by size: {} bytes)", dex_name, data.len());
            parse_meteora_dlmm_v2_sqrt(data, dex_name, pool_address, base_decimals, quote_decimals)
        },
        // Unknown size - try AMM first
        _ => {
            println!("[{}] [WARN] Unexpected size: {} bytes, trying AMM", dex_name, data.len());
            parse_meteora_amm_binary(data, dex_name, pool_address, base_decimals, quote_decimals, ""). await
        }
    }
}


/// Parse Meteora DLMM v2 using sqrt_price at offset 456
/// FIXED: Now accepts dynamic decimals instead of hardcoded * 1000. 0
fn parse_meteora_dlmm_v2_sqrt(
    data: &[u8],
    dex_name: &str,
    pool_address: &str,
    base_decimals: u8,   // ADDED
    quote_decimals: u8,  // ADDED
) -> Option<EnhancedPriceUpdate> {
    println!("[{}] [DLMM v2] Parsing sqrt_price.. .", dex_name);
    
    // Based on diagnostic scan: sqrt_price at offset 456
    let sqrt_offset = 456;
    
    if sqrt_offset + 16 > data.len() {
        println! ("[{}] [X] Data too small for sqrt_price at offset {}", dex_name, sqrt_offset);
        return None;
    }
    
    let sqrt_price_x64 = read_u128_le(data, sqrt_offset)? ;
    
    if sqrt_price_x64 == 0 {
        println!("[{}] [X] Zero sqrt_price", dex_name);
        return None;
    }
    
    // Convert Q64.64 fixed point to float
    let sqrt_price = sqrt_price_x64 as f64 / ((1_u128 << 64) as f64);
    let raw_price = sqrt_price * sqrt_price;
    
    // FIX: Use dynamic decimal adjustment instead of hardcoded * 1000.0
    let decimal_adjustment = 10_f64.powi((base_decimals as i32) - (quote_decimals as i32));
    let price = raw_price * decimal_adjustment;
    
    println!("[{}]    sqrt_price_x64: {}", dex_name, sqrt_price_x64);
    println! ("[{}]    sqrt_price: {:.10}", dex_name, sqrt_price);
    println!("[{}]    raw_price: {:.10}", dex_name, raw_price);
    println!("[{}]    decimal_adj: {} (base={}, quote={})", dex_name, decimal_adjustment, base_decimals, quote_decimals);
    println!("[{}]    final_price: {:.8}", dex_name, price);
    
    // Dynamic sanity check
    if price <= 0.0 || price. is_nan() || price.is_infinite() {
        println!("[{}] [X] Invalid price: {}", dex_name, price);
        return None;
    }
    
    println!("[{}] [OK] DLMM v2 parse successful: {:.8}", dex_name, price);
    
    Some(EnhancedPriceUpdate {
        dex: dex_name.to_string(),
        token_pair: "CUSTOM".to_string(),
        price,
        timestamp: TokioInstant::now(),
        liquidity: None,
        data_source: DataSource::WebSocket,
        pool_address: pool_address.to_string(),
        reserve_token_a: None,
        reserve_token_b: None,
    })
}

/// Parse Meteora DLMM v1 using reserves at offset 216
fn parse_meteora_dlmm_v1_reserves(
    data: &[u8],
    dex_name: &str,
    pool_address: &str,
) -> Option<EnhancedPriceUpdate> {
    println! ("[{}] [DLMM v1] Parsing reserves...", dex_name);
    
    // Based on diagnostic scan: reserves at offset 216
    let reserve_a_offset = 216;
    let reserve_b_offset = 224;
    
    if reserve_b_offset + 8 > data.len() {
        println!("[{}] [X] Data too small for reserves at offset {}", dex_name, reserve_a_offset);
        return None;
    }
    
    let reserve_a = read_u64_le(data, reserve_a_offset)?;
    let reserve_b = read_u64_le(data, reserve_b_offset)?;
    
    if reserve_a == 0 || reserve_b == 0 {
        println! ("[{}] [X] Zero reserves detected", dex_name);
        return None;
    }
    
    // Calculate price with SOL (9 decimals) and USDC (6 decimals)
    let reserve_a_f = reserve_a as f64 / 1e9;  // SOL
    let reserve_b_f = reserve_b as f64 / 1e6;  // USDC
    let price = reserve_b_f / reserve_a_f;
    
    println!("[{}]    Reserve A (SOL): {:.6}", dex_name, reserve_a_f);
    println!("[{}]    Reserve B (USDC): {:.2}", dex_name, reserve_b_f);
    println! ("[{}]    Calculated price: ${:.6}", dex_name, price);
    
    // Sanity check
    if !(50.0..=500.0).contains(&price) {    
    println!("[{}] [X] Price out of range: ${:.6}", dex_name, price);
        return None;
    }
    
    let liquidity = reserve_a_f * price * 2.0;
    
    println!("[{}] [OK] DLMM v1 parse successful: ${:.4}", dex_name, price);
    
    Some(EnhancedPriceUpdate {
        dex: dex_name.to_string(),
        token_pair: "SOL/USDC". to_string(),
        price,
        timestamp: TokioInstant::now(),
        liquidity: Some(liquidity),
        data_source: DataSource::WebSocket,
        pool_address: pool_address.to_string(),
        reserve_token_a: Some(reserve_a),
        reserve_token_b: Some(reserve_b),
    })
}

/// Fallback parser using original multi-strategy approach
fn parse_meteora_dlmm_fallback(
    data: &[u8],
    dex_name: &str,
    pool_address: &str,
) -> Option<EnhancedPriceUpdate> {
    println!("[{}] [DLMM Fallback] Trying multiple strategies...", dex_name);
    
    let offset_strategies = [
        (81, 83, "Strategy 1 (adjusted)"),
        (73, 76, "Strategy 2 (original)"),
        (89, 93, "Strategy 3 (with padding)"),
        (65, 68, "Strategy 4 (compact)"),
    ];
    
    let mut valid_states = Vec::new();
    
    for (bin_step_offset, active_id_offset, strategy_name) in offset_strategies {
        if let (Some(bin_step), Some(active_id)) = 
            (read_u16_le(data, bin_step_offset), read_i32_le(data, active_id_offset)) {
            
            println!("[{}]    Trying {}: bin_step={}, active_id={}", 
                dex_name, strategy_name, bin_step, active_id);
            
            if bin_step > 0 && bin_step < 1000 && active_id != 0 && active_id. abs() < 100000 {
                let bin_step_decimal = bin_step as f64 / 10000.0;
                let price_raw = (1.0 + bin_step_decimal). powi(active_id);
                let price = price_raw * 1000.0;
                
                println!("[{}]       Calculated price: ${:.6}", dex_name, price);
                
                if (50.0..=500.0).contains(&price) {
                    valid_states.push((price, bin_step, active_id, strategy_name));
                } else {
                    let price_inverse = if price_raw > 0.0 { 1.0 / price_raw * 1000.0 } else { 0.0 };
                    if (50.0..=500.0).contains(&price_inverse) {
                        println!("[{}]       Using inverted price: ${:.6}", dex_name, price_inverse);
                        valid_states.push((price_inverse, bin_step, active_id, strategy_name));
                    }
                }
            }
        }
    }
    
    if valid_states.is_empty() {
        println!("[{}] [X] All fallback strategies failed", dex_name);
        return None;
    }
    
    valid_states.sort_by(|a, b| {
        let dist_a = (a.0 - 134.0).abs();
        let dist_b = (b.0 - 134.0).abs();
        dist_a.partial_cmp(&dist_b). unwrap()
    });
    
    let (price, bin_step, active_id, strategy) = &valid_states[0];
    
    println!("[{}] [OK] Fallback parse successful using {}: ${:.4}", dex_name, strategy, price);
    println!("[{}]    Bin step: {}, Active ID: {}", dex_name, bin_step, active_id);

    Some(EnhancedPriceUpdate {
        dex: dex_name.to_string(),
        token_pair: "SOL/USDC". to_string(),
        price: *price,
        timestamp: TokioInstant::now(),
        liquidity: None,
        data_source: DataSource::WebSocket,
        pool_address: pool_address.to_string(),
        reserve_token_a: None,
        reserve_token_b: None,
    })
}


/// Scan pool data for valid pubkey candidates and test them
async fn scan_for_vault_pubkeys(
    data: &[u8],
    dex_name: &str,
    rpc: &AsyncRpcClient,
) -> Option<(Pubkey, Pubkey, u64, u64)> {
    println!("[{}] [SCAN] Scanning for valid vault pubkeys.. .", dex_name);
    
    // Scan for pubkey-like patterns (32 bytes that could be valid pubkeys)
    // Pubkeys should NOT be all zeros and should be valid base58
    
    let mut potential_vaults: Vec<(usize, Pubkey)> = Vec::new();
    
    // Scan at 8-byte aligned offsets (most Solana structs are aligned)
    for offset in (8..data.len(). saturating_sub(32)).step_by(8) {
        let pubkey_bytes = &data[offset..offset + 32];
        
        // Skip if all zeros
        if pubkey_bytes.iter().all(|&b| b == 0) {
            continue;
        }
        
        // Try to create a pubkey
        if let Ok(pk) = Pubkey::try_from(pubkey_bytes) {
            // Check if it looks like a valid pubkey (not default, has reasonable bytes)
            if pk != Pubkey::default() {
                potential_vaults.push((offset, pk));
            }
        }
    }
    
    println!("[{}] Found {} potential pubkeys in pool data", dex_name, potential_vaults.len());
    
    // Now test each pubkey to see if it's a valid token account
    let mut valid_token_accounts: Vec<(usize, Pubkey, u64)> = Vec::new();
    
    for (offset, pk) in &potential_vaults {
        // Try to fetch as token account
        match rpc.get_token_account_balance(pk). await {
            Ok(balance) => {
                let amount = balance.amount. parse::<u64>().unwrap_or(0);
                println!("[{}]   Offset {}: {} -> balance: {}", dex_name, offset, pk, amount);
                valid_token_accounts. push((*offset, *pk, amount));
            }
            Err(_) => {
                // Not a token account, skip silently
            }
        }
    }
    
    println!("[{}] Found {} valid token accounts", dex_name, valid_token_accounts.len());
    
    // We need exactly 2 token accounts (reserve_x and reserve_y)
    // They should have non-zero balances for an active pool
    let non_zero_accounts: Vec<_> = valid_token_accounts
        . into_iter()
        .filter(|(_, _, bal)| *bal > 0)
        .collect();
    
    if non_zero_accounts.len() >= 2 {
        // Take the first two with non-zero balances
        let (off1, pk1, bal1) = &non_zero_accounts[0];
        let (off2, pk2, bal2) = &non_zero_accounts[1];
        
        println!("[{}] [OK] Found vault pair:", dex_name);
        println!("[{}]   Vault X at offset {}: {} (balance: {})", dex_name, off1, pk1, bal1);
        println!("[{}]   Vault Y at offset {}: {} (balance: {})", dex_name, off2, pk2, bal2);
        
        return Some((*pk1, *pk2, *bal1, *bal2));
    }
    
    println!("[{}] [X] Could not find valid vault pair", dex_name);
    None
}

/// Parse Meteora DLMM v1 by scanning for vaults with proper token order detection
async fn parse_meteora_dlmm_v1_scan_vaults(
    data: &[u8],
    dex_name: &str,
    pool_address: &str,
    base_decimals: u8,
    quote_decimals: u8,
    rpc: &AsyncRpcClient,
) -> Option<EnhancedPriceUpdate> {
    println!("[{}] [DLMM v1] Scanning for vault accounts with token order detection.. .", dex_name);
    
    if data.len() < 216 {
        println!("[{}] [X] Data too small for DLMM v1 structure", dex_name);
        return None;
    }
    
    // =========================================================================
    // STEP 1: Read token mints from pool data to determine token order
    // Meteora DLMM LbPair structure:
    //   token_x_mint: offset 88 (32 bytes)
    //   token_y_mint: offset 120 (32 bytes)
    //   reserve_x:    offset 152 (32 bytes) - this is the vault pubkey
    //   reserve_y:    offset 184 (32 bytes) - this is the vault pubkey
    // =========================================================================
    
    let token_x_mint_bytes = &data[88..120];
    let token_y_mint_bytes = &data[120.. 152];
    
    let token_x_mint = match Pubkey::try_from(token_x_mint_bytes) {
        Ok(pk) if pk != Pubkey::default() => pk,
        _ => {
            println!("[{}] [X] Failed to parse token_x_mint", dex_name);
            return None;
        }
    };
    
    let token_y_mint = match Pubkey::try_from(token_y_mint_bytes) {
        Ok(pk) if pk != Pubkey::default() => pk,
        _ => {
            println!("[{}] [X] Failed to parse token_y_mint", dex_name);
            return None;
        }
    };
    
    println!("[{}] token_x_mint: {}", dex_name, token_x_mint);
    println!("[{}] token_y_mint: {}", dex_name, token_y_mint);
    
    // =========================================================================
    // STEP 2: Read vault pubkeys and fetch balances
    // =========================================================================
    
    let reserve_x_bytes = &data[152..184];
    let reserve_y_bytes = &data[184..216];
    
    let reserve_x_pubkey = match Pubkey::try_from(reserve_x_bytes) {
        Ok(pk) if pk != Pubkey::default() => pk,
        _ => {
            println!("[{}] [X] Failed to parse reserve_x pubkey", dex_name);
            return None;
        }
    };
    
    let reserve_y_pubkey = match Pubkey::try_from(reserve_y_bytes) {
        Ok(pk) if pk != Pubkey::default() => pk,
        _ => {
            println!("[{}] [X] Failed to parse reserve_y pubkey", dex_name);
            return None;
        }
    };
    
    println! ("[{}] reserve_x vault: {}", dex_name, reserve_x_pubkey);
    println!("[{}] reserve_y vault: {}", dex_name, reserve_y_pubkey);
    
    // Fetch vault balances
    let balance_x = match rpc.get_token_account_balance(&reserve_x_pubkey).await {
        Ok(bal) => bal.amount. parse::<u64>().unwrap_or(0),
        Err(e) => {
            println!("[{}] [X] Failed to fetch reserve_x balance: {}", dex_name, e);
            return None;
        }
    };
    
    let balance_y = match rpc. get_token_account_balance(&reserve_y_pubkey). await {
        Ok(bal) => bal.amount.parse::<u64>(). unwrap_or(0),
        Err(e) => {
            println! ("[{}] [X] Failed to fetch reserve_y balance: {}", dex_name, e);
            return None;
        }
    };
    
    if balance_x == 0 || balance_y == 0 {
        println! ("[{}] [X] Zero balance in reserves: x={}, y={}", dex_name, balance_x, balance_y);
        return None;
    }
    
    println!("[{}] balance_x (raw): {}", dex_name, balance_x);
    println!("[{}] balance_y (raw): {}", dex_name, balance_y);
    
    // =========================================================================
    // STEP 3: Determine token order using Jupiter reference prices
    // We need to figure out: is token_x the base or the quote? 
    // =========================================================================
    
    // Get Jupiter prices for both tokens in the pool
    let token_x_usd_price = get_jupiter_token_price(&token_x_mint. to_string()). await;
    let token_y_usd_price = get_jupiter_token_price(&token_y_mint.to_string()).await;
    
    println! ("[{}] token_x USD price: ${:.8}", dex_name, token_x_usd_price);
    println! ("[{}] token_y USD price: ${:.8}", dex_name, token_y_usd_price);
    
    if token_x_usd_price <= 0.0 || token_y_usd_price <= 0.0 {
        println! ("[{}] [WARN] Could not get USD prices for token order detection", dex_name);
        // Fallback: try both directions and pick the one that makes sense
        return try_both_price_directions(
            dex_name, pool_address, 
            balance_x, balance_y, 
            base_decimals, quote_decimals
        );
    }
    
    // Calculate expected price ratio: base_token / quote_token
    // If token_x is USDC ($1) and token_y is AVICI ($6. 93):
    //   expected_price = 6.93 / 1. 0 = 6.93 (AVICI per USDC...  but we want USDC per AVICI)
    //   So if base=AVICI, quote=USDC: expected = AVICI_USD / USDC_USD = 6. 93
    
    // Determine which token is which based on their USD values
    // The token with higher USD value is likely the "base" in most trading pairs
    // But we need to match with what the user requested
    
    // Calculate both possible prices
    let balance_x_adjusted = balance_x as f64 / 10_f64. powi(base_decimals as i32);
    let balance_y_adjusted = balance_y as f64 / 10_f64. powi(quote_decimals as i32);
    
    // Try: token_x = base, token_y = quote Ã¢â€ â€™ price = y/x
    let price_x_as_base = balance_y_adjusted / balance_x_adjusted;
    
    // Try: token_y = base, token_x = quote Ã¢â€ â€™ price = x/y  
    let price_y_as_base = balance_x_adjusted / balance_y_adjusted;
    
    // Expected price from Jupiter: base_usd / quote_usd
    // If token_x is base: expected = token_x_usd / token_y_usd
    let expected_if_x_is_base = token_x_usd_price / token_y_usd_price;
    // If token_y is base: expected = token_y_usd / token_x_usd
    let expected_if_y_is_base = token_y_usd_price / token_x_usd_price;
    
    println!("[{}] price if X=base: {:.8} (expected: {:.8})", dex_name, price_x_as_base, expected_if_x_is_base);
    println! ("[{}] price if Y=base: {:.8} (expected: {:.8})", dex_name, price_y_as_base, expected_if_y_is_base);
    
    // Calculate deviations
    let dev_x_as_base = if expected_if_x_is_base > 0.0 {
        ((price_x_as_base - expected_if_x_is_base) / expected_if_x_is_base). abs()
    } else {
        f64::MAX
    };
    
    let dev_y_as_base = if expected_if_y_is_base > 0.0 {
        ((price_y_as_base - expected_if_y_is_base) / expected_if_y_is_base). abs()
    } else {
        f64::MAX
    };
    
    println!("[{}] deviation if X=base: {:.2}%", dex_name, dev_x_as_base * 100.0);
    println! ("[{}] deviation if Y=base: {:.2}%", dex_name, dev_y_as_base * 100.0);
    
    // Choose the interpretation with lower deviation
    let (price, base_balance, quote_balance, token_order) = if dev_x_as_base <= dev_y_as_base {
        println!("[{}] [OK] Using token_x as base (deviation: {:.2}%)", dex_name, dev_x_as_base * 100.0);
        (price_x_as_base, balance_x, balance_y, "X=base, Y=quote")
    } else {
        println! ("[{}] [OK] Using token_y as base (deviation: {:.2}%)", dex_name, dev_y_as_base * 100.0);
        (price_y_as_base, balance_y, balance_x, "Y=base, X=quote")
    };
    
    // Validate the chosen price is reasonable
    let final_deviation = dev_x_as_base. min(dev_y_as_base);
    if final_deviation > 0.5 {
        println!("[{}] [WARN] Best deviation is {:.2}% - price may be unreliable", 
            dex_name, final_deviation * 100.0);
    }
    
    // Calculate liquidity
    let base_amount = base_balance as f64 / 10_f64. powi(base_decimals as i32);
    let liquidity = base_amount * price * 2.0;
    
    println!("[{}] [OK] DLMM v1 vault scan successful: {:.8} ({})", dex_name, price, token_order);
    
    Some(EnhancedPriceUpdate {
        dex: dex_name. to_string(),
        token_pair: "CUSTOM".to_string(),
        price,
        timestamp: TokioInstant::now(),
        liquidity: Some(liquidity),
        data_source: DataSource::WebSocket,
        pool_address: pool_address.to_string(),
        reserve_token_a: Some(base_balance),
        reserve_token_b: Some(quote_balance),
    })
}

/// Fallback function when Jupiter prices aren't available
/// Tries both price directions and picks the one that seems more reasonable
fn try_both_price_directions(
    dex_name: &str,
    pool_address: &str,
    balance_x: u64,
    balance_y: u64,
    base_decimals: u8,
    quote_decimals: u8,
) -> Option<EnhancedPriceUpdate> {
    println!("[{}] [FALLBACK] Trying both price directions...", dex_name);
    
    let balance_x_adj = balance_x as f64 / 10_f64. powi(base_decimals as i32);
    let balance_y_adj = balance_y as f64 / 10_f64.powi(quote_decimals as i32);
    
    let price_xy = balance_y_adj / balance_x_adj;  // Y per X
    let price_yx = balance_x_adj / balance_y_adj;  // X per Y
    
    println!("[{}]   price (Y/X): {:.8}", dex_name, price_xy);
    println! ("[{}]   price (X/Y): {:.8}", dex_name, price_yx);
    
    // Heuristic: most traded pairs have prices between 0.0001 and 10000
    // If one direction gives a more "normal" looking price, use that
    
    let xy_reasonable = price_xy > 0.0001 && price_xy < 100000.0;
    let yx_reasonable = price_yx > 0.0001 && price_yx < 100000.0;
    
    let (price, base_bal, quote_bal) = match (xy_reasonable, yx_reasonable) {
        (true, false) => {
            println!("[{}]   Using Y/X direction", dex_name);
            (price_xy, balance_x, balance_y)
        },
        (false, true) => {
            println!("[{}]   Using X/Y direction", dex_name);
            (price_yx, balance_y, balance_x)
        },
        (true, true) => {
            // Both reasonable - prefer the one closer to 1.0 for stablecoin pairs
            // or the larger one for token/USD pairs
            if price_xy > 1.0 && price_xy > price_yx {
                println!("[{}]   Both valid, using Y/X (larger): {:.8}", dex_name, price_xy);
                (price_xy, balance_x, balance_y)
            } else {
                println!("[{}]   Both valid, using X/Y: {:.8}", dex_name, price_yx);
                (price_yx, balance_y, balance_x)
            }
        },
        (false, false) => {
            println!("[{}] [X] Neither direction produces a reasonable price", dex_name);
            return None;
        }
    };
    
    let base_amount = base_bal as f64 / 10_f64.powi(base_decimals as i32);
    let liquidity = base_amount * price * 2.0;
    
    println!("[{}] [OK] Fallback price: {:.8}", dex_name, price);
    
    Some(EnhancedPriceUpdate {
        dex: dex_name.to_string(),
        token_pair: "CUSTOM".to_string(),
        price,
        timestamp: TokioInstant::now(),
        liquidity: Some(liquidity),
        data_source: DataSource::WebSocket,
        pool_address: pool_address.to_string(),
        reserve_token_a: Some(base_bal),
        reserve_token_b: Some(quote_bal),
    })
}

// ============================================================================
// --- PUMPSWAP PARSER (FIX 1) ---
// ============================================================================

/// Parse PumpSwap pool binary data
/// PumpSwap pool accounts are typically 301 bytes and use a bonding curve model
async fn parse_pumpswap_binary(
    data: &[u8],
    dex_name: &str,
    pool_address: &str,
    token_a_mint: &str,
    token_b_mint: &str,
    rpc: &AsyncRpcClient,  // ADDED: Need RPC to fetch token account balances
) -> Option<EnhancedPriceUpdate> {
    let data_len = data.len();
    let pool_prefix = if pool_address.len() >= 12 { &pool_address[..12] } else { pool_address };
    println!("[{}] [PARSE] PumpSwap parse start: {} bytes (pool: {}...)", 
        dex_name, data_len, pool_prefix);
    
    // PumpSwap pools are typically 211-301 bytes
    if data_len < 211 {
        println!("[{}] [X] Data too small for PumpSwap pool: {} bytes (need >= 211)", dex_name, data_len);
        return None;
    }
    
    // Verify discriminator [f1, 9a, 6d, 04, 11, b1, 6d, bc]
    let discriminator = &data[0..8];
    let expected_discriminator: [u8; 8] = [0xf1, 0x9a, 0x6d, 0x04, 0x11, 0xb1, 0x6d, 0xbc];
    
    if discriminator != expected_discriminator {
        println!("[{}] [X] Invalid discriminator: {:02x?} (expected: {:02x?})", 
            dex_name, discriminator, expected_discriminator);
        return None;
    }
    println!("[{}] [INFO] Discriminator verified: {:02x?}", dex_name, discriminator);
    
    // =========================================================================
    // PUMPSWAP POOL STRUCTURE (from IDL):
    // Offset | Size | Field
    // 0      | 8    | Discriminator
    // 8      | 1    | pool_bump (u8)
    // 9      | 2    | index (u16)
    // 11     | 32   | creator (Pubkey)
    // 43     | 32   | base_mint (Pubkey)
    // 75     | 32   | quote_mint (Pubkey)
    // 107    | 32   | lp_mint (Pubkey)
    // 139    | 32   | pool_base_token_account (Pubkey) <- TOKEN ACCOUNT ADDRESS
    // 171    | 32   | pool_quote_token_account (Pubkey) <- TOKEN ACCOUNT ADDRESS
    // 203    | 8    | lp_supply (u64)
    // =========================================================================
    
    // Parse pool index
    let index = u16::from_le_bytes([data[9], data[10]]);
    println!("[{}] [INFO] Pool index: {}", dex_name, index);
    
    // Parse base_mint (offset 43)
    let base_mint_bytes = &data[43..75];
    let base_mint_pubkey = match Pubkey::try_from(base_mint_bytes) {
        Ok(pk) => pk,
        Err(_) => {
            println!("[{}] [X] Failed to parse base_mint pubkey", dex_name);
            return None;
        }
    };
    println!("[{}] [INFO] Base mint: {}", dex_name, base_mint_pubkey);
    
    // Parse quote_mint (offset 75)
    let quote_mint_bytes = &data[75..107];
    let quote_mint_pubkey = match Pubkey::try_from(quote_mint_bytes) {
        Ok(pk) => pk,
        Err(_) => {
            println!("[{}] [X] Failed to parse quote_mint pubkey", dex_name);
            return None;
        }
    };
    println!("[{}] [INFO] Quote mint: {}", dex_name, quote_mint_pubkey);
    
    // Parse pool_base_token_account (offset 139)
    let pool_base_account_bytes = &data[139..171];
    let pool_base_token_account = match Pubkey::try_from(pool_base_account_bytes) {
        Ok(pk) => pk,
        Err(_) => {
            println!("[{}] [X] Failed to parse pool_base_token_account pubkey", dex_name);
            return None;
        }
    };
    println!("[{}] [INFO] Pool base token account: {}", dex_name, pool_base_token_account);
    
    // Parse pool_quote_token_account (offset 171)
    let pool_quote_account_bytes = &data[171..203];
    let pool_quote_token_account = match Pubkey::try_from(pool_quote_account_bytes) {
        Ok(pk) => pk,
        Err(_) => {
            println!("[{}] [X] Failed to parse pool_quote_token_account pubkey", dex_name);
            return None;
        }
    };
    println!("[{}] [INFO] Pool quote token account: {}", dex_name, pool_quote_token_account);
    
    // Parse lp_supply (offset 203)
    let lp_supply_bytes: [u8; 8] = match data[203..211].try_into() {
        Ok(b) => b,
        Err(_) => {
            println!("[{}] [X] Failed to read lp_supply", dex_name);
            return None;
        }
    };
    let lp_supply = u64::from_le_bytes(lp_supply_bytes);
    println!("[{}] [INFO] LP supply: {}", dex_name, lp_supply);
    
    // =========================================================================
    // FETCH ACTUAL RESERVES FROM TOKEN ACCOUNTS
    // =========================================================================
    
    // Fetch base token account balance
    let base_balance = match rpc.get_token_account_balance(&pool_base_token_account).await {
        Ok(balance) => {
            let amount = balance.amount.parse::<u64>().unwrap_or(0);
            println!("[{}] [INFO] Base token balance: {} (raw)", dex_name, amount);
            amount
        },
        Err(e) => {
            println!("[{}] [X] Failed to fetch base token account: {}", dex_name, e);
            return None;
        }
    };
    
    // Fetch quote token account balance (SOL/WSOL)
    let quote_balance = match rpc.get_token_account_balance(&pool_quote_token_account).await {
        Ok(balance) => {
            let amount = balance.amount.parse::<u64>().unwrap_or(0);
            println!("[{}] [INFO] Quote token balance: {} (raw)", dex_name, amount);
            amount
        },
        Err(e) => {
            println!("[{}] [X] Failed to fetch quote token account: {}", dex_name, e);
            return None;
        }
    };
    
    if base_balance == 0 || quote_balance == 0 {
        println!("[{}] [X] Zero reserves: base={}, quote={}", dex_name, base_balance, quote_balance);
        return None;
    }
    
    // =========================================================================
    // CALCULATE PRICE
    // =========================================================================
    
    // Determine decimals from mints
    let base_decimals: u8 = if base_mint_pubkey.to_string() == SOL_MINT { 9 } else { 6 };
    let quote_decimals: u8 = if quote_mint_pubkey.to_string() == SOL_MINT { 9 } else { 6 };
    
    println!("[{}] [INFO] Decimals: base={}, quote={}", dex_name, base_decimals, quote_decimals);
    
    // Calculate adjusted reserves
    let base_reserves_f = base_balance as f64 / 10_f64.powi(base_decimals as i32);
    let quote_reserves_f = quote_balance as f64 / 10_f64.powi(quote_decimals as i32);
    
    println!("[{}] [INFO] Adjusted reserves:", dex_name);
    println!("[{}]   Base: {:.6} tokens", dex_name, base_reserves_f);
    println!("[{}]   Quote: {:.9} SOL", dex_name, quote_reserves_f);
    
    if base_reserves_f == 0.0 {
        println!("[{}] [X] Base reserves are zero after adjustment", dex_name);
        return None;
    }
    
    // Price = quote_reserves / base_reserves (SOL per token)
    let price = quote_reserves_f / base_reserves_f;
    
    println!("[{}] [INFO] Price: {:.10} SOL per token", dex_name, price);
    
    // Calculate liquidity (quote side * 2)
    let liquidity = quote_reserves_f * 2.0;
    
    println!("[{}] [OK] PumpSwap parse successful: {:.10} SOL | Liq: {:.4} SOL", 
        dex_name, price, liquidity);
    
    Some(EnhancedPriceUpdate {
        dex: dex_name.to_string(),
        token_pair: "TOKEN/SOL".to_string(),
        price,
        timestamp: TokioInstant::now(),
        liquidity: Some(liquidity),
        data_source: DataSource::WebSocket,
        pool_address: pool_address.to_string(),
        reserve_token_a: Some(base_balance),
        reserve_token_b: Some(quote_balance),
    })
}


/// Legacy function for backward compatibility
async fn parse_meteora_from_parsed(
    parsed: &serde_json::Value,
    dex_name: &str,
    pool_address: &str,
) -> Option<EnhancedPriceUpdate> {
    println!("[{}]  Parsing from JSON (fallback method)", dex_name);
    
    let info = parsed.get("info")?;
    
    let reserve_a = info.get("aTokenReserve")
        .or_else(|| info.get("tokenAReserve"))
        .or_else(|| info.get("reserveA"))
        .or_else(|| info.get("baseReserve"))
        .and_then(|v| v.as_str())
        .and_then(|s| s.parse::<u64>().ok())?;
        
    let reserve_b = info.get("bTokenReserve")
        .or_else(|| info.get("tokenBReserve"))
        .or_else(|| info.get("reserveB"))
        .or_else(|| info.get("quoteReserve"))
        .and_then(|v| v.as_str())
        .and_then(|s| s.parse::<u64>().ok())?;
    
    if reserve_a == 0 || reserve_b == 0 {
        println!("[{}]  JSON contained zero reserves", dex_name);
        return None;
    }
    
    let price = calculate_price_from_constant_product(reserve_a, reserve_b, 9, 6);
    let liquidity = calculate_liquidity_usd(reserve_a, reserve_b, price, 9, 6);
    
    println!("[{}]  JSON parse successful: ${:.6}", dex_name, price);
    
    Some(EnhancedPriceUpdate {
        dex: dex_name.to_string(),
        token_pair: "SOL/USDC".to_string(),
        price,
        timestamp: TokioInstant::now(),
        liquidity: Some(liquidity),
        data_source: DataSource::API,
        pool_address: pool_address.to_string(),
        reserve_token_a: Some(reserve_a),
        reserve_token_b: Some(reserve_b),
    })
}


/// Helper to detect pool type from account data
fn detect_meteora_pool_type(data: &[u8]) -> &'static str {
    if data.len() < 8 {
        return "Unknown";
    }
    
    let discriminator = &data[0..8];
    
    // Known discriminators (these are examples - update based on actual values)
    match discriminator {
        [0x62, 0x1e, 0x5f, 0x4e, 0xd7, 0x8c, 0x02, 0x3e] => "Meteora AMM",
        [0x5d, 0x8f, 0x91, 0x2a, 0xc4, 0x7b, 0x88, 0x2e] => "Meteora DLMM",
        _ => {
            // Fallback to size-based detection
            match data.len() {
                800..=950 => "Meteora AMM (by size)",
                1000..=1200 => "Meteora DLMM (by size)",
                _ => "Unknown Meteora Type",
            }
        }
    }
}

/// Test function to debug account parsing
async fn debug_account_data(dex_name: &str, pool_address: &str) -> Result<()> {
    println!("\n DEBUG MODE: Fetching account data for {}", dex_name);
    
    let client = AsyncRpcClient::new_with_commitment(
        QUICKNODE_RPC_URL.to_string(),
        CommitmentConfig::confirmed(),
    );
    
    let pubkey = Pubkey::from_str(pool_address)?;
    let account = client.get_account(&pubkey).await?;
    
    println!("   Account size: {} bytes", account.data.len());
    println!("   Owner: {}", account.owner);
    println!("   Lamports: {}", account.lamports);
    
    // Show first 100 bytes in hex
    println!("   First 100 bytes (hex):");
    for (i, chunk) in account.data.chunks(20).take(5).enumerate() {
        print!("   [{:03}]: ", i * 20);
        for byte in chunk {
            print!("{:02x} ", byte);
        }
        println!();
    }
    
    // Try parsing
    let result = match dex_name {
        "Raydium" => parse_raydium_amm_binary(&account.data, dex_name, pool_address).await,
        "Raydium CLMM" => parse_raydium_clmm_binary(&account.data, dex_name, pool_address).await,
        // FIX: Pass default decimals (9 for SOL, 6 for USDC/Other) for debugging
        "Orca V2" => parse_orca_whirlpool_binary(&account.data, dex_name, pool_address, 9, 6).await,
        // Meteora - All Pool Types (DLMM, DAMM V1, DAMM V2, Memecoin)
        "Meteora" | "Meteora DLMM" | "Meteora DAMM V1" | "Meteora DAMM V2" | "Meteora Memecoin" => {    
        parse_meteora_binary(&account.data, dex_name, pool_address, SOL_MINT, USDC_MINT, &client).await
        }
        _ => None,
    };
    
    if let Some(update) = result {
        println!("\n    Parse successful!");
        println!("   Price: ${:.6}", update.price);
        println!("   Liquidity: ${:.2}", update.liquidity.unwrap_or(0.0));
    } else {
        println!("\n    Parse failed");
    }
    
    Ok(())
}

// ============================================================================
// --- POOL BLACKLIST FILTER ---
// ============================================================================

// Add this function near the top of your WebSocket setup code
fn filter_blacklisted_pools(pools: &mut Vec<(String, String)>) {
    let blacklisted_pools = vec![
        "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2", // Wrong token pair (shows $479 instead of $134)
    ];

    let original_count = pools.len();
    
    pools.retain(|(dex_name, pool_addr)| {
        if blacklisted_pools.contains(&pool_addr.as_str()) {
            println!("[!] Skipping blacklisted pool: {} ({})", pool_addr, dex_name);
            false
        } else {
            true
        }
    });

    let filtered_count = original_count - pools.len();
    if filtered_count > 0 {
        println!("[INFO] Filtered out {} blacklisted pool(s)", filtered_count);
    }
    println!("[INFO] Using {} valid pools", pools.len());
}



// ============================================================================
// --- ENHANCED WEBSOCKET SUBSCRIPTION MANAGER ---
// ============================================================================

#[derive(Debug)]
struct CacheStatistics {
    total_entries: usize,
    ws_entries: usize,
    api_entries: usize,
    fresh_entries: usize,
    hit_rate: f64,
}

struct EnhancedWebSocketSubscriptionManager {
    price_cache: EnhancedPriceCache,
    subscriptions: Vec<(String, String)>,
    token_a_mint: String, // NEW FIELD
    token_b_mint: String, // NEW FIELD
}

impl EnhancedWebSocketSubscriptionManager {
    fn new(price_cache: EnhancedPriceCache) -> Self {
        // Default: Hardcoded pool addresses for major SOL/USDC pairs
        let subscriptions = vec![
            ("Raydium".to_string(), "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2".to_string()),
            ("Raydium CLMM".to_string(), "61R1ndXxvsWXXkWSyNkCxnzwd3zUNB8Q2ibmkiLPC8ht".to_string()),
            ("Orca V2".to_string(), "HJPjoWUrhoZzkNfRpHuieeFk9WcZWjwy6PBjZ81ngndJ".to_string()),
            ("Meteora DAMM V1".to_string(), "83v8iPyZihDEjDdY8RdZddyZNyUtXngz69Lgo9Kt5d6d".to_string()),
            ("Meteora DLMM".to_string(), "VANAy7EfFregN3N6vL3RXE8qKhdvua5eo71o8qmE76Z".to_string()),
        ];
        
        Self {
            price_cache,
            subscriptions,
            token_a_mint: SOL_MINT.to_string(),
            token_b_mint: USDC_MINT.to_string(),
        }
    }
    
    /// Create a new subscription manager with dynamically fetched pool addresses
    fn with_pools(price_cache: EnhancedPriceCache, pools: Vec<(String, String)>) -> Self {
        Self {
            price_cache,
            subscriptions: pools,
            token_a_mint: SOL_MINT.to_string(),
            token_b_mint: USDC_MINT.to_string(),
        }
    }
    
    /// Create a new subscription manager with custom token pair
    fn with_pools_and_tokens(price_cache: EnhancedPriceCache, pools: Vec<(String, String)>, token_a: &str, token_b: &str) -> Self {
        Self {
            price_cache,
            subscriptions: pools,
            token_a_mint: token_a.to_string(),
            token_b_mint: token_b.to_string(),
        }
    }
    
    async fn start(&self) {
        println!(" Starting SHARED WebSocket connection for {} pools...", self.subscriptions.len());
        
        let cache = self.price_cache.clone();
        let subs = self.subscriptions.clone();
        let token_a = self.token_a_mint.clone();
        let token_b = self.token_b_mint.clone();
        
        // Use a SINGLE shared connection for all subscriptions
        tokio::spawn(async move {
            loop {
                match connect_and_monitor_pools_shared(subs.clone(), cache.clone(), &token_a, &token_b).await {
                    Ok(_) => {
                        println!(" Shared WebSocket disconnected, reconnecting in 5s...");
                    }
                    Err(e) => {
                        eprintln!(" Shared WebSocket error: {}, reconnecting in 5s...", e);
                    }
                }
                tokio::time::sleep(Duration::from_secs(5)).await;
            }
        });
        
        // Wait for connection to establish
        tokio::time::sleep(Duration::from_millis(2000)).await;
        println!(" Shared WebSocket connection established\n");
    }

    
    async fn get_cache_statistics(&self) -> CacheStatistics {
        let cache = self.price_cache.read().await;
        let total_entries = cache.len();
        let mut ws_entries = 0;
        let mut api_entries = 0;
        let mut fresh_entries = 0;
        
        let now = TokioInstant::now();
        
        for update in cache.values() {
            match update.data_source {
                DataSource::WebSocket => ws_entries += 1,
                DataSource::API => api_entries += 1,
            }
            
            if now.duration_since(update.timestamp).as_millis() < PRICE_STALENESS_MS {
                fresh_entries += 1;
            }
        }
        
        CacheStatistics {
            total_entries,
            ws_entries,
            api_entries,
            fresh_entries,
            hit_rate: if total_entries > 0 {
                (fresh_entries as f64 / total_entries as f64) * 100.0
            } else {
                0.0
            },
        }
    }
}

// ============================================================================
// --- DATA STRUCTURES (EXISTING + UPDATED) ---
// ============================================================================

#[derive(Deserialize, Debug, Clone)]
struct TokenInfo {
    #[serde(alias = "address")]
    id: String,
    name: String,
    symbol: String,
    decimals: u32,
    #[serde(rename = "logoURI", alias = "icon")]
    #[allow(dead_code)]
    logo_uri: Option<String>,
    #[allow(dead_code)]
    tags: Option<Vec<String>>,
     // Enhanced fields from Jupiter Ultra API
    #[serde(rename = "isVerified", default)]
    is_verified: Option<bool>,

    #[serde(rename = "usdPrice", default)]
    usd_price: Option<f64>,

    #[serde(default)]
    liquidity: Option<f64>,

    #[serde(rename = "holderCount", default)]
    holder_count: Option<u64>,
}

#[derive(Deserialize, Debug, Clone, Serialize)]
struct OrderResponse {
    #[serde(rename = "outAmount")]
    out_amount: String,
    #[serde(rename = "inputMint")]
    input_mint: String,
    #[serde(rename = "outputMint")]
    output_mint: String,
    #[serde(rename = "inAmount")]
    in_amount: String,
    #[serde(rename = "slippageBps")]
    slippage_bps: u32,
    #[serde(rename = "priceImpactPct")]
    price_impact_pct: String,
    #[serde(rename = "otherAmountThreshold")]
    other_amount_threshold: String,
}

#[derive(Serialize, Debug)]
struct JitoBundle {
    jsonrpc: String,
    id: u64,
    method: String,
    params: Vec<Vec<String>>,
}

#[derive(Deserialize, Debug)]
#[allow(dead_code)]
struct JitoBundleStatusResponse {
    jsonrpc: String,
    id: u64,
    result: JitoBundleStatusResult,
}

#[derive(Deserialize, Debug)]
#[allow(dead_code)]
struct JitoBundleStatusResult {
    context: JitoContext,
    value: Vec<JitoBundleStatus>,
}

#[derive(Deserialize, Debug)]
#[allow(dead_code)]
struct JitoContext {
    slot: u64,
}

#[derive(Deserialize, Debug, Clone)]
#[serde(rename_all = "camelCase")]
#[allow(dead_code)]
struct JitoBundleStatus {
    bundle_id: String,
    #[serde(default)]
    transactions: Vec<String>,
    #[serde(default)]
    slot: Option<u64>,
    #[serde(default)]
    confirmation_status: Option<String>,
    #[serde(default)]
    err: Option<serde_json::Value>,
}

#[derive(Debug, Clone)]
#[allow(dead_code)]
struct TradeMetrics {
    timestamp: chrono::DateTime<chrono::Local>,
    success: bool,
    profit_usd: f64,
    trade_amount_sol: f64,
}

#[derive(Debug)]
struct RiskManager {
    daily_pnl: f64,
    consecutive_failures: u32,
    circuit_breaker_until: Option<chrono::DateTime<chrono::Local>>,
    trades_today: u32,
    trade_history: Vec<TradeMetrics>,
    last_reset_date: chrono::NaiveDate,
    persistent_state: PersistentState,
    last_state_save: TokioInstant,
}

impl RiskManager {
    fn new() -> Self {
        // Load persistent state from disk
        let mut persistent = PersistentState::load();
        persistent.check_daily_reset();
        
        // Parse circuit breaker time if exists
        let circuit_breaker = persistent.circuit_breaker_until.as_ref().and_then(|s| {
            chrono::DateTime::parse_from_rfc3339(s)
                .ok()
                .map(|dt| dt.with_timezone(&chrono::Local))
        });
        
        // Parse last reset date
        let last_reset = chrono::NaiveDate::parse_from_str(&persistent.last_reset_date, "%Y-%m-%d")
            .unwrap_or_else(|_| chrono::Local::now().date_naive());
        
        println!(" Restored state: P&L ${:.2}, {} trades today, {} all-time trades",
            persistent.daily_pnl, persistent.trades_today, persistent.total_trades_all_time);
        
        RiskManager {
            daily_pnl: persistent.daily_pnl,
            consecutive_failures: persistent.consecutive_failures,
            circuit_breaker_until: circuit_breaker,
            trades_today: persistent.trades_today,
            trade_history: Vec::new(),
            last_reset_date: last_reset,
            persistent_state: persistent,
            last_state_save: TokioInstant::now(),
        }
    }

    fn reset_daily_if_needed(&mut self) {
        let today = chrono::Local::now().date_naive();
        if today != self.last_reset_date {
            // Send daily summary alert
            let success_rate = if !self.trade_history.is_empty() {
                let successful = self.trade_history.iter().filter(|t| t.success).count();
                (successful as f64 / self.trade_history.len() as f64) * 100.0
            } else {
                0.0
            };
            
            let pnl = self.daily_pnl;
            let trades = self.trades_today;
            tokio::spawn(async move {
                alert_daily_summary(pnl, trades, success_rate).await;
            });
            
            println!("\n Daily Reset - Previous day P&L: ${:.2}", self.daily_pnl);
            self.daily_pnl = 0.0;
            self.trades_today = 0;
            self.last_reset_date = today;
            self.trade_history.clear();
            
            // Update persistent state
            self.persistent_state.daily_pnl = 0.0;
            self.persistent_state.trades_today = 0;
            self.persistent_state.last_reset_date = today.format("%Y-%m-%d").to_string();
            self.save_state();
        }
    }

    fn can_trade(&mut self) -> Result<(), String> {
        self.reset_daily_if_needed();
        if let Some(until) = self.circuit_breaker_until {
            if chrono::Local::now() < until {
                return Err(format!("Circuit breaker active until {}", until.format("%H:%M:%S")));
            } else {
                self.circuit_breaker_until = None;
                self.consecutive_failures = 0;
                self.persistent_state.circuit_breaker_until = None;
                self.persistent_state.consecutive_failures = 0;
                self.save_state();
            }
        }
        if self.daily_pnl <= -MAX_DAILY_LOSS_USD {
            return Err(format!("Daily loss limit reached: ${:.2} (limit: ${})", self.daily_pnl, MAX_DAILY_LOSS_USD));
        }
        if self.trades_today >= MAX_DAILY_TRADES {
            return Err(format!("Daily trade limit reached: {} trades", MAX_DAILY_TRADES));
        }
        Ok(())
    }
    
    fn save_state(&mut self) {
        // Only save if enough time has passed (avoid disk thrashing)
        if self.last_state_save.elapsed().as_secs() >= STATE_SAVE_INTERVAL_SECS {
            self.persistent_state.save();
            self.last_state_save = TokioInstant::now();
        }
    }
    
    fn force_save_state(&mut self) {
        self.persistent_state.save();
        self.last_state_save = TokioInstant::now();
    }

    fn record_trade(&mut self, success: bool, profit_usd: f64, trade_amount_sol: f64) {
        let metric = TradeMetrics {
            timestamp: chrono::Local::now(),
            success,
            profit_usd,
            trade_amount_sol,
        };
        self.trade_history.push(metric);
        self.trades_today += 1;
        
        // Update persistent state
        self.persistent_state.trades_today = self.trades_today;
        self.persistent_state.total_trades_all_time += 1;
        self.persistent_state.total_profit_all_time += profit_usd;
        
        if success {
            self.daily_pnl += profit_usd;
            self.consecutive_failures = 0;
            self.persistent_state.daily_pnl = self.daily_pnl;
            self.persistent_state.consecutive_failures = 0;
            self.persistent_state.successful_trades_all_time += 1;
            println!(" Trade successful. Daily P&L: ${:.2}", self.daily_pnl);
        } else {
            self.consecutive_failures += 1;
            self.daily_pnl += profit_usd;
            self.persistent_state.daily_pnl = self.daily_pnl;
            self.persistent_state.consecutive_failures = self.consecutive_failures;
            println!(" Trade failed. Consecutive failures: {}", self.consecutive_failures);
            
            if self.consecutive_failures >= MAX_CONSECUTIVE_FAILURES {
                let cooldown_until = chrono::Local::now() + chrono::Duration::minutes(CIRCUIT_BREAKER_COOLDOWN_MINUTES as i64);
                self.circuit_breaker_until = Some(cooldown_until);
                self.persistent_state.circuit_breaker_until = Some(cooldown_until.to_rfc3339());
                
                println!(" CIRCUIT BREAKER ACTIVATED until {}", cooldown_until.format("%H:%M:%S"));
                log_to_file(&format!("CIRCUIT BREAKER: {} consecutive failures, cooldown until {}", self.consecutive_failures, cooldown_until));
                
                // Send Telegram alert
                let reason = format!("{} consecutive failures", self.consecutive_failures);
                let until_str = cooldown_until.format("%H:%M:%S").to_string();
                tokio::spawn(async move {
                    alert_circuit_breaker(&reason, &until_str).await;
                });
            }
        }
        
        // Save state (throttled)
        self.save_state();
    }

    fn record_failure(&mut self) {
        self.consecutive_failures += 1;
        self.persistent_state.consecutive_failures = self.consecutive_failures;
        println!(" Execution failed. Consecutive failures: {}", self.consecutive_failures);
        
        if self.consecutive_failures >= MAX_CONSECUTIVE_FAILURES {
            let cooldown_until = chrono::Local::now() + chrono::Duration::minutes(CIRCUIT_BREAKER_COOLDOWN_MINUTES as i64);
            self.circuit_breaker_until = Some(cooldown_until);
            self.persistent_state.circuit_breaker_until = Some(cooldown_until.to_rfc3339());
            
            println!(" CIRCUIT BREAKER ACTIVATED until {}", cooldown_until.format("%H:%M:%S"));
            log_to_file(&format!("CIRCUIT BREAKER: {} consecutive failures, cooldown until {}", self.consecutive_failures, cooldown_until));
            
            // Send Telegram alert
            let reason = format!("{} consecutive failures", self.consecutive_failures);
            let until_str = cooldown_until.format("%H:%M:%S").to_string();
            tokio::spawn(async move {
                alert_circuit_breaker(&reason, &until_str).await;
            });
        }
        
        // Force save on failure
        self.force_save_state();
    }

    fn print_summary(&self) {
        println!("\n");
        println!("                 RISK MANAGEMENT SUMMARY                         ");
        println!("");
        println!("   Daily P&L (USDC):     ${:<12.2}                         ", self.daily_pnl);
        println!("   Trades Today:         {}/{}                                ", self.trades_today, MAX_DAILY_TRADES);
        println!("   Consecutive Failures: {}                                    ", self.consecutive_failures);
        println!("    Loss Limit Left:      ${:<12.2} USDC                     ", MAX_DAILY_LOSS_USD + self.daily_pnl.min(0.0));
        let successful_trades = self.trade_history.iter().filter(|t| t.success).count();
        let total_trades = self.trade_history.len();
        if total_trades > 0 {
            println!("   Success Rate:         {:.1}% ({}/{})                         ",
                (successful_trades as f64 / total_trades as f64) * 100.0,
                successful_trades,
                total_trades
            );
        }
        println!("");
        println!("   ALL-TIME STATISTICS                                         ");
        println!("     Total Trades:   {}                                          ", self.persistent_state.total_trades_all_time);
        println!("     Total Profit:   ${:.2} USDC                                 ", self.persistent_state.total_profit_all_time);
        println!("     Success Rate:   {:.1}%                                      ", 
            if self.persistent_state.total_trades_all_time > 0 {
                (self.persistent_state.successful_trades_all_time as f64 / self.persistent_state.total_trades_all_time as f64) * 100.0
            } else { 0.0 });
        println!("\n");
    }
}

#[derive(Debug, Clone)]
struct ArbitrageOpportunity {
    sell_dex: String,
    buy_dex: String,
    sell_quote: OrderResponse,
    buy_quote: OrderResponse,
    gross_profit_sol: f64,
    net_profit_usd: f64,
    spread_pct: f64,
    trade_amount_sol: f64,
}

#[derive(Debug, Clone)]
struct EnhancedArbitrageOpportunity {
    sell_dex: String,
    buy_dex: String,
    sell_quote: OrderResponse,
    buy_quote: OrderResponse,
    gross_profit_sol: f64,
    net_profit_usd: f64,
    spread_pct: f64,
    trade_amount_sol: f64,
    price_impact_sell: f64,
    price_impact_buy: f64,
    estimated_execution_time_ms: u64,
    confidence_score: f64,
    quote_age_ms: u128,
    // NEW: Add timestamp tracking
    sell_quote_timestamp_ms: u128,
    buy_quote_timestamp_ms: u128,
    sell_quote_slot: Option<u64>,
    buy_quote_slot: Option<u64>,
}


#[derive(Debug, Clone)]
struct DexLiquidity {
    dex_name: String,
    base_liquidity_usd: f64,
    quote_liquidity_usd: f64,
    twenty_four_hour_volume: f64,
    last_updated: std::time::Instant,
}

#[derive(Debug)]
struct MarketState {
    recent_spreads: BTreeMap<String, Vec<(chrono::DateTime<chrono::Local>, f64)>>,
    dex_liquidity: HashMap<String, DexLiquidity>,
    failed_executions: Vec<(String, String, chrono::DateTime<chrono::Local>)>,
    successful_trades: Vec<EnhancedArbitrageOpportunity>,
}

impl MarketState {
    fn new() -> Self {
        Self {
            recent_spreads: BTreeMap::new(),
            dex_liquidity: HashMap::new(),
            failed_executions: Vec::new(),
            successful_trades: Vec::new(),
        }
    }
    
    fn record_spread(&mut self, dex_pair: String, spread: f64) {
        let entry = self.recent_spreads.entry(dex_pair).or_insert_with(Vec::new);
        entry.push((chrono::Local::now(), spread));
        if entry.len() > 50 {
            entry.remove(0);
        }
    }
    
    fn get_average_spread(&self, dex_pair: &str) -> Option<f64> {
        self.recent_spreads.get(dex_pair).and_then(|spreads| {
            if spreads.is_empty() {
                None
            } else {
                Some(spreads.iter().map(|(_, s)| s).sum::<f64>() / spreads.len() as f64)
            }
        })
    }
    
    fn is_dex_pair_reliable(&self, sell_dex: &str, buy_dex: &str) -> bool {
        let recent_failures = self.failed_executions.iter()
            .filter(|(s, b, time)| {
                s == sell_dex && b == buy_dex && 
                chrono::Local::now().signed_duration_since(*time).num_minutes() < 30
            })
            .count();
        recent_failures < 3
    }
    
    fn update_liquidity(&mut self, dex_name: String, liquidity: DexLiquidity) {
        self.dex_liquidity.insert(dex_name, liquidity);
    }
    
    fn get_dex_health_score(&self, dex_name: &str) -> f64 {
        if let Some(liquidity) = self.dex_liquidity.get(dex_name) {
            let age_seconds = liquidity.last_updated.elapsed().as_secs();
            let recency_score = if age_seconds < 30 { 1.0 } else { 0.5 };
            let liquidity_score = (liquidity.base_liquidity_usd / 10000.0).min(1.0);
            (recency_score + liquidity_score) / 2.0 * 100.0
        } else {
            50.0
        }
    }
}

fn log_to_file(message: &str) {
    use std::fs::OpenOptions;
    use std::io::Write as IoWrite;
    
    let timestamp = chrono::Local::now().format("%Y-%m-%d %H:%M:%S");
    let log_message = format!("[{}] {}\n", timestamp, message);
    
    if let Ok(mut file) = OpenOptions::new()
        .create(true)
        .append(true)
        .open("/tmp/arbitrage_bot.log") {
        let _ = file.write_all(log_message.as_bytes());
    }
}

// ============================================================================
// --- JUPITER ULTRA V1 STRUCTURES ---
// ============================================================================

#[derive(Debug, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct UltraV1OrderRequest {
    pub input_mint: String,
    pub output_mint: String,
    pub amount: u64,
    pub taker: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub slippage_bps: Option<u16>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub auto_slippage: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub auto_slippage_collision_u_turn: Option<bool>,
}

#[derive(Debug, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct UltraV1OrderResponse {
    pub mode: String,
    pub input_mint: String,
    pub output_mint: String,
    pub in_amount: String,
    pub out_amount: String,
    pub other_amount_threshold: String,
    pub swap_mode: String,
    pub slippage_bps: u16,
    pub price_impact_pct: String,
    #[allow(dead_code)]
    pub route_plan: Vec<serde_json::Value>,
    pub request_id: String,
    pub transaction: String,
    #[allow(dead_code)]
    pub signature_fee: Option<String>,
    #[allow(dead_code)]
    pub prioritization_fee: Option<String>,
    #[serde(default)]
    pub error_code: Option<String>,
    #[serde(default)]
    pub error_message: Option<String>,
}

#[derive(Debug, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct UltraV1ExecuteRequest {
    pub signed_transaction: String,
    pub request_id: String,
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct UltraV1ExecuteResponse {
    pub status: String,
    pub signature: Option<String>,
    #[allow(dead_code)]
    pub slot: Option<String>,
    pub error: Option<String>,
    #[allow(dead_code)]
    pub code: Option<i32>,
    #[allow(dead_code)]
    pub total_input_amount: Option<String>,
    pub input_amount_result: Option<String>,
    pub output_amount_result: Option<String>,
    #[allow(dead_code)]
    pub swap_events: Option<Vec<serde_json::Value>>,
}

#[derive(Debug, Clone)]
pub struct WalletBalanceV1 {
    pub sol_balance: u64,
    pub usdc_balance: u64,
}

impl WalletBalanceV1 {
    pub fn display(&self) {
        println!("\n Wallet Balance:");
        println!(
            "   SOL:  {:.9} SOL",
            self.sol_balance as f64 / LAMPORTS_PER_SOL as f64
        );
        println!(
            "   USDC: {:.6} USDC",
            self.usdc_balance as f64 / 10u64.pow(USDC_DECIMALS) as f64
        );
    }
}

// ============================================================================
// --- SOLANA CLIENT & UTILITIES ---
// ============================================================================

struct SolanaClient {
    client: RpcClient,
}

impl SolanaClient {
    fn new() -> Self {
        let rpc_url = HARDCODED_RPC_URL;
        let client = RpcClient::new_with_commitment(rpc_url.to_string(), CommitmentConfig::confirmed());
        SolanaClient { client }
    }

    fn get_token_balance(&self, pubkey: &Pubkey, mint: &str) -> Result<f64> {
        if mint == SOL_MINT {
            let lamports = self.client.get_balance(pubkey)?;
            return Ok(lamports_to_sol(lamports));
        }

        let token_account_pubkey = spl_associated_token_account::get_associated_token_address(
            pubkey,
            &Pubkey::from_str(mint)?
        );
        match self.client.get_token_account_balance(&token_account_pubkey) {
            Ok(token_balance) => {
                let amount = token_balance.ui_amount.unwrap_or(0.0);
                Ok(amount)
            },
            Err(e) => {
                if e.to_string().contains("AccountNotFound") ||
                   e.to_string().contains("could not find account") {
                    Ok(0.0)
                } else {
                    Err(anyhow!("Error fetching token balance for {}: {}", mint, e))
                }
            }
        }
    }

    fn simulate_transaction(&self, transaction: &solana_sdk::transaction::VersionedTransaction) -> Result<()> {
        match self.client.simulate_transaction(transaction) {
            Ok(result) => {
                if let Some(err) = result.value.err {
                    return Err(anyhow!("Transaction simulation failed: {:?}", err));
                }
                Ok(())
            },
            Err(e) => Err(anyhow!("Failed to simulate transaction: {}", e))
        }
    }
}

pub struct JupiterUltraV1Client {
    rpc_client: AsyncRpcClient,
    http_client: reqwest::Client,
    wallet: Keypair,
    #[allow(dead_code)]
    usdc_mint: Pubkey,
    #[allow(dead_code)]
    sol_mint: Pubkey,
    usdc_token_account: Pubkey,
}

impl JupiterUltraV1Client {
    pub fn new(rpc_url: &str, wallet: Keypair) -> Result<Self> {
        let rpc_client = AsyncRpcClient::new_with_commitment(
            rpc_url.to_string(),
            CommitmentConfig::confirmed(),
        );

        let usdc_mint = Pubkey::from_str(USDC_MINT)?;
        let sol_mint = Pubkey::from_str(SOL_MINT)?;
        let usdc_token_account = spl_associated_token_account::get_associated_token_address(&wallet.pubkey(), &usdc_mint);

        let mut headers = reqwest::header::HeaderMap::new();
        headers.insert(
            "x-api-key",
            reqwest::header::HeaderValue::from_static(JUPITER_API_KEY),
        );

        let http_client = reqwest::Client::builder()
            .timeout(Duration::from_secs(30))
            .default_headers(headers)
            .build()?;

        Ok(Self {
            rpc_client,
            http_client,
            wallet,
            usdc_mint,
            sol_mint,
            usdc_token_account,
        })
    }

    pub async fn get_balances(&self) -> Result<WalletBalanceV1> {
        let sol_balance = self.rpc_client.get_balance(&self.wallet.pubkey()).await.map_err(|e| anyhow!(e))?;
        let usdc_balance = match self.rpc_client.get_token_account_balance(&self.usdc_token_account).await {
            Ok(balance) => balance.amount.parse::<u64>().context("Failed to parse USDC balance")?,
            Err(_e) => 0,
        };
        Ok(WalletBalanceV1 { sol_balance, usdc_balance })
    }

    pub async fn get_order(
        &self,
        input_mint: &str,
        output_mint: &str,
        amount: u64,
        slippage_bps: Option<u16>,
    ) -> Result<UltraV1OrderResponse> {
        let order_request = UltraV1OrderRequest {
            input_mint: input_mint.to_string(),
            output_mint: output_mint.to_string(),
            amount,
            taker: self.wallet.pubkey().to_string(),
            slippage_bps,
            auto_slippage: if slippage_bps.is_none() { Some(true) } else { Some(false) },
            auto_slippage_collision_u_turn: None,
        };
        let url = format!("{}order", JUPITER_ULTRA_API);
        let response = self.http_client.get(&url).query(&order_request).send().await?;

        if !response.status().is_success() {
            let status = response.status();
            let error_text = response.text().await?;
            return Err(anyhow!("Order request failed with status {}: {}", status, error_text));
        }

        let order: UltraV1OrderResponse = response.json().await.context("Failed to parse order response")?;
        if let Some(error_msg) = &order.error_message {
            return Err(anyhow!("Order error: {}", error_msg));
        }

        let in_amount: u64 = order.in_amount.parse()?;
        let out_amount: u64 = order.out_amount.parse()?;
        let price_impact: f64 = order.price_impact_pct.parse().unwrap_or(0.0);

        println!("\n Order Details:");
        println!("   Mode: {} ({})", order.mode, order.swap_mode);
        println!("   Input:  {} {}", self.format_token_amount(input_mint, in_amount), self.get_token_symbol(input_mint));
        println!("   Output: {} {}", self.format_token_amount(output_mint, out_amount), self.get_token_symbol(output_mint));
        println!("   Price Impact: {:.4}%", price_impact);
        println!("   Slippage Tolerance: {:.2}% ({} bps)", order.slippage_bps as f64 / 100.0, order.slippage_bps);
        println!("   Request ID: {}", order.request_id);

        Ok(order)
    }

    pub async fn execute_order(&self, order: UltraV1OrderResponse) -> Result<String> {
        let transaction_bytes = general_purpose::STANDARD.decode(&order.transaction).context("Failed to decode transaction")?;
        let mut transaction: solana_sdk::transaction::VersionedTransaction = bincode::deserialize(&transaction_bytes).context("Failed to deserialize transaction")?;

        let message_bytes = transaction.message.serialize();
        let account_keys = transaction.message.static_account_keys();
        let our_pubkey = self.wallet.pubkey();

        let our_signer_index = account_keys
            .iter()
            .position(|key| key == &our_pubkey)
            .ok_or_else(|| anyhow!("Our wallet not found in transaction signers"))?;
        let signature = self.wallet.sign_message(&message_bytes);

        if our_signer_index < transaction.signatures.len() {
            transaction.signatures[our_signer_index] = signature;
        } else {
            return Err(anyhow!("Signer index {} out of bounds", our_signer_index));
        }

        let signed_tx_bytes = bincode::serialize(&transaction).context("Failed to serialize signed transaction")?;
        let signed_tx_base64 = general_purpose::STANDARD.encode(&signed_tx_bytes);
        let execute_request = UltraV1ExecuteRequest {
            signed_transaction: signed_tx_base64,
            request_id: order.request_id.clone(),
        };
        let url = format!("{}execute", JUPITER_ULTRA_API);
        let response = self.http_client.post(&url).json(&execute_request).send().await?;

        if !response.status().is_success() {
            let status = response.status();
            let error_text = response.text().await?;
            return Err(anyhow!("Execute request failed with status {}: {}", status, error_text));
        }

        let execute_response: UltraV1ExecuteResponse = response.json().await.context("Failed to parse execute response")?;
        if execute_response.status != "Success" {
            let error_msg = execute_response.error.unwrap_or_else(|| "Unknown error".to_string());
            return Err(anyhow!("Swap execution failed: {}", error_msg));
        }

        let signature = execute_response.signature.ok_or_else(|| anyhow!("No signature in successful response"))?;
        println!("\n Transaction Details:");
        println!("   Signature: {}", signature);
        println!("   View on Solscan: https://solscan.io/tx/{}", signature);
        if let (Some(input_result), Some(output_result)) = (execute_response.input_amount_result, execute_response.output_amount_result) {
            println!("\n Swap Results:");
            println!("   Input Amount:  {}", input_result);
            println!("   Output Amount: {}", output_result);
        }

        Ok(signature)
    }

    fn format_token_amount(&self, mint: &str, amount: u64) -> String {
        if mint == SOL_MINT {
            format!("{:.9}", amount as f64 / LAMPORTS_PER_SOL as f64)
        } else if mint == USDC_MINT {
            format!("{:.6}", amount as f64 / 10u64.pow(USDC_DECIMALS) as f64)
        } else {
            amount.to_string()
        }
    }

    fn get_token_symbol(&self, mint: &str) -> &str {
        if mint == SOL_MINT {
            "SOL"
        } else if mint == USDC_MINT {
            "USDC"
        } else {
            "TOKEN"
        }
    }
}

// ============================================================================
// --- UTILITY FUNCTIONS ---
// ============================================================================


fn get_dynamic_priority_fee(sol_price_usd: f64, net_profit_usd: f64) -> u64 {
    let base_tip = JITO_TIP_LAMPORTS;
    let extra_afford_usd = net_profit_usd * 0.10;
    let extra_afford_lamports = (extra_afford_usd / sol_price_usd * LAMPORTS_PER_SOL as f64) as u64;
    base_tip + extra_afford_lamports.min(20_000_000)
}

fn load_keypair_secure() -> Result<Keypair> {
    println!("\n");
    println!("          SECURE KEYPAIR LOADING                    ");
    println!("");
    println!("\nOptions:");
    println!("1. Load from JSON file (recommended)");
    println!("2. Enter private key (UNSAFE - terminal input)");
    print!("\nChoice: ");
    io::stdout().flush()?;
    let mut choice = String::new();
    io::stdin().read_line(&mut choice)?;

    match choice.trim() {
        "1" => {
            println!("\nEnter path to keypair JSON file:");
            println!("(e.g., ~/.config/solana/id.json)");
            let mut path = String::new();
            io::stdin().read_line(&mut path)?;
            let path = path.trim();
            let expanded_path = if path.starts_with("~/") {
                let home = std::env::var("HOME").unwrap_or_else(|_| ".".to_string());
                PathBuf::from(home).join(&path[2..])
            } else {
                PathBuf::from(path)
            };
            let keypair_bytes = fs::read(&expanded_path)
                .map_err(|e| anyhow!("Failed to read keypair file: {}", e))?;
            let keypair_bytes: Vec<u8> = serde_json::from_slice(&keypair_bytes)
                .map_err(|e| anyhow!("Failed to parse keypair JSON: {}", e))?;
            let keypair = Keypair::from_bytes(&keypair_bytes)
                .map_err(|e| anyhow!("Failed to parse keypair: {}", e))?;
            println!(" Keypair loaded successfully from file");
            Ok(keypair)
        },
        "2" => {
            println!("\n  WARNING: This method is INSECURE");
            println!("Private key will be visible in terminal history");
            println!("\nEnter private key (base58):");

            let mut private_key = String::new();
            io::stdin().read_line(&mut private_key)?;
            let private_key_str = private_key.trim().to_string();

            let keypair_result = panic::catch_unwind(move || {
                Keypair::from_base58_string(&private_key_str)
            });
            match keypair_result {
                Ok(kp) => {
                    println!(" Keypair loaded successfully");
                    Ok(kp)
                },
                Err(_) => Err(anyhow!("Invalid private key format"))
            }
        },
        _ => Err(anyhow!("Invalid choice"))
    }
}

fn build_authenticated_client() -> Result<reqwest::Client> {
    let mut headers = reqwest::header::HeaderMap::new();
    headers.insert(
        "x-api-key",
        reqwest::header::HeaderValue::from_static(JUPITER_API_KEY),
    );

    Ok(reqwest::Client::builder()
        .timeout(Duration::from_secs(30))
        .default_headers(headers)
        .build()?)
}

async fn fetch_with_rate_limit_handling(
    client: &reqwest::Client,
    url: String,
) -> Result<reqwest::Response> {
    let mut retries = 0;
    let mut backoff_ms = INITIAL_BACKOFF_MS;
    loop {
        let response = client.get(&url).send().await?;
        if response.status() == reqwest::StatusCode::TOO_MANY_REQUESTS {
            if retries >= MAX_RATE_LIMIT_RETRIES {
                return Err(anyhow!("Rate limit exceeded after {} retries", MAX_RATE_LIMIT_RETRIES));
            }

            println!("     Rate limit hit, backing off {}ms (retry {}/{})", backoff_ms, retries + 1, MAX_RATE_LIMIT_RETRIES);
            tokio::time::sleep(Duration::from_millis(backoff_ms)).await;

            retries += 1;
            backoff_ms *= 2;
            continue;
        }

        return Ok(response);
    }
}

async fn get_sol_usdc_price() -> Result<f64> {
    let url = format!(
        "{}?inputMint={}&outputMint={}&amount={}&slippageBps=0",
        JUPITER_ORDER_API_URL, SOL_MINT, USDC_MINT, COMPARISON_AMOUNT_SOL
    );
    let client = build_authenticated_client()?;
    let response = fetch_with_rate_limit_handling(&client, url).await?;

    if !response.status().is_success() {
        return Err(anyhow!("API error when fetching price"));
    }
    let response: OrderResponse = response.json().await?;
    let out_amount_u64 = response.out_amount.parse::<u64>()?;
    Ok(out_amount_u64 as f64 / 10u64.pow(USDC_DECIMALS) as f64)
}

async fn search_token_by_address(address: &str) -> Result<TokenInfo> {
    let url = format!("{}?query={}", JUPITER_SEARCH_API_URL, address);
    let client = build_authenticated_client()?;

    let response = client.get(&url).send().await?;

    if !response.status().is_success() {
        let status = response.status();
        let error_text = response.text().await?;
        return Err(anyhow!("Token search failed with status {}: {}", status, error_text));
    }

    let tokens: Vec<TokenInfo> = response.json().await
        .context("Failed to parse token search response")?;

    if tokens.is_empty() {
        return Err(anyhow!("Token not found: {}", address));
    }

    let address_lower = address.to_lowercase();
    for token in &tokens {
        if token.id.to_lowercase() == address_lower {
            return Ok(token.clone());
        }
    }

    Ok(tokens[0].clone())
}


/// Search for token with fallback to Jupiter Ultra API
async fn search_token_with_fallback(address: &str) -> Result<TokenInfo> {
    println!("[SCAN] Searching for token information...");

    // Try Jupiter Ultra API first
    match search_token_by_address_jupiter(address).await {
        Ok(info) => {
            println!("   Source: Jupiter Ultra API [OK]");
            Ok(info)
        },
        Err(e) => {
            println!("   [WARN] Jupiter search failed: {}", e);
            println!("   Trying legacy API.. .");

            // Fallback to legacy API
            match search_token_by_address(address).await {
                Ok(info) => {
                    println!("   Source: Legacy API [OK]");
                    Ok(info)
                },
                Err(e2) => {
                    println! ("   [X] Both APIs failed");
                    Err(anyhow!("Token search failed: Jupiter ({}), Legacy ({})", e, e2))
                }
            }
        }
    }
}

/// Enhanced token search using Jupiter Ultra API

async fn search_token_by_address_jupiter(address: &str) -> Result<TokenInfo> {
    let encoded_address = urlencoding::encode(address);
    let url = format!("https://api.jup.ag/ultra/v1/search?query={}", encoded_address);

    let mut headers = reqwest::header::HeaderMap::new();
    headers.insert(
        "x-api-key",
        reqwest::header::HeaderValue::from_static(JUPITER_API_KEY),
    );

    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(10))
        .default_headers(headers)
        . build()?;

    let mut retries = 0;
    const MAX_RETRIES: u32 = 2;

    loop {
        match client. get(&url).send().await {
            Ok(response) => {
                return match response.status() {
                    reqwest::StatusCode::OK => {
                        let tokens: Vec<TokenInfo> = response.json().await
                            .context("Failed to parse Jupiter token search response")?;

                        if tokens. is_empty() {
                            return Err(anyhow! ("Token not found in Jupiter database: {}", address));
                        }

                        let address_lower = address.to_lowercase();
                        for token in &tokens {
                            if token.id.to_lowercase() == address_lower {
                                println!("   [OK] Found via Jupiter Ultra API:");
                                println!("     Name:     {}", token.name);
                                println!("     Symbol:   {}", token.symbol);
                                println!("     Decimals: {}", token.decimals);

                                if let Some(true) = token.is_verified {
                                    println!("     Status:    Verified");
                                }

                                if let Some(price) = token.usd_price {
                                println!("     Price:    ${:.6}", price);
                                }

                                if let Some(liq) = token. liquidity {
                                    println!("     Liquidity: ${:.2}", liq);
                                }

                                if let Some(holders) = token.holder_count {
                                    println!("     Holders:  {}", holders);
                                }

                                return Ok(token.clone());
                            }
                        }

                        println!("   [WARN] No exact match, using first result");
                        Ok(tokens[0].clone())
                    },
                    reqwest::StatusCode::NOT_FOUND => {
                        Err(anyhow!("Token not found: {}", address))
                    },
                    reqwest::StatusCode::TOO_MANY_REQUESTS => {
                        Err(anyhow!("Rate limited - please wait before retrying"))
                    },
                    reqwest::StatusCode::BAD_REQUEST => {
                        let error_text = response.text().await.unwrap_or_else(|_| "Unknown error".to_string());
                        Err(anyhow!("Invalid token address format: {}", error_text))
                    },
                    status => {
                        let error_text = response.text(). await.unwrap_or_else(|_| "Unknown error". to_string());
                        Err(anyhow!("Jupiter API error ({}): {}", status, error_text))
                    }
                };
            },
            Err(e) if retries < MAX_RETRIES && e.is_timeout() => {
                retries += 1;
                println!("   [RETRY {}/{}] Request timeout, retrying...", retries, MAX_RETRIES);
                tokio::time::sleep(Duration::from_millis(500 * retries as u64)).await;
                continue;
            },
            Err(e) if retries < MAX_RETRIES && e. is_connect() => {
                retries += 1;
                println!("   [RETRY {}/{}] Connection error, retrying...", retries, MAX_RETRIES);
                tokio::time::sleep(Duration::from_millis(500 * retries as u64)).await;
                continue;
            },
            Err(e) => {
                return Err(anyhow!("Jupiter API request failed: {}", e));
            }
        }
    }
}

async fn get_token_price_in_usdc(token_mint: &str, amount: u64) -> Result<f64> {
    let url = format!(
        "{}?inputMint={}&outputMint={}&amount={}&slippageBps=0",
        JUPITER_ORDER_API_URL, token_mint, USDC_MINT, amount
    );
    let client = build_authenticated_client()?;
    let response = fetch_with_rate_limit_handling(&client, url).await?;

    if !response.status().is_success() {
        return Err(anyhow!("API error when fetching token price"));
    }
    let response: OrderResponse = response.json().await?;
    let out_amount_u64 = response.out_amount.parse::<u64>()?;
    Ok(out_amount_u64 as f64 / 10u64.pow(USDC_DECIMALS) as f64)
}

async fn get_token_price_from_dex(token_mint: &str, amount: u64, dex_label: &str) -> Result<f64> {
    let url = format!(
        "{}?inputMint={}&outputMint={}&amount={}&slippageBps=0&onlyDexes={}",
        JUPITER_ORDER_API_URL, token_mint, USDC_MINT, amount, dex_label
    );
    let client = build_authenticated_client()?;
    let response = fetch_with_rate_limit_handling(&client, url).await?;

    if !response.status().is_success() {
        return Err(anyhow!("API error"));
    }
    let quote: OrderResponse = response.json().await?;
    let out_amount_u64 = quote.out_amount.parse::<u64>()?;
    Ok(out_amount_u64 as f64 / 10u64.pow(USDC_DECIMALS) as f64)
}


/// Get quote with timestamp tracking for freshness validation
async fn get_timestamped_quote_from_dex(
    input_mint: &str,
    output_mint: &str,
    amount: u64,
    slippage_bps: u32,
    dex_label: &str,
    rpc: &AsyncRpcClient,
) -> Result<TimestampedQuote> {
    // Get current slot before fetching quote
    let current_slot = rpc.get_slot().await. ok();
    
    let url = format!(
        "{}?inputMint={}&outputMint={}&amount={}&slippageBps={}&onlyDexes={}",
        JUPITER_ORDER_API_URL, input_mint, output_mint, amount, slippage_bps, dex_label
    );
    let client = build_authenticated_client()? ;
    
    tokio::time::sleep(Duration::from_millis(JUPITER_DELAY_BETWEEN_CALLS_MS)).await;
    
    let response = fetch_with_rate_limit_handling(&client, url). await?;
    
    if !response.status(). is_success() {
        return Err(anyhow! ("DEX quote error from {}", dex_label));
    }
    
    let quote: OrderResponse = response. json().await?;
    
    let timestamped = TimestampedQuote::new(quote, dex_label, current_slot);
    
    println! ("   [QUOTE] {} quote obtained (slot: {:?}, age: 0ms)", 
        dex_label, current_slot);
    
    Ok(timestamped)
}

/// Validate WebSocket price feed freshness before using for arbitrage
fn validate_ws_price_freshness(
    update: &EnhancedPriceUpdate,
    max_age_ms: u128,
) -> Result<(), String> {
    let age_ms = update. timestamp. elapsed().as_millis();
    
    if age_ms > max_age_ms {
        return Err(format!(
            "WebSocket price from {} is stale: {}ms old (max: {}ms)",
            update. dex, age_ms, max_age_ms
        ));
    }
    
    Ok(())
}

async fn get_quote_from_dex(
    input_mint: &str,
    output_mint: &str,
    amount: u64,
    slippage_bps: u32,
    dex_label: &str
) -> Result<OrderResponse> {
    let url = format!(
        "{}?inputMint={}&outputMint={}&amount={}&slippageBps={}&onlyDexes={}",
        JUPITER_ORDER_API_URL, input_mint, output_mint, amount, slippage_bps, dex_label
    );
    let client = build_authenticated_client()?;

    tokio::time::sleep(Duration::from_millis(JUPITER_DELAY_BETWEEN_CALLS_MS)).await;

    let response = fetch_with_rate_limit_handling(&client, url).await?;

    if !response.status().is_success() {
        return Err(anyhow!("DEX quote error"));
    }
    Ok(response.json().await?)
}

/// Enhanced quote function with dynamic slippage calculation
/// Uses pool liquidity and trade size to determine optimal slippage
async fn get_quote_from_dex_dynamic_slippage(
    input_mint: &str,
    output_mint: &str,
    amount: u64,
    trade_amount_usd: f64,
    liquidity_usd: Option<f64>,
    current_price: Option<f64>,
    dex_label: &str
) -> Result<OrderResponse> {
    // Calculate dynamic slippage based on market conditions
    let dynamic_slippage = calculate_dynamic_slippage(
        liquidity_usd,
        trade_amount_usd,
        None, // We don't have price impact yet
        current_price,
    ).await;
    
    println!("   [{}] Using dynamic slippage: {} bps ({:.2}%)", 
        dex_label, dynamic_slippage, dynamic_slippage as f64 / 100.0);
    
    // Get quote with calculated slippage
    let url = format!(
        "{}?inputMint={}&outputMint={}&amount={}&slippageBps={}&onlyDexes={}",
        JUPITER_ORDER_API_URL, input_mint, output_mint, amount, dynamic_slippage, dex_label
    );
    let client = build_authenticated_client()?;

    tokio::time::sleep(Duration::from_millis(JUPITER_DELAY_BETWEEN_CALLS_MS)).await;

    let response = fetch_with_rate_limit_handling(&client, url).await?;

    if !response.status().is_success() {
        return Err(anyhow!("DEX quote error"));
    }
    
    let quote: OrderResponse = response.json().await?;
    
    // If price impact is high, we might need to re-fetch with higher slippage
    let price_impact: f64 = quote.price_impact_pct.parse().unwrap_or(0.0);
    
    if price_impact.abs() > 1.0 && dynamic_slippage < 150 {
        // Price impact is high, recalculate with this information
        let adjusted_slippage = calculate_dynamic_slippage(
            liquidity_usd,
            trade_amount_usd,
            Some(price_impact),
            current_price,
        ).await;
        
        if adjusted_slippage > dynamic_slippage + 20 {
            println!("   [{}] High price impact ({:.2}%), adjusting slippage to {} bps", 
                dex_label, price_impact, adjusted_slippage);
            
            // Re-fetch with adjusted slippage
            let retry_url = format!(
                "{}?inputMint={}&outputMint={}&amount={}&slippageBps={}&onlyDexes={}",
                JUPITER_ORDER_API_URL, input_mint, output_mint, amount, adjusted_slippage, dex_label
            );
            
            tokio::time::sleep(Duration::from_millis(100)).await;
            
            let retry_response = fetch_with_rate_limit_handling(&client, retry_url).await?;
            if retry_response.status().is_success() {
                return Ok(retry_response.json().await?);
            }
        }
    }
    
    Ok(quote)
}

async fn get_swap_transaction(
    user_pubkey: &Pubkey,
    input_mint: &str,
    output_mint: &str,
    amount: u64,
    slippage_bps: u32,
    _priority_fee: u64,
    _dex: &str,
) -> Result<solana_sdk::transaction::VersionedTransaction> {
    let url = format!("{}order", JUPITER_ULTRA_API);
    let order_request = UltraV1OrderRequest {
        input_mint: input_mint.to_string(),
        output_mint: output_mint.to_string(),
        amount,
        taker: user_pubkey.to_string(),
        slippage_bps: Some(slippage_bps as u16),
        auto_slippage: Some(false),
        auto_slippage_collision_u_turn: None,
    };

    let client = build_authenticated_client()?;
    let response = client.get(&url)
        .query(&order_request)
        .send()
        .await?;

    if !response.status().is_success() {
        let status = response.status();
        let error_text = response.text().await.unwrap_or_else(|_| "Unknown error".to_string());
        return Err(anyhow!("Jupiter Ultra API Error ({}): {}", status, error_text));
    }

    let order_response: UltraV1OrderResponse = response.json().await?;

    if let Some(error_code) = &order_response.error_code {
        let error_msg = order_response.error_message.as_deref().unwrap_or("Unknown error");
        return Err(anyhow!("Jupiter Ultra Error [{}]: {}", error_code, error_msg));
    }

    let tx_bytes = general_purpose::STANDARD.decode(&order_response.transaction)?;
    let tx: solana_sdk::transaction::VersionedTransaction = bincode::deserialize(&tx_bytes)?;

    Ok(tx)
}

/// Enhanced swap transaction builder with dynamic slippage
/// Automatically calculates optimal slippage based on market conditions
async fn get_swap_transaction_dynamic_slippage(
    user_pubkey: &Pubkey,
    input_mint: &str,
    output_mint: &str,
    amount: u64,
    trade_amount_usd: f64,
    liquidity_usd: Option<f64>,
    current_price: Option<f64>,
    _priority_fee: u64,
    dex: &str,
) -> Result<solana_sdk::transaction::VersionedTransaction> {
    // Calculate dynamic slippage
    let dynamic_slippage = calculate_dynamic_slippage(
        liquidity_usd,
        trade_amount_usd,
        None,
        current_price,
    ).await;
    
    println!("   [{}] Swap transaction using dynamic slippage: {} bps", dex, dynamic_slippage);

    let url = format!("{}/v1/order", JUPITER_ULTRA_API);

    let order_request = UltraV1OrderRequest {
        input_mint: input_mint.to_string(),
        output_mint: output_mint.to_string(),
        amount,
        taker: user_pubkey.to_string(),
        slippage_bps: Some(dynamic_slippage as u16),
        auto_slippage: Some(false),
        auto_slippage_collision_u_turn: None,
    };

    let client = build_authenticated_client()?;
    let response = client.get(&url)
        .query(&order_request)
        .send()
        .await?;

    if !response.status().is_success() {
        let status = response.status();
        let error_text = response.text().await.unwrap_or_else(|_| "Unknown error".to_string());
        return Err(anyhow!("Jupiter Ultra API Error ({}): {}", status, error_text));
    }

    let order_response: UltraV1OrderResponse = response.json().await?;

    if let Some(error_code) = &order_response.error_code {
        let error_msg = order_response.error_message.as_deref().unwrap_or("Unknown error");
        return Err(anyhow!("Jupiter Ultra Error [{}]: {}", error_code, error_msg));
    }

    let tx_bytes = general_purpose::STANDARD.decode(&order_response.transaction)?;
    let tx: solana_sdk::transaction::VersionedTransaction = bincode::deserialize(&tx_bytes)?;

    Ok(tx)
}

// ============================================================================
// --- JITO TIP ACCOUNT MANAGEMENT (DYNAMIC) ---
// ============================================================================

/// Fetch tip accounts dynamically from Jito's API
/// Returns cached accounts if still valid, otherwise fetches fresh ones
async fn get_jito_tip_accounts() -> Vec<String> {
    // Check if we have a valid cached copy
    {
        let cache = JITO_TIP_ACCOUNTS_CACHE.read().await;
        let last_fetch = JITO_TIP_ACCOUNTS_LAST_FETCH.read().await;
        
        if let (Some(accounts), Some(fetch_time)) = (cache.as_ref(), last_fetch.as_ref()) {
            if fetch_time.elapsed().as_secs() < JITO_TIP_ACCOUNTS_CACHE_TTL_SECS && !accounts.is_empty() {
                return accounts.clone();
            }
        }
    }
    
    // Fetch fresh tip accounts from Jito API
    match fetch_jito_tip_accounts_from_api().await {
        Ok(accounts) if !accounts.is_empty() => {
            // Update cache
            {
                let mut cache = JITO_TIP_ACCOUNTS_CACHE.write().await;
                let mut last_fetch = JITO_TIP_ACCOUNTS_LAST_FETCH.write().await;
                *cache = Some(accounts.clone());
                *last_fetch = Some(std::time::Instant::now());
            }
            println!("   [Jito] Fetched {} tip accounts from API", accounts.len());
            accounts
        }
        Ok(_) => {
            println!("   [Jito] API returned empty tip accounts, using fallback");
            JITO_TIP_ACCOUNTS_FALLBACK.iter().map(|s| s.to_string()).collect()
        }
        Err(e) => {
            println!("   [Jito] Failed to fetch tip accounts: {}, using fallback", e);
            JITO_TIP_ACCOUNTS_FALLBACK.iter().map(|s| s.to_string()).collect()
        }
    }
}

/// Fetch tip accounts directly from Jito's API endpoint
async fn fetch_jito_tip_accounts_from_api() -> Result<Vec<String>> {
    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(10))
        .build()?;
    
    let response = client.get(JITO_TIP_ACCOUNTS_API)
        .send()
        .await
        .context("Failed to connect to Jito tip accounts API")?;
    
    if !response.status().is_success() {
        return Err(anyhow!("Jito tip accounts API returned status: {}", response.status()));
    }
    
    // Jito API returns an array of tip account addresses
    let accounts: Vec<String> = response.json().await
        .context("Failed to parse Jito tip accounts response")?;
    
    // Validate that we got valid Pubkey strings
    let valid_accounts: Vec<String> = accounts.into_iter()
        .filter(|addr| Pubkey::from_str(addr).is_ok())
        .collect();
    
    if valid_accounts.is_empty() {
        return Err(anyhow!("No valid tip accounts returned from Jito API"));
    }
    
    Ok(valid_accounts)
}

/// Get a random tip account from the available pool
async fn get_random_jito_tip_account() -> Result<Pubkey> {
    let accounts = get_jito_tip_accounts().await;
    
    if accounts.is_empty() {
        return Err(anyhow!("No Jito tip accounts available"));
    }
    
    // Use a simple random selection based on time
    let idx = (std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap_or_default()
        .as_nanos() as usize) % accounts.len();
    
    Pubkey::from_str(&accounts[idx])
        .context("Invalid tip account address")
}

// ============================================================================
// --- JITO BUNDLE FUNCTIONS ---
// ============================================================================

async fn submit_jito_bundle(
    transactions: Vec<String>,
) -> Result<String> {
    let max_retries = 3;
    let mut last_error = None;

    for attempt in 0..max_retries {
        let idx = JITO_ENDPOINT_INDEX.fetch_add(1, std::sync::atomic::Ordering::Relaxed) % JITO_BUNDLE_URLS.len();
        let endpoint = JITO_BUNDLE_URLS[idx];

        if attempt > 0 {
            println!("   Retrying with different endpoint...");
            tokio::time::sleep(Duration::from_millis(500 * (attempt as u64 + 1))).await;
        }

        let bundle = JitoBundle {
            jsonrpc: "2.0".to_string(),
            id: 1,
            method: "sendBundle".to_string(),
            params: vec![transactions.clone()],
        };

        let client = reqwest::Client::builder()
            .timeout(Duration::from_secs(10))
            .build()?;

        let response = match client.post(endpoint).json(&bundle).send().await {
            Ok(r) => r,
            Err(e) => {
                last_error = Some(anyhow!("Request failed: {}", e));
                continue;
            }
        };

        let status = response.status();
        if status == reqwest::StatusCode::TOO_MANY_REQUESTS {
            last_error = Some(anyhow!("Rate limited, trying next endpoint"));
            continue;
        }

        let response_text = response.text().await?;

        match serde_json::from_str::<serde_json::Value>(&response_text) {
            Ok(jito_response) => {
                if let Some(result) = jito_response.get("result").and_then(|r| {
                    match r {
                        serde_json::Value::String(s) => Some(s.clone()),
                        serde_json::Value::Number(n) => Some(n.to_string()),
                        _ => None
                    }
                }) {
                    return Ok(result);
                } else if let Some(error) = jito_response.get("error") {
                    let error_msg = error.get("message").and_then(|m| m.as_str()).unwrap_or("Unknown error");
                    last_error = Some(anyhow!("Jito RPC Error: {}", error_msg));

                    if error_msg.contains("could not be decoded") || error_msg.contains("invalid") {
                        return Err(last_error.unwrap());
                    }
                    continue;
                } else {
                    last_error = Some(anyhow!("Unexpected Jito response format: {}", response_text));
                    continue;
                }
            }
            Err(e) => {
                if response_text.trim().len() < 100 {
                    return Ok(response_text.trim().to_string());
                }
                last_error = Some(anyhow!("Failed to parse Jito response: {} - Response: {}", e, response_text));
                continue;
            }
        }
    }

    Err(last_error.unwrap_or_else(|| anyhow!("All Jito endpoints failed")))
}

async fn check_jito_bundle_status(
    bundle_id: &str,
) -> Result<JitoBundleStatus> {
    let request_body = serde_json::json!({
        "jsonrpc": "2.0",
        "id": 1,
        "method": "getBundleStatuses",
        "params": [[bundle_id]]
    });
    let client = reqwest::Client::new();
    let response = client
        .post(JITO_BUNDLE_URLS[0])
        .json(&request_body)
        .send()
        .await?;
    if !response.status().is_success() {
        let error_text = response.text().await?;
        return Err(anyhow!("Jito status check failed: {}", error_text));
    }

    let status_response: JitoBundleStatusResponse = response.json().await?;
    if status_response.result.value.is_empty() {
        return Err(anyhow!("No bundle status returned"));
    }

    Ok(status_response.result.value[0].clone())
}

async fn wait_for_jito_confirmation(
    bundle_id: &str,
    timeout_seconds: u64,
) -> Result<Vec<String>> {
    let start_time = std::time::Instant::now();
    let timeout_duration = Duration::from_secs(timeout_seconds);
    let mut poll_count = 0;

    println!("   Polling Jito bundle status...");
    loop {
        poll_count += 1;
        if start_time.elapsed() > timeout_duration {
            return Err(anyhow!(
                "Bundle confirmation timeout after {} seconds ({} polls)",
                timeout_seconds, poll_count
            ));
        }

        match check_jito_bundle_status(bundle_id).await {
            Ok(status) => {
                if let Some(err) = status.err {
                    return Err(anyhow!("Bundle failed with error: {:?}", err));
                }

                if let Some(conf_status) = &status.confirmation_status {
                    match conf_status.as_str() {
                        "confirmed" | "finalized" => {
                            println!(
                                "   Bundle confirmed in slot {:?} (Status: {})",
                                status.slot, conf_status
                            );
                            return Ok(status.transactions);
                        }
                        "processed" => {
                            println!(
                                "   [Poll {}] Bundle processed, waiting for confirmation...",
                                poll_count
                            );
                        }
                        _ => {
                            println!(
                                "   [Poll {}] Bundle status: {} (waiting...)",
                                poll_count, conf_status
                            );
                        }
                    }
                } else if !status.transactions.is_empty() {
                    println!(
                        "   Bundle landed in slot {:?} ({} transactions)",
                        status.slot,
                        status.transactions.len()
                    );
                    return Ok(status.transactions);
                }

                tokio::time::sleep(Duration::from_millis(500)).await;
            }
            Err(e) => {
                if e.to_string().contains("not found")
                    || e.to_string().contains("No bundle status")
                {
                    println!("   [Poll {}] Bundle not found yet, retrying...", poll_count);
                    tokio::time::sleep(Duration::from_millis(800)).await;
                } else {
                    return Err(e);
                }
            }
        }
    }
}

fn calculate_confidence_score(
    spread_pct: f64,
    price_impact_sell: f64,
    price_impact_buy: f64,
    sell_dex: &str,
    buy_dex: &str,
    market_state: &MarketState,
    quote_age_ms: u128,
) -> f64 {
    let mut score = 100.0;

    let total_impact = price_impact_sell.abs() + price_impact_buy.abs();
    score -= (total_impact * 10.0).min(30.0);

    if quote_age_ms > 300 {
        score -= ((quote_age_ms as f64 - 300.0) / 100.0).min(20.0);
    }

    let dex_pair = format!("{}-{}", sell_dex, buy_dex);
    if let Some(avg_spread) = market_state.get_average_spread(&dex_pair) {
        let spread_deviation = (spread_pct - avg_spread).abs();
        if spread_deviation < 0.1 {
            score += 10.0;
        } else if spread_deviation > 0.5 {
            score -= 15.0;
        }
    }

    let sell_health = market_state.get_dex_health_score(sell_dex);
    let buy_health = market_state.get_dex_health_score(buy_dex);
    score += ((sell_health + buy_health) / 2.0 - 50.0) * 0.2;

    score.max(0.0).min(100.0)
}

// ============================================================================
// --- ARBITRAGE OPPORTUNITY DETECTION ---
// ============================================================================

fn check_opportunity_custom(
    sell_dex: String,
    buy_dex: String,
    sell_quote: OrderResponse,
    buy_quote: OrderResponse,
    trade_amount_base: f64,
    base_price_usd: f64,
    decimals: u32
) -> Option<ArbitrageOpportunity> {
    let base_out: u64 = buy_quote.out_amount.parse().unwrap_or(0);
    let base_out_f64 = base_out as f64 / 10u64.pow(decimals) as f64;
    let gross_profit_base = base_out_f64 - trade_amount_base;

    if gross_profit_base > 0.0 {
        let gross_profit_usd = gross_profit_base * base_price_usd;
        let estimated_tip_lamports = get_dynamic_priority_fee(base_price_usd, gross_profit_usd);
        let estimated_tip_sol = estimated_tip_lamports as f64 / LAMPORTS_PER_SOL as f64;
        let estimated_network_fee_sol = 0.000005 * 2.0;

        let total_fees_sol = estimated_tip_sol + estimated_network_fee_sol;
        let total_fees_usd = total_fees_sol * base_price_usd;
        let net_profit_usd = gross_profit_usd - total_fees_usd;

        if net_profit_usd >= DESIRED_NET_PROFIT_USD {
            let spread_pct = (gross_profit_base / trade_amount_base) * 100.0;
            return Some(ArbitrageOpportunity {
                sell_dex,
                buy_dex,
                sell_quote,
                buy_quote,
                gross_profit_sol: gross_profit_base,
                net_profit_usd,
                spread_pct,
                trade_amount_sol: trade_amount_base,
            });
        }
    }
    None
}

fn check_opportunity_enhanced(
    sell_dex: String,
    buy_dex: String,
    sell_quote: OrderResponse,
    buy_quote: OrderResponse,
    trade_amount_base: f64,
    base_price_usd: f64,
    decimals: u32,
    quote_age_ms: u128,
    market_state: &MarketState,
    min_profit_usd: f64,
) -> Option<EnhancedArbitrageOpportunity> {
    if quote_age_ms > PRICE_STALENESS_MS {
        return None;
    }

    let base_out: u64 = buy_quote.out_amount.parse().unwrap_or(0);
    let base_out_f64 = base_out as f64 / 10u64.pow(decimals) as f64;
    let gross_profit_base = base_out_f64 - trade_amount_base;

    if gross_profit_base <= 0.0 {
        return None;
    }

    let price_impact_sell: f64 = sell_quote.price_impact_pct.parse().unwrap_or(0.0);
    let price_impact_buy: f64 = buy_quote.price_impact_pct.parse().unwrap_or(0.0);

    if price_impact_sell.abs() + price_impact_buy.abs() > 2.0 {
        return None;
    }

    let gross_profit_usd = gross_profit_base * base_price_usd;
    let estimated_tip_lamports = get_dynamic_priority_fee(base_price_usd, gross_profit_usd);
    let estimated_tip_sol = estimated_tip_lamports as f64 / LAMPORTS_PER_SOL as f64;
    let estimated_network_fee_sol = 0.000005 * 2.0;

    let total_fees_sol = estimated_tip_sol + estimated_network_fee_sol;
    let total_fees_usd = total_fees_sol * base_price_usd;
    let net_profit_usd = gross_profit_usd - total_fees_usd;

    if net_profit_usd < min_profit_usd {
        return None;
    }

    let spread_pct = (gross_profit_base / trade_amount_base) * 100.0;

    let confidence_score = calculate_confidence_score(
        spread_pct,
        price_impact_sell,
        price_impact_buy,
        &sell_dex,
        &buy_dex,
        market_state,
        quote_age_ms,
    );

    if confidence_score < 60.0 {
        return None;
    }

    let estimated_execution_time_ms = 2000 + (quote_age_ms as u64 / 2);

    Some(EnhancedArbitrageOpportunity {
        sell_dex,
        buy_dex,
        sell_quote,
        buy_quote,
        gross_profit_sol: gross_profit_base,
        net_profit_usd,
        spread_pct,
        trade_amount_sol: trade_amount_base,
        price_impact_sell,
        price_impact_buy,
        estimated_execution_time_ms,
        confidence_score,
        quote_age_ms,
        sell_quote_timestamp_ms: std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap_or_default()
        .as_millis(),
    buy_quote_timestamp_ms: std::time::SystemTime::now()
        . duration_since(std::time::UNIX_EPOCH)
        .unwrap_or_default()
        .as_millis(),
    sell_quote_slot: None,  // Or pass actual slot if available
    buy_quote_slot: None,   // Or pass actual slot if available
    })
}


#[derive(Debug, Clone)]
struct TriangularOpportunity {
    route_description: String,
    hop_token: String,
    start_amount_sol: f64,
    end_amount_sol: f64,
    net_profit_usd: f64,
    profit_pct: f64,
}

/// Check for Triangular Arbitrage: SOL -> Hop Token -> USDC -> SOL
async fn check_triangular_arbitrage(
    sol_amount: f64,
    sol_price_usd: f64,
    hop_token_mint: &str,
    hop_token_symbol: &str,
) -> Option<TriangularOpportunity> {
    let sol_amount_lamports = (sol_amount * LAMPORTS_PER_SOL as f64) as u64;

    // Leg 1: SOL -> HOP (Find best DEX)
    let leg1_quote = match get_quote_from_dex(SOL_MINT, hop_token_mint, sol_amount_lamports, 50, "Jupiter").await {
        Ok(q) => q,
        Err(_) => return None,
    };
    let hop_amount_u64: u64 = leg1_quote.out_amount.parse().unwrap_or(0);

    if hop_amount_u64 == 0 { return None; }

    // Leg 2: HOP -> USDC
    let leg2_quote = match get_quote_from_dex(hop_token_mint, USDC_MINT, hop_amount_u64, 50, "Jupiter").await {
        Ok(q) => q,
        Err(_) => return None,
    };
    let usdc_amount_u64: u64 = leg2_quote.out_amount.parse().unwrap_or(0);

    // Leg 3: USDC -> SOL
    let leg3_quote = match get_quote_from_dex(USDC_MINT, SOL_MINT, usdc_amount_u64, 50, "Jupiter").await {
        Ok(q) => q,
        Err(_) => return None,
    };
    let final_sol_u64: u64 = leg3_quote.out_amount.parse().unwrap_or(0);
    let final_sol = final_sol_u64 as f64 / LAMPORTS_PER_SOL as f64;

    // Calculate Profit
    let gross_profit_sol = final_sol - sol_amount;
    
    // Filter for profitability
    if gross_profit_sol > 0.0 {
        let gross_profit_usd = gross_profit_sol * sol_price_usd;
        
        // Estimate fees (3 transactions = ~3x fees)
        let estimated_fees_usd = 0.000015 * sol_price_usd * 3.0; 
        let net_profit = gross_profit_usd - estimated_fees_usd;

        if net_profit > 0.05 { // Min profit threshold
             let profit_pct = (gross_profit_sol / sol_amount) * 100.0;
             
             return Some(TriangularOpportunity {
                 route_description: format!("SOL -> {} -> USDC -> SOL", hop_token_symbol),
                 hop_token: hop_token_symbol.to_string(),
                 start_amount_sol: sol_amount,
                 end_amount_sol: final_sol,
                 net_profit_usd: net_profit,
                 profit_pct,
             });
        }
    }

    None
}

async fn find_arbitrage_opportunities_custom(
    base_token_mint: &str,
    base_token_info: &TokenInfo,
    quote_token_mint: &str,
    _quote_token_symbol: &str,
    base_price_usd: f64,
    trade_amount_base: f64,
) -> Vec<ArbitrageOpportunity> {
    let mut opportunities = Vec::new();
    let trade_amount_raw = (trade_amount_base * 10u64.pow(base_token_info.decimals) as f64) as u64;

    let mut dex_pairs = Vec::new();
    for i in 0..ACTIVE_DEXS.len() {
        for j in (i + 1)..ACTIVE_DEXS.len() {
            dex_pairs.push((ACTIVE_DEXS[i], ACTIVE_DEXS[j]));
        }
    }

    let total_routes = dex_pairs.len() * 2;
    println!("   Scanning {} DEX pairs ({} total routes)", dex_pairs.len(), total_routes);

    let mut completed = 0;
    let mut found_count = 0;

    for (batch_num, chunk) in dex_pairs.chunks(BATCH_SIZE).enumerate() {
        if batch_num > 0 {
            tokio::time::sleep(Duration::from_millis(DELAY_BETWEEN_BATCHES_MS)).await;
        }

        for (dex_a, dex_b) in chunk {
            match get_quote_from_dex(base_token_mint, quote_token_mint, trade_amount_raw, 50, dex_a).await {
                Ok(sell_quote) => {
                    let quote_out: u64 = sell_quote.out_amount.parse().unwrap_or(0);
                    if quote_out > 0 {
                        match get_quote_from_dex(quote_token_mint, base_token_mint, quote_out, 50, dex_b).await {
                            Ok(buy_quote) => {
                                if let Some(opp) = check_opportunity_custom(
                                    dex_a.to_string(),
                                    dex_b.to_string(),
                                    sell_quote,
                                    buy_quote,
                                    trade_amount_base,
                                    base_price_usd,
                                    base_token_info.decimals
                                ) {
                                    found_count += 1;
                                    opportunities.push(opp);
                                }
                            }
                            Err(_) => {}
                        }
                    }
                }
                Err(_) => {}
            }
            completed += 1;
            print!("\r  Progress: {}/{} routes checked, {} opportunities found", completed, total_routes, found_count);
            io::stdout().flush().ok();

            match get_quote_from_dex(base_token_mint, quote_token_mint, trade_amount_raw, 50, dex_b).await {
                Ok(sell_quote) => {
                    let quote_out: u64 = sell_quote.out_amount.parse().unwrap_or(0);
                    if quote_out > 0 {
                        match get_quote_from_dex(quote_token_mint, base_token_mint, quote_out, 50, dex_a).await {
                            Ok(buy_quote) => {
                                if let Some(opp) = check_opportunity_custom(
                                    dex_b.to_string(),
                                    dex_a.to_string(),
                                    sell_quote,
                                    buy_quote,
                                    trade_amount_base,
                                    base_price_usd,
                                    base_token_info.decimals
                                ) {
                                    found_count += 1;
                                    opportunities.push(opp);
                                }
                            }
                            Err(_) => {}
                        }
                    }
                }
                Err(_) => {}
            }
            completed += 1;
            print!("\r  Progress: {}/{} routes checked, {} opportunities found", completed, total_routes, found_count);
            io::stdout().flush().ok();
        }
    }

    println!();
    opportunities.sort_by(|a, b| b.net_profit_usd.partial_cmp(&a.net_profit_usd).unwrap());
    opportunities
}

// ============================================================================
// --- WEBSOCKET-ACCELERATED ARBITRAGE SCANNER (OPTION 4) ---
// ============================================================================

async fn find_arbitrage_opportunities_websocket(
    base_token_mint: &str,
    base_token_info: &TokenInfo,
    quote_token_mint: &str,
    _quote_token_symbol: &str,
    base_price_usd: f64,
    trade_amount_base: f64,
    market_state: &mut MarketState,
    price_cache: &EnhancedPriceCache,
    min_profit_usd: f64,
) -> Vec<EnhancedArbitrageOpportunity> {
    println!(" WebSocket-Accelerated Arbitrage Scan");
    println!("   Using cached prices to pre-filter opportunities.. .\n");

    // ===== SUPPORTED DEX PARSERS (DLMM-only for Meteora) =====
    let working_dexs = vec!["Orca", "Orca V2", "Raydium", "Raydium CLMM", "Meteora DLMM"];
    
    println!("   Active DEXs: {}", working_dexs.join(", "));

    // Stage 1: Quick spread analysis from cache
    // Cache keys are now: "{DEX}-{pool_prefix}" e.g., "Orca-Czfq3xZZ"
    let cache_snapshot = price_cache.read().await.clone();
    let mut promising_pairs = Vec::new();
    
    // Collect all valid cached prices
    let cached_prices: Vec<(&String, &EnhancedPriceUpdate)> = cache_snapshot    
    .iter()
        .filter(|(_, update)| update.timestamp.elapsed().as_millis() < PRICE_STALENESS_MS)
        .collect();
    
    println!("   Cache contains {} fresh prices", cached_prices.len());
    
    // Compare all pairs of cached prices to find spreads
    for i in 0..cached_prices.len() {
        for j in (i+1)..cached_prices.len() {
            let (key_a, price_a) = cached_prices[i];
            let (key_b, price_b) = cached_prices[j];
            
            // Extract DEX name from cache key (format: "DEX-poolPrefix")
            let dex_a = key_a.split('-').next().unwrap_or("Unknown");
            let dex_b = key_b.split('-').next().unwrap_or("Unknown");
            
            // Skip if same DEX (no arbitrage within same DEX)
            if dex_a == dex_b {
                continue;
            }
            
            let spread = ((price_a.price - price_b.price).abs() / price_b.price.min(price_a.price)) * 100.0;
            
            if spread > SPREAD_ALERT_THRESHOLD {
                // Determine which is higher/lower for proper sell/buy direction
                let (sell_dex, buy_dex, sell_price, buy_price) = if price_a.price > price_b.price {
                    (dex_a.to_string(), dex_b.to_string(), price_a.price, price_b.price)
                } else {
                    (dex_b.to_string(), dex_a.to_string(), price_b.price, price_a.price)
                };
                
                println!("     Potential: {} (${:.2})  {} (${:.2}) = {:.3}% spread", 
                    sell_dex, sell_price, buy_dex, buy_price, spread);
                promising_pairs.push((sell_dex, buy_dex, spread));
            }
        }
    }
    
    // Deduplicate pairs (same DEX pair might appear multiple times from different pools)
    promising_pairs.sort_by(|a, b| b.2.partial_cmp(&a.2).unwrap());
    promising_pairs.dedup_by(|a, b| a.0 == b.0 && a.1 == b.1);

    println!("   Found {} promising pairs from WebSocket cache", promising_pairs.len());
    println!("   Requesting detailed quotes.. .\n");

    // Stage 2: Get detailed quotes only for promising pairs
    let mut opportunities = Vec::new();
    let trade_amount_raw = (trade_amount_base * 10u64.pow(base_token_info.decimals) as f64) as u64;

    for (dex_a, dex_b, _cached_spread) in promising_pairs {
        // Direction 1: Sell on A, buy on B
        if let Ok(sell_quote) = get_quote_from_dex(base_token_mint, quote_token_mint, trade_amount_raw, 50, &dex_a). await {
            let quote_out: u64 = sell_quote.out_amount.parse().unwrap_or(0);
            if quote_out > 0 {
                if let Ok(buy_quote) = get_quote_from_dex(quote_token_mint, base_token_mint, quote_out, 50, &dex_b).await {
                    if let Some(opp) = check_opportunity_enhanced(
                        dex_a. clone(),
                        dex_b.clone(),
                        sell_quote,
                        buy_quote,
                        trade_amount_base,
                        base_price_usd,
                        base_token_info.decimals,
                        0,
                        market_state,
                        min_profit_usd,
                    ) {
                        opportunities.push(opp);
                    }
                }
            }
        }

        // Direction 2: Sell on B, buy on A
        if let Ok(sell_quote) = get_quote_from_dex(base_token_mint, quote_token_mint, trade_amount_raw, 50, &dex_b).await {
            let quote_out: u64 = sell_quote.out_amount.parse().unwrap_or(0);
            if quote_out > 0 {
                if let Ok(buy_quote) = get_quote_from_dex(quote_token_mint, base_token_mint, quote_out, 50, &dex_a).await {
                    if let Some(opp) = check_opportunity_enhanced(
                        dex_b.clone(),
                        dex_a.clone(),
                        sell_quote,
                        buy_quote,
                        trade_amount_base,
                        base_price_usd,
                        base_token_info.decimals,
                        0,
                        market_state,
                        min_profit_usd,
                    ) {
                        opportunities.push(opp);
                    }
                }
            }
        }
    }

    opportunities. sort_by(|a, b| {
        match b.confidence_score. partial_cmp(&a.confidence_score) {
            Some(std::cmp::Ordering::Equal) => b.net_profit_usd.partial_cmp(&a.net_profit_usd).unwrap(),
            other => other. unwrap(),
        }
    });

    for opp in &opportunities {
        let dex_pair = format!("{}-{}", opp.sell_dex, opp.buy_dex);
        market_state.record_spread(dex_pair, opp.spread_pct);
    }

    println!(" Scan complete: {} qualified opportunities\n", opportunities.len());
    opportunities
}

// ============================================================================
// --- ARBITRAGE EXECUTION ---
// ============================================================================

/// Simulation result validation structure
#[derive(Debug)]
struct SimulationValidation {
    success: bool,
    units_consumed: Option<u64>,
    logs: Vec<String>,
    error: Option<String>,
    return_data: Option<String>,
}

/// Validate simulation results thoroughly before submitting transactions
fn validate_simulation_result(
    result: &solana_client::rpc_response::RpcSimulateTransactionResult,
    tx_name: &str,
) -> Result<SimulationValidation> {
    let mut validation = SimulationValidation {
        success: result.err.is_none(),
        units_consumed: result.units_consumed,
        logs: result.logs.clone().unwrap_or_default(),
        error: None,
        return_data: result.return_data.as_ref().map(|rd| format!("{:?}", rd)),
    };
    
    // Check for explicit errors
    if let Some(ref err) = result.err {
        validation.success = false;
        validation.error = Some(format!("{:?}", err));
        return Err(anyhow!(
            "{} simulation failed with error: {:?}\nLogs: {:?}",
            tx_name, err, validation.logs
        ));
    }
    
    // Check logs for common failure patterns
    for log in &validation.logs {
        let log_lower = log.to_lowercase();
        
        // Check for insufficient funds
        if log_lower.contains("insufficient") || log_lower.contains("not enough") {
            validation.success = false;
            validation.error = Some("Insufficient funds detected in simulation".to_string());
            return Err(anyhow!("{} simulation: Insufficient funds - {}", tx_name, log));
        }
        
        // Check for slippage errors
        if log_lower.contains("slippage") || log_lower.contains("exceeds desired") {
            validation.success = false;
            validation.error = Some("Slippage tolerance exceeded".to_string());
            return Err(anyhow!("{} simulation: Slippage exceeded - {}", tx_name, log));
        }
        
        // Check for invalid account states
        if log_lower.contains("invalid") && log_lower.contains("account") {
            validation.success = false;
            validation.error = Some("Invalid account state".to_string());
            return Err(anyhow!("{} simulation: Invalid account - {}", tx_name, log));
        }
        
        // Check for program errors
        if log_lower.contains("program failed") || log_lower.contains("error:") {
            // Some error logs are informational, only fail on critical ones
            if log_lower.contains("custom program error") {
                validation.success = false;
                validation.error = Some(format!("Program error: {}", log));
                return Err(anyhow!("{} simulation: Program error - {}", tx_name, log));
            }
        }
    }
    
    // Validate compute units are reasonable
    if let Some(units) = validation.units_consumed {
        if units > 1_200_000 {
            println!("   [WARN] {} uses {} compute units (high)", tx_name, units);
        }
        if units == 0 {
            validation.success = false;
            validation.error = Some("Zero compute units consumed (likely failed silently)".to_string());
            return Err(anyhow!("{} simulation: Zero compute units - transaction likely invalid", tx_name));
        }
    }
    
    Ok(validation)
}

/// Enhanced transaction simulation with detailed validation
fn simulate_transaction_with_validation(
    client: &RpcClient,
    transaction: &solana_sdk::transaction::VersionedTransaction,
    tx_name: &str,
) -> Result<SimulationValidation> {
    let config = solana_client::rpc_config::RpcSimulateTransactionConfig {
        sig_verify: false,
        replace_recent_blockhash: true,
        commitment: Some(CommitmentConfig::confirmed()),
        encoding: None,
        accounts: None,
        min_context_slot: None,
        inner_instructions: true,
    };
    
    match client.simulate_transaction_with_config(transaction, config) {
        Ok(response) => {
            validate_simulation_result(&response.value, tx_name)
        }
        Err(e) => {
            Err(anyhow!("{} simulation RPC error: {}", tx_name, e))
        }
    }
}

async fn execute_arbitrage_with_jito(
    keypair: &Keypair,
    opportunity: &ArbitrageOpportunity,
    solana_client: &SolanaClient,
    sol_price_usd: f64,
) -> Result<(String, String)> {
    let pubkey = keypair.pubkey();
    println!("   Preparing Jito bundle for atomic execution...");
        // === PRE-EXECUTION BALANCE VERIFICATION ===
    println!("   [BALANCE] Verifying wallet balances before execution...");
    
    let balance_verifier = BalanceVerifier::default();
    let async_rpc = AsyncRpcClient::new_with_commitment(
        QUICKNODE_RPC_URL. to_string(),
        CommitmentConfig::confirmed(),
    );
    
    // Parse the sell amount from the opportunity
    let sell_amount_lamports: u64 = opportunity.sell_quote.in_amount
        .parse()
        .context("Failed to parse sell amount")?;
    
    // Verify SOL balance (for gas + trade if selling SOL)
    let sol_check = balance_verifier
        .verify_sol_balance(&async_rpc, &pubkey, sell_amount_lamports)
        .await? ;
    
    sol_check.display();
    
    if ! sol_check.is_sufficient {
        return Err(anyhow!(
            "ABORT: Insufficient SOL balance. Available: {} lamports, Required: {} lamports, Deficit: {} lamports",
            sol_check.available_balance,
            sol_check.required_balance,
            sol_check.deficit.unwrap_or(0)
        ));
    }
    
    println!("   [OK] Balance verification passed");
    // === PRE-EXECUTION QUOTE FRESHNESS CHECK ===
    println!("   [FRESH] Validating quote freshness before execution...");
    
    let freshness_validator = QuoteFreshnessValidator::default();
    let async_rpc = AsyncRpcClient::new_with_commitment(
        QUICKNODE_RPC_URL.to_string(),
        CommitmentConfig::confirmed(),
    );
    
    // Get current slot for validation
    let current_slot = async_rpc.get_slot().await.ok();
    
    // Check if opportunity quotes are still fresh
    // Note: You'll need to track quote timestamps when creating ArbitrageOpportunity
    let quote_age_sell = std::time::Instant::now(); // Replace with actual timestamp from opportunity
    let quote_age_buy = std::time::Instant::now();  // Replace with actual timestamp from opportunity
    
    // For now, use the quote_age_ms from EnhancedArbitrageOpportunity if available
    if opportunity.sell_quote.in_amount. parse::<u64>().is_err() {
        return Err(anyhow!("Invalid sell quote - cannot parse in_amount"));
    }
    
    // If quotes are older than MAX_QUOTE_AGE_MS, abort and re-fetch
    // This is a critical safety check to prevent executing on stale prices
    println!("   [FRESH] Quotes validated, proceeding with execution");

    let dynamic_tip_lamports = get_dynamic_priority_fee(sol_price_usd, opportunity.net_profit_usd);
    let compute_unit_price_microlamports = BASE_PRIORITY_FEE_MICRO_LAMPORTS;
    println!(
        "   Dynamic Tip: {:.6} SOL (${:.3})",
        dynamic_tip_lamports as f64 / LAMPORTS_PER_SOL as f64,
        (dynamic_tip_lamports as f64 / LAMPORTS_PER_SOL as f64) * sol_price_usd
    );

    let sell_amount: u64 = opportunity.sell_quote.in_amount.parse()?;
    let buy_amount: u64 = opportunity.buy_quote.in_amount.parse()?;

    println!("   Getting sell transaction from {}...", opportunity.sell_dex);
    let mut tx1 = get_swap_transaction(
        &pubkey,
        &opportunity.sell_quote.input_mint,
        &opportunity.sell_quote.output_mint,
        sell_amount,
        opportunity.sell_quote.slippage_bps,
        compute_unit_price_microlamports,
        &opportunity.sell_dex,
    ).await?;

    println!("   Getting buy transaction from {}...", opportunity.buy_dex);
    let mut tx2 = get_swap_transaction(
        &pubkey,
        &opportunity.buy_quote.input_mint,
        &opportunity.buy_quote.output_mint,
        buy_amount,
        opportunity.buy_quote.slippage_bps,
        compute_unit_price_microlamports,
        &opportunity.buy_dex,
    ).await?;

    let tx1_header = tx1.message.header();
    let tx2_header = tx2.message.header();

    let tx1_writable_signers = tx1_header.num_required_signatures - tx1_header.num_readonly_signed_accounts;
    let tx2_writable_signers = tx2_header.num_required_signatures - tx2_header.num_readonly_signed_accounts;

    if tx1_writable_signers > 1 || tx2_writable_signers > 1 {
        let msg = format!(
            "Skipping multi-signer route: Tx1 needs {} signers, Tx2 needs {} signers. DEX pair: {} -> {}",
            tx1_writable_signers, tx2_writable_signers, opportunity.sell_dex, opportunity.buy_dex
        );
        println!("   [!] {}", msg);
        log_to_file(&msg);
        return Err(anyhow!("Multi-signer transaction not supported for atomic execution"));
    }

    // =========================================================================
    // FIX 3: Enhanced simulation validation
    // =========================================================================
    println!("   Simulating transactions with enhanced validation...");
    
    // Simulate sell transaction
    println!("   [SIM] Validating sell transaction ({})...", opportunity.sell_dex);
    let sim1 = simulate_transaction_with_validation(&solana_client.client, &tx1, "Sell TX")?;
    println!("   [SIM] Sell TX:  (units: {:?})", sim1.units_consumed);
    
    // Simulate buy transaction
    println!("   [SIM] Validating buy transaction ({})...", opportunity.buy_dex);
    let sim2 = simulate_transaction_with_validation(&solana_client.client, &tx2, "Buy TX")?;
    println!("   [SIM] Buy TX:  (units: {:?})", sim2.units_consumed);
    
    // Ensure both simulations passed
    if !sim1.success || !sim2.success {
        return Err(anyhow!(
            "Simulation validation failed: Sell={}, Buy={}",
            sim1.success, sim2.success
        ));
    }
    println!("    Both transactions validated successfully");
        // === FINAL BALANCE CHECK (Last-second verification) ===
    println!("   [FINAL] Last-second balance verification...");
    
    let final_sol_balance = async_rpc.get_balance(&pubkey).await
        .context("Failed to fetch final SOL balance")? ;
    
    // Calculate total required: trade amount + Jito tip + buffer for fees
    let total_required = sell_amount_lamports + dynamic_tip_lamports + 10_000_000; // +0.01 SOL buffer
    
    if final_sol_balance < total_required {
        return Err(anyhow!(
            "ABORT: Final balance check failed!  Balance: {} lamports, Required: {} lamports.  \
             Balance may have changed since initial check.",
            final_sol_balance, 
            total_required
        ));
    }
    
    println!("   [OK] Final balance: {} lamports (need {})", final_sol_balance, total_required);
    
    // Continue with existing code...
    println!("   Signing transactions...");
    tx1.signatures[0] = keypair.sign_message(tx1.message.serialize().as_slice());
    tx2.signatures[0] = keypair.sign_message(tx2.message.serialize().as_slice());

    // =========================================================================
    // FIX 1: Get tip account dynamically from Jito API
    // =========================================================================
    println!("   Fetching Jito tip account...");
    let tip_account = get_random_jito_tip_account().await?;
    println!("   Using tip account: {}...", &tip_account.to_string()[..16]);
    
    let tip_ix = system_instruction::transfer(&pubkey, &tip_account, dynamic_tip_lamports);

    let recent_blockhash = solana_client.client.get_latest_blockhash()?;
    let tip_tx = solana_sdk::transaction::Transaction::new_signed_with_payer(
        &[tip_ix],
        Some(&pubkey),
        &[keypair],
        recent_blockhash,
    );

    let tx1_serialized = bincode::serialize(&tx1)?;
    let tx2_serialized = bincode::serialize(&tx2)?;
    let tip_serialized = bincode::serialize(&tip_tx)?;

    let tx1_b64 = general_purpose::STANDARD.encode(&tx1_serialized);
    let tx2_b64 = general_purpose::STANDARD.encode(&tx2_serialized);
    let tip_b64 = general_purpose::STANDARD.encode(&tip_serialized);

    // =========================================================================
    // FIX 1 (continued): Ensure tip transaction is LAST in the bundle
    // This is critical for Jito to process the bundle correctly.
    // Bundle order: [swap1, swap2, tip] - tip MUST be last
    // =========================================================================
    println!("   Submitting bundle to Jito (tip as last transaction)...");
    let bundle_transactions = vec![tx1_b64, tx2_b64, tip_b64]; // tip_b64 is LAST
    let bundle_id = submit_jito_bundle(bundle_transactions).await?;
    println!("   Bundle submitted. ID: {}", bundle_id);

    match wait_for_jito_confirmation(&bundle_id, JITO_CONFIRM_TIMEOUT_SECONDS).await {
        Ok(signatures) => {
            if signatures.len() >= 2 {
                println!("    Bundle confirmed on-chain!");
                log_to_file(&format!("Bundle confirmed: ID={}, Tx1={}, Tx2={}", bundle_id, signatures[0], signatures[1]));
                println!("     Tx1: {}", signatures[0]);
                println!("     Tx2: {}", signatures[1]);
                Ok((signatures[0].clone(), signatures[1].clone()))
            } else {
                Err(anyhow!("Bundle confirmed but missing signatures: {:?}", signatures))
            }
        }
        Err(e) => {
            eprintln!("   Bundle confirmation failed: {}", e);
            Err(e)
        }
    }
}

fn display_enhanced_opportunity(
    opp: &EnhancedArbitrageOpportunity,
    base_token_symbol: &str,
    base_price_usd: f64,
    scan_count: u32
) {
    println!("\n");
    println!("           ARBITRAGE OPPORTUNITY DETECTED!                   ");
    println!("                       Scan #{}                                ", scan_count);
    println!("");
    println!("   PROFIT ESTIMATE (USDC)                                    ");
    println!("        ");
    println!("       Net Profit:    ${:<8.3} USDC                        ", opp.net_profit_usd);
    println!("       Gross Spread:  {:<8.3}%                             ", opp.spread_pct);
    println!("        ");
    println!("");
    println!("   Trade Details                                             ");
    println!("     Trade Amount:   {:.4} {} (${:.2} USDC)",
        opp.trade_amount_sol, base_token_symbol,
        opp.trade_amount_sol * base_price_usd);
    println!("     Gross Profit:   {:.6} {} (${:.3} USDC)",
        opp.gross_profit_sol, base_token_symbol,
        opp.gross_profit_sol * base_price_usd);
    println!("");
    println!("   Execution Metrics                                         ");
    println!("     Confidence:     {:.1}/100", opp.confidence_score);
    println!("     Quote Age:      {}ms", opp.quote_age_ms);
    println!("     Est. Exec Time: {}ms", opp.estimated_execution_time_ms);
    println!("     Price Impact:   Sell {:.3}% | Buy {:.3}%",
        opp.price_impact_sell, opp.price_impact_buy);
    println!("");
    println!("   Route                                                     ");
    println!("      SELL {} on {}", base_token_symbol, opp.sell_dex);
    println!("      BUY  {} on {}", base_token_symbol, opp.buy_dex);
    println!("\n");
}

// ============================================================================
// --- WEBSOCKET-ENHANCED OPTION 3 HANDLER (REAL-TIME PRICE TICKER) ---
// ============================================================================


async fn compare_all_dex_prices_handler_websocket(price_cache: EnhancedPriceCache) -> Result<()> {
    println!("\n");
    println!("       DEX PRICE COMPARISON (WebSocket)            ");
    println!("");

    // Token selection (existing code)
    println!("\n Token Selection:");
    println!("1. SOL/USDC (default - real-time WebSocket)");
    println!("2. Custom token (provide mint address)");
    print!("\nChoice (1-2, or press Enter for SOL): ");
    io::stdout().flush()?;

    let mut token_choice = String::new();
    io::stdin().read_line(&mut token_choice)?;

     let (base_token_mint, base_token_info, quote_token_mint, quote_token_symbol) = 
    match token_choice.trim() {
        "2" => {
            println!("\n[CONFIG] Custom Token Pair Configuration");
            
            // Get Token 1 (base)
            print!("Enter Token 1 (base) mint address: ");
            io::stdout().flush()?;
            let mut token1 = String::new();
            io::stdin().read_line(&mut token1)?;
            let token1 = token1. trim().to_string();

            // Search for token info using Jupiter + fallback
            let token1_info = match search_token_with_fallback(&token1).await {
                Ok(info) => info,
                Err(e) => {
                    println!("\n[X] Failed to fetch token 1 information: {}", e);
                    println!("[SCAN] Manual Entry Mode");
                    
                    print!("Enter token symbol (e.g., MET): ");
                    io::stdout().flush()?;
                    let mut symbol = String::new();
                    io::stdin().read_line(&mut symbol)?;
                    let symbol = symbol.trim().to_string();
                    
                    print!("Enter token decimals (default 6): ");
                    io::stdout().flush()?;
                    let mut dec_str = String::new();
                    io::stdin().read_line(&mut dec_str)?;
                    let decimals: u32 = dec_str.trim().parse().unwrap_or(6);
                    TokenInfo {
    id: token1.clone(),
    name: format!("{} Token", symbol),
    symbol: symbol.clone(),
    decimals,
    logo_uri: None,
    tags: None,
    is_verified: None,
    usd_price: None,
    liquidity: None,
    holder_count: None,
}    
                }
            };

            // Get Token 2 (quote)
            print!("\nEnter Token 2 (quote) mint address: ");
            io::stdout().flush()?;
            let mut token2 = String::new();
            io::stdin(). read_line(&mut token2)? ;
            let token2 = token2.trim().to_string();

            // Search for quote token info
            let token2_info = match search_token_with_fallback(&token2).await {
                Ok(info) => info,
                Err(_) => {
                    // Default to common quote tokens
                    if token2 == USDC_MINT {
                    TokenInfo {
    id: USDC_MINT.to_string(),
    name: "USD Coin".to_string(),
    symbol: "USDC". to_string(),
    decimals: 6,
    logo_uri: None,
    tags: None,
    is_verified: None,
    usd_price: None,
    liquidity: None,
    holder_count: None,
}
                    } else if token2 == SOL_MINT {
                    TokenInfo {
    id: SOL_MINT.to_string(),
    name: "Solana".to_string(),
    symbol: "SOL". to_string(),
    decimals: 9,
    logo_uri: None,
    tags: None,
    is_verified: None,
    usd_price: None,
    liquidity: None,
    holder_count: None,
}
                    } else {
                        println!("\n[SCAN] Failed to identify quote token, please enter manually:");
                        print!("Enter quote token symbol: ");
                        io::stdout(). flush()?;
                        let mut symbol = String::new();
                        io::stdin().read_line(&mut symbol)?;
                        let symbol = symbol.trim(). to_string();
                        
                        print!("Enter quote token decimals (default 6): ");
                        io::stdout().flush()?;
                        let mut dec_str = String::new();
                        io::stdin().read_line(&mut dec_str)?;
                        let decimals: u32 = dec_str.trim().parse().unwrap_or(6);
                        TokenInfo {
    id: token2. clone(),
    name: format!("{} Token", symbol),
    symbol,
    decimals,
    logo_uri: None,
    tags: None,
    is_verified: None,
    usd_price: None,
    liquidity: None,
    holder_count: None,
}
                    }
                }
            };

            println!("\n[OK] Token Pair Configuration:");
            println!("   Base:  {} ({}, {} decimals)", 
                token1_info.symbol, token1_info.name, token1_info.decimals);
            println!("   Quote: {} ({}, {} decimals)", 
                token2_info. symbol, token2_info.name, token2_info.decimals);

            (token1, token1_info, token2, token2_info. symbol)
        },

            _ => {
                // Default: SOL/USDC
                let sol_info = TokenInfo {
    id: SOL_MINT.to_string(),
    name: "Solana".to_string(),
    symbol: "SOL".to_string(),
    decimals: 9,
    logo_uri: None,
    tags: None,
    is_verified: None,
    usd_price: None,
    liquidity: None,
    holder_count: None,
};
                (SOL_MINT.to_string(), sol_info, USDC_MINT.to_string(), "USDC".to_string())
            }
        };

    println!("\n Waiting for WebSocket connections to establish...");
    tokio::time::sleep(Duration::from_secs(3)).await;

    let mut interval = time::interval(Duration::from_millis(DISPLAY_REFRESH_INTERVAL_MS));
    
    //  NEW: Initialize health tracker
    let mut health_tracker = DexHealthTracker::new();
    
    // Note: WebSocket feeds are for SOL/USDC only
    let using_websocket = base_token_mint == SOL_MINT && quote_token_mint == USDC_MINT;
    
    if !using_websocket {
        println!("\n  Note: Custom tokens use API polling (WebSocket only available for SOL/USDC)");
    }

    println!("\n");
    println!("         LIVE PRICE TICKER (REAL-TIME)             ");
    println!("");
    println!("  Pair: {} / {}", base_token_info.symbol, quote_token_symbol);
    println!("  Amount: 1 {}  {}", base_token_info.symbol, quote_token_symbol);
    println!("   = WebSocket |  = API Fallback");
    println!("   = Healthy |  = Degraded |  = Failed |  = Critical |  = Disabled");
    println!("\nPress CTRL+C to stop\n");

    let mut iteration = 0u32;
    let comparison_amount = 10u64.pow(base_token_info.decimals);

    loop {
        interval.tick().await;
        iteration += 1;

        let timestamp = chrono::Local::now().format("%H:%M:%S");

        // Clear screen and redraw every 2 iterations (1 second)
        if iteration % 2 == 0 {
            print!("\x1B[2J\x1B[1;1H");
            println!("\n");
            println!("         LIVE PRICE TICKER (REAL-TIME)             ");
            println!("");
            println!("  Last Update: {} | Refresh: {}ms | Iteration: {}", 
                timestamp, DISPLAY_REFRESH_INTERVAL_MS, iteration);
            println!("  Pair: {} / {}", base_token_info.symbol, quote_token_symbol);
            
            //  NEW: Show health summary
            let (healthy, degraded, failed) = health_tracker.get_summary();
            println!("  DEX Health:  {} |  {} |  {} ", healthy, degraded, failed);
            println!("");
        }

        let mut best_price = 0.0;
        let mut best_dex = "N/A";
        let mut prices_collected = Vec::new();

        // Iterate through DEXs with health tracking
        for dex in ACTIVE_DEXS.iter() {
            //  NEW: Check if we should query this DEX
            if !health_tracker.should_query(dex, iteration) {
                // Skip querying, but maybe show status
                if health_tracker.should_display(dex, iteration) {
                    let status = health_tracker.get_status(dex);
                    let failures = health_tracker.consecutive_failures.get(*dex).unwrap_or(&0);
                    println!("  {} {:20} Skipped (failures: {})", 
                        status, format!("{}:", dex), failures);
                }
                continue;
            }

            let (price, source_indicator, age_ms) = if using_websocket {
                // Try WebSocket cache first for SOL/USDC
                let cache_key = format!("{}-SOL/USDC", dex);
                let cached = price_cache.read().await.get(&cache_key).cloned();

                if let Some(update) = cached {
                    let age = update.timestamp.elapsed().as_millis();
                    if age < PRICE_STALENESS_MS {
                        (update.price, "", age)
                    } else {
                        // Stale, fall back to API
                        match get_token_price_from_dex(&base_token_mint, comparison_amount, dex).await {
                            Ok(p) => (p, "", 0),
                            Err(_) => (0.0, "", age),
                        }
                    }
                } else {
                    // Not in cache, use API
                    match get_token_price_from_dex(&base_token_mint, comparison_amount, dex).await {
                        Ok(p) => (p, "", 0),
                        Err(_) => (0.0, "", 0),
                    }
                }
            } else {
                // Custom token - always use API
                match get_quote_from_dex(
                    &base_token_mint,
                    &quote_token_mint,
                    comparison_amount,
                    50,
                    dex
                ).await {
                    Ok(quote) => {
                        let out_amount: u64 = quote.out_amount.parse().unwrap_or(0);
                        let quote_decimals = if quote_token_mint == USDC_MINT { 6 } else { 9 };
                        let price = out_amount as f64 / 10u64.pow(quote_decimals) as f64;
                        (price, "", 0)
                    },
                    Err(_) => (0.0, "", 0),
                }
            };

            //  NEW: Update health tracker based on result
            if price > 0.0 {
                // Sanity check price (for SOL/USDC should be $50-$300)
                let is_valid_price = if base_token_mint == SOL_MINT && quote_token_mint == USDC_MINT {
                    (50.0..=500.0).contains(&price)
                } else {
                    true  // Skip validation for custom tokens
                };

                if is_valid_price {
                    health_tracker.record_success(dex);
                    
                    // Only display if should_display says so
                    if health_tracker.should_display(dex, iteration) {
                        let age_display = if age_ms > 0 {
                            format!("{}ms", age_ms)
                        } else {
                            "fresh".to_string()
                        };

                        let health = health_tracker.get_health_percentage(dex);
                        println!("  {} {:20} ${:.6}  ({}) [{}%]",
                            source_indicator,
                            format!("{}:", dex),
                            price,
                            age_display,
                            health
                        );
                    }

                    prices_collected.push((dex.to_string(), price, source_indicator));

                    if price > best_price {
                        best_price = price;
                        best_dex = dex;
                    }
                } else {
                    // Invalid price (e.g., $1.00 for SOL)
                    health_tracker.record_failure(dex);
                    
                    if health_tracker.should_display(dex, iteration) {
                        let status = health_tracker.get_status(dex);
                        println!("  {} {:20} Invalid price: ${:.6}", 
                            status, format!("{}:", dex), price);
                    }
                }
            } else {
                // Failed to get price
                health_tracker.record_failure(dex);
                
                //  NEW: Permanently disable after too many failures
                //
              let failures = *health_tracker.consecutive_failures.get(*dex).unwrap_or(&0);  //  Clone the value
              if failures >= MAX_CONSECUTIVE_FAILURES_DEX {  //  Use the cloned value
                  health_tracker.disable_permanently(dex);
              }

           // Only display if should_display says so
              if health_tracker.should_display(dex, iteration) {
                   let status = health_tracker.get_status(dex);
                   println!("  {} {:20} No data (failures: {})", 
                  status, format!("{}:", dex), failures);
              }          
            }
        }

        // Jupiter aggregator (always query, but track health)
        let jupiter_dex_name = "Jupiter Aggregator";
        if health_tracker.should_query(jupiter_dex_name, iteration) {
            match get_token_price_in_usdc(&base_token_mint, comparison_amount).await {
                Ok(agg_price) => {
                    health_tracker.record_success(jupiter_dex_name);
                    
                    println!("");
                    let health = health_tracker.get_health_percentage(jupiter_dex_name);
                    println!("   {:20} ${:.6} [{}%]", 
                        format!("{}:", jupiter_dex_name), agg_price, health);

                    if agg_price > best_price {
                        best_price = agg_price;
                        best_dex = jupiter_dex_name;
                    }
                },
                Err(_) => {
                    health_tracker.record_failure(jupiter_dex_name);
                    
                    if health_tracker.should_display(jupiter_dex_name, iteration) {
                        println!("");
                        let status = health_tracker.get_status(jupiter_dex_name);
                        println!("  {} {:20} Error", status, format!("{}:", jupiter_dex_name));
                    }
                }
            }
        }

        println!("");
        if best_price > 0.0 {
            println!("    BEST: ${:.6} ({})", best_price, best_dex);

            if prices_collected.len() >= 2 {
                let prices: Vec<f64> = prices_collected.iter().map(|(_, p, _)| *p).collect();
                let min_price = prices.iter().cloned().fold(f64::INFINITY, f64::min);
                let max_price = prices.iter().cloned().fold(f64::NEG_INFINITY, f64::max);
                let spread = ((max_price - min_price) / min_price) * 100.0;

                println!("    Spread: {:.3}% (${:.6} - ${:.6})", spread, min_price, max_price);

                if spread > 0.5 {
                    println!("    Arbitrage opportunity detected!");
                }
            }

            let ws_count = prices_collected.iter().filter(|(_, _, s)| *s == "").count();
            let api_count = prices_collected.iter().filter(|(_, _, s)| *s == "").count();
            println!("    Data sources: {} WebSocket, {} API", ws_count, api_count);
            
            //  NEW: Show active/skipped summary
            let active_count = prices_collected.len();
            let total_count = ACTIVE_DEXS.len() + 1; // +1 for Jupiter
            let skipped_count = total_count - active_count;
            if skipped_count > 0 {
                println!("     Skipped: {} DEXs (will retry periodically)", skipped_count);
            }
        } else {
            println!("    No prices available");
        }
        println!("");

        //  OPTIONAL: Health dashboard every 100 iterations
        if iteration % 100 == 0 {
            println!("\n");
            println!("            DEX HEALTH DASHBOARD                    ");
            println!("");
            
            for dex in ACTIVE_DEXS.iter() {
                let status = health_tracker.get_status(dex);
                let health = health_tracker.get_health_percentage(dex);
                let failures = health_tracker.consecutive_failures.get(*dex).unwrap_or(&0);
                
                let bar_length = (health as usize) / 5;  // 0-20 chars
                let bar = "".repeat(bar_length) + &"".repeat(20 - bar_length);
                
                println!("  {} {:15} [{}] {}% (failures: {})", 
                    status, dex, bar, health, failures);
            }
            println!("");
        }

        io::stdout().flush()?;
    }
}

/// Dynamic price comparison handler that uses discovered pools
    
async fn compare_all_dex_prices_handler_websocket_dynamic(
    price_cache: EnhancedPriceCache,
    base_token_mint: &str,
    quote_token_mint: &str,
    base_token_info: TokenInfo,
    discovered_pools: Vec<(String, String)>,
) -> Result<()> {
// Fetch token info
       // Token info already passed as parameter
    let _base_token_symbol = &base_token_info.symbol;
    let quote_token_symbol = if quote_token_mint == USDC_MINT {
        "USDC".to_string()
    } else if quote_token_mint == SOL_MINT {
        "SOL".to_string()
    } else {
        match search_token_by_address(quote_token_mint).await {
            Ok(info) => info.symbol,
            Err(_) => "???".to_string(),
        }
    };
    
    // Determine price unit symbol based on quote token
    let price_unit = if quote_token_mint == USDC_MINT {
        "$".to_string()  // USD for USDC pairs
    } else {
        quote_token_symbol.clone()  // Token symbol for non-USDC pairs (e.g., "SOL")
    };
    
    let is_usd_quote = quote_token_mint == USDC_MINT;

    let mut interval = time::interval(Duration::from_millis(DISPLAY_REFRESH_INTERVAL_MS));
    let mut health_tracker = DexHealthTracker::new();
    
    println!("\n");
    println!("      LIVE PRICE TICKER (Top 5 Most Liquid Pools)      ");
    println!("");
    println!("  Pair: {} / {}", base_token_info.symbol, quote_token_symbol);
    println!("  Amount: 1 {} -> {}", base_token_info.symbol, quote_token_symbol);
    println!("   = WebSocket |  = API Fallback");
    println!("   = Healthy |  = Degraded |  = Failed |  = Critical");
    println!("\nPress CTRL+C to stop\n");

    let mut iteration = 0u32;

    loop {
        interval.tick().await;
        iteration += 1;

        let timestamp = chrono::Local::now().format("%H:%M:%S");

        // Clear screen and redraw every 2 iterations (1 second)
        if iteration % 2 == 0 {
            print!("\x1B[2J\x1B[1;1H");
            println!("\n");
            println!("      LIVE PRICE TICKER (Top 5 Most Liquid Pools)      ");
            println!("");
            println!("  Last Update: {} | Refresh: {}ms | Iteration: {}", 
                timestamp, DISPLAY_REFRESH_INTERVAL_MS, iteration);
            println!("  Pair: {} / {}", base_token_info.symbol, quote_token_symbol);
            
            let (healthy, degraded, failed) = health_tracker.get_summary();
            println!("  DEX Health:  {} |  {} |  {} ", healthy, degraded, failed);
            println!("");
        }

        let mut best_price = 0.0;
        let mut best_dex = String::from("N/A");
        let mut prices_collected = Vec::new();

        // Check WebSocket cache for all subscribed DEXs
        {
            let cache = price_cache.read().await;
            for (cache_key, update) in cache.iter() {
                let age = update.timestamp.elapsed().as_millis();
                
                // Extract DEX name from cache key (format: "DexName-BASE/QUOTE")
                let dex_name = cache_key.split('-').next().unwrap_or("Unknown").to_string();
                
                if age < PRICE_STALENESS_MS && update.price > 0.0 {
                    health_tracker.record_success(&dex_name);
                    
                    let source_indicator = match update.data_source {
                        DataSource::WebSocket => "",
                        DataSource::API => "",
                    };
                    
                    if health_tracker.should_display(&dex_name, iteration) {
                        let health = health_tracker.get_health_percentage(&dex_name);
                        if is_usd_quote {
                            println!("  {} {:25} ${:.6}  ({}ms) [{}%]",
                                source_indicator,
                                format!("{}:", dex_name),
                                update.price,
                                age,
                                health
                            );
                        } else {
                            println!("  {} {:25} {:.6} {}  ({}ms) [{}%]",
                                source_indicator,
                                format!("{}:", dex_name),
                                update.price,
                                price_unit,
                                age,
                                health
                            );
                        }
                    }
                    
                    prices_collected.push((dex_name.clone(), update.price, source_indicator.to_string()));
                    
                    if update.price > best_price {
                        best_price = update.price;
                        best_dex = dex_name;
                    }
                }
            }
        } // cache lock released here

          // === RPC FALLBACK FOR SILENT POOLS ===
        // Every 10 seconds (20 iterations x 500ms), check for pools with no data
        if iteration % 20 == 0 && iteration > 0 {
            let cache = price_cache.read().await;
            let cache_keys: HashSet<String> = cache.keys().cloned().collect();
            drop(cache);
            
            let async_rpc = AsyncRpcClient::new_with_commitment(
                QUICKNODE_RPC_URL.to_string(),
                CommitmentConfig::confirmed(),
            );
            
            // Check each discovered pool
            for (dex_name, pool_addr) in &discovered_pools {
                let cache_key = format!("{}-{}/{}", dex_name, 
                    base_token_info.symbol, quote_token_symbol);
                
                if ! cache_keys.contains(&cache_key) {
                    // This pool has never reported - try direct RPC fetch
                    println!("\n[{}] [REFRESH] No WebSocket data after {}s, fetching via RPC...", 
                        dex_name, iteration / 2);
                    
                    match Pubkey::from_str(pool_addr) {
                        Ok(pool_pubkey) => {
                            match async_rpc.get_account(&pool_pubkey).await {
                                Ok(account) => {
                                    // Try to parse the account data directly
                                    if let Some(mut price_update) = parse_account_update_from_bytes(
                                        &account.data,
                                        dex_name,
                                        pool_addr,
                                        price_cache.clone(),
                                        &base_token_mint,
                                        &quote_token_mint,
                                        &async_rpc,
                                    ).await {
                                        // === PRICE DIRECTION CORRECTION FOR RPC ===
                                        let corrected_price = match correct_price_direction(
                                            price_update.price,
                                            dex_name,
                                            &base_token_mint,
                                            &quote_token_mint,
                                        ).await {
                                            Some(price) => price,
                                            None => {
                                                println!("[{}] [RPC REJECTED] Price rejected (>50% deviation from expected)", dex_name);
                                                health_tracker.record_failure(dex_name);
                                                continue;
                                            }
                                        };
                                        
                                        if (corrected_price - price_update.price).abs() > 0.0001 {
                                            println!("[{}] [RPC CORRECTED] Price changed from {:.8} to {:.8}", 
                                                dex_name, price_update.price, corrected_price);
                                            price_update.price = corrected_price;
                                        }
                                        
                                        // Mark as API source
                                        price_update. data_source = DataSource::API;
                                        
                                        price_cache.write().await.insert(cache_key. clone(), price_update. clone());
                                        if is_usd_quote {
                                            println!("[{}] [OK] Price fetched via RPC: ${:.6}", 
                                                dex_name, price_update.price);
                                        } else {
                                            println!("[{}] [OK] Price fetched via RPC: {:.6} {}", 
                                                dex_name, price_update.price, price_unit);
                                        }
                                        health_tracker.record_success(dex_name);
                                    } else {
                                        println!("[{}] [X] RPC fetch successful but parsing failed", dex_name);
                                        health_tracker.record_failure(dex_name);
                                    }
                                },
                                Err(e) => {
                                    println!("[{}] [X] RPC fetch failed: {}", dex_name, e);
                                    health_tracker.record_failure(dex_name);
                                }
                            }
                        },
                        Err(e) => {
                            println!("[{}] [X] Invalid pool address: {}", dex_name, e);
                            health_tracker.disable_permanently(dex_name);
                        }
                    }
                }
            }
        }



        // Only use the top 5 discovered pools - no fallback to other DEXs
        // The pools were already limited to 5 in fetch_pools_for_pair()

        // Summary
        if iteration % 2 == 0 && !prices_collected.is_empty() {
            println!("\n  ");
            if is_usd_quote {
                println!("   Best Price: ${:.6} @ {}", best_price, best_dex);
            } else {
                println!("   Best Price: {:.6} {} @ {}", best_price, price_unit, best_dex);
            }
            
            // Price spread
            let prices: Vec<f64> = prices_collected.iter().map(|(_, p, _)| *p).collect();
            if prices.len() > 1 {
                let min_price = prices.iter().cloned().fold(f64::INFINITY, f64::min);
                let max_price = prices.iter().cloned().fold(f64::NEG_INFINITY, f64::max);
                let spread_pct = ((max_price - min_price) / min_price) * 100.0;
                if is_usd_quote {
                    println!("   Spread: {:.4}% (${:.6} - ${:.6})", spread_pct, min_price, max_price);
                } else {
                    println!("   Spread: {:.4}% ({:.6} - {:.6} {})", spread_pct, min_price, max_price, price_unit);
                }
            }
            
            println!("   Active Sources: {}", prices_collected.len());
        }

        io::stdout().flush()?;
    }
}

// ============================================================================
// --- WEBSOCKET-ENHANCED OPTION 4 HANDLER (ARBITRAGE SCANNER) ---
// ============================================================================

async fn run_arbitrage_scanner_websocket(
    keypair: &Keypair,
    solana_client: &SolanaClient,
    base_token_mint: &str,
    base_token_info: &TokenInfo,
    quote_token_mint: &str,
    quote_token_symbol: &str,
    pools_for_ws: Vec<(String, String)>,
    max_trade_usd: f64,
    min_profit_usd: f64,
) -> Result<()> {
    let mut risk_manager = RiskManager::new();
    let mut market_state = MarketState::new();
    let mut scan_count = 0;

    let async_rpc = AsyncRpcClient::new_with_commitment(
        HARDCODED_RPC_URL.to_string(),
        CommitmentConfig::confirmed(),
    );


    // Initialize WebSocket price cache
    let price_cache = create_enhanced_price_cache();
    
    // ===== STEP 5: USE POOLS DISCOVERED BY OPTION 8 =====
    // pools_for_ws is now passed as a parameter from start_arbitrage_scan_handler
    if pools_for_ws.is_empty() {
        println!("\n No pools available for WebSocket monitoring");
        return Ok(());
    }

    println!("\n Using {} pre-discovered pools for WebSocket monitoring", pools_for_ws.len());
    for (dex, addr) in &pools_for_ws {
        println!("    {} ({}...)", dex, &addr[..12.min(addr.len())]);
    }
    
    // Create subscription manager with pre-discovered pools
    let subscription_manager = EnhancedWebSocketSubscriptionManager::with_pools_and_tokens(
        price_cache.clone(),
        pools_for_ws.clone(),
        base_token_mint,
        quote_token_mint,
    );

    // Start WebSocket subscriptions in background
    tokio::spawn(async move {
        subscription_manager.start().await;
    });

    println!("\n");
    println!("       WEBSOCKET-ENHANCED ARBITRAGE SCANNER v2.0               ");
    println!("");
    println!("   Token:       {} / USDC", base_token_info.symbol);
    println!("   Max Trade:   ${:.2} USD", max_trade_usd);
    println!("   Min Profit:  ${:.2} USD", min_profit_usd);
    println!("   Pools:       {} active", pools_for_ws.len());
    println!("");
    println!("  Features:                                                    ");
    println!("   Real-time WebSocket price feeds                           ");
    println!("   Multi-DEX scanning (Orca, Raydium, Meteora)               ");
    println!("   Confidence scoring & market state learning                ");
    println!("   MEV protection via Jito bundles                           ");
    println!("   Telegram alerts (if configured)                           ");
    println!("   Persistent state (survives restarts)                      ");
    println!("");

    println!("\n Establishing WebSocket connections (3s)...");
    tokio::time::sleep(Duration::from_secs(3)).await;

    log_to_file(&format!("=== Arbitrage Scanner Started: {} / USDC | Max: ${:.2} | Min Profit: ${:.2} ===", 
        base_token_info.symbol, max_trade_usd, min_profit_usd));

    loop {
        scan_count += 1;
        scan_count += 1;
        let timestamp = chrono::Local::now(). format("%H:%M:%S");

        if let Err(reason) = risk_manager.can_trade() {
            print!(
                "\r[{}]  Trading halted: {}                    ",
                timestamp, reason
            );
            io::stdout().flush()?;
            if scan_count % 10 == 0 {
                println!();
                risk_manager.print_summary();
            }
            tokio::time::sleep(Duration::from_secs(10)).await;
            continue;
        }

        let base_price_usd = match get_token_price_in_usdc(base_token_mint, 10u64. pow(base_token_info.decimals)). await {
            Ok(price) => price,
            Err(_) => {
                print!(
                    "\r[{}]   Failed to get {} price.  Retrying...      ",
                    timestamp, base_token_info.symbol
                );
                io::stdout().flush()?;
                tokio::time::sleep(Duration::from_secs(2)).await;
                continue;
            }
        };

        let trade_amount_base = if base_price_usd > 0.01 {
            max_trade_usd / base_price_usd
        } else {
            0.2
        };

        let current_balance = if base_token_mint == SOL_MINT {
            match async_rpc.get_balance(&keypair.pubkey()).await {
                Ok(bal) => bal as f64 / LAMPORTS_PER_SOL as f64,
                Err(e) => {
                    eprintln!("\n Failed to check balance: {}", e);
                    tokio::time::sleep(Duration::from_secs(5)).await;
                    continue;
                }
            }
        } else {
            match solana_client.get_token_balance(&keypair.pubkey(), base_token_mint) {
                Ok(balance) => balance,
                Err(e) => {
                    eprintln! ("\n Failed to get token balance: {}", e);
                    tokio::time::sleep(Duration::from_secs(5)).await;
                    continue;
                }
            }
        };

        let required_balance = trade_amount_base * 1.02;

        if current_balance < required_balance {
            println!(
                "\n  Insufficient balance: {:.6} {} (${:.2} USD)",
                current_balance, base_token_info.symbol, current_balance * base_price_usd
            );
            tokio::time::sleep(Duration::from_secs(30)).await;
            continue;
        }

        println! ("\n[{}]  Starting scan #{} | {} Price: ${:.2} | Bal: {:.3} {} (${:.2})",
            timestamp, scan_count, base_token_info.symbol, base_price_usd,
            current_balance, base_token_info.symbol, current_balance * base_price_usd);

        let opportunities = find_arbitrage_opportunities_websocket(
            base_token_mint,
            base_token_info,
            quote_token_mint,
            quote_token_symbol,
            base_price_usd,
            trade_amount_base,
            &mut market_state,
            &price_cache,
            min_profit_usd,
        ). await;

        if opportunities.is_empty() {
            println!("     No profitable opportunities found");
            println!("    Waiting 20s before next scan...\n");
            tokio::time::sleep(Duration::from_secs(20)).await;
            continue;
        }

        let opportunity = &opportunities[0];
        display_enhanced_opportunity(opportunity, &base_token_info. symbol, base_price_usd, scan_count);
        
        // Send Telegram alert for opportunity found
        let sell_dex = opportunity.sell_dex.clone();
        let buy_dex = opportunity.buy_dex.clone();
        let spread = opportunity.spread_pct;
        let profit = opportunity.net_profit_usd;
        let confidence = opportunity.confidence_score;
        let token_sym = base_token_info.symbol.clone();
        tokio::spawn(async move {
            alert_opportunity_found(&sell_dex, &buy_dex, spread, profit, confidence, &token_sym).await;
        });

        if opportunities.len() > 1 {
            println!("\n Additional Opportunities:");
            for (idx, opp) in opportunities.iter().skip(1).take(2).enumerate() {
                println!("   {}. ${:.3} profit | {:.1}% confidence | {}  {}",
                    idx + 2, opp.net_profit_usd, opp.confidence_score, opp.sell_dex, opp.buy_dex);
            }
        }

        log_to_file(&format!("Opportunity found: {:.3}% spread, ${:.3} profit, {:.1} confidence, {} -> {}",    
        opportunity.spread_pct, opportunity.net_profit_usd, opportunity.confidence_score,
            opportunity.sell_dex, opportunity.buy_dex));

        let standard_opp = ArbitrageOpportunity {
            sell_dex: opportunity. sell_dex. clone(),
            buy_dex: opportunity.buy_dex. clone(),
            sell_quote: opportunity.sell_quote.clone(),
            buy_quote: opportunity. buy_quote.clone(),
            gross_profit_sol: opportunity.gross_profit_sol,
            net_profit_usd: opportunity.net_profit_usd,
            spread_pct: opportunity.spread_pct,
            trade_amount_sol: opportunity.trade_amount_sol,
        };

        let mut trade_success = false;
        let pre_trade_balance = current_balance;

        for attempt in 1..=MAX_RETRIES {
            println!("\n Executing Trade (Attempt {}/{})...", attempt, MAX_RETRIES);
            log_to_file(&format!("Executing trade attempt {}: ${:.3} profit expected, {:.1} confidence",
                attempt, opportunity.net_profit_usd, opportunity.confidence_score));

            match execute_arbitrage_with_jito(
                keypair,
                &standard_opp,
                solana_client,
                base_price_usd,
            ).await {
                Ok((sig1, sig2)) => {
                    println!(" Arbitrage Bundle Confirmed!");
                    println!("    Tx1: https://solscan.io/tx/{}", sig1);
                    println!("    Tx2: https://solscan. io/tx/{}", sig2);

                    tokio::time::sleep(Duration::from_secs(2)).await;
                    let post_trade_balance = if base_token_mint == SOL_MINT {
                        match async_rpc.get_balance(&keypair.pubkey()).await {
                            Ok(bal) => bal as f64 / LAMPORTS_PER_SOL as f64,
                            Err(_) => pre_trade_balance,
                        }
                    } else {
                        match solana_client. get_token_balance(&keypair.pubkey(), base_token_mint) {
                            Ok(bal) => bal,
                            Err(_) => pre_trade_balance,
                        }
                    };

                    let actual_profit = post_trade_balance - pre_trade_balance;
                    let actual_pnl = actual_profit * base_price_usd;
                    trade_success = true;

                    println!(" Verified P&L: ${:.3} USD ({:.6} {})",
                        actual_pnl, actual_profit, base_token_info.symbol);

                    market_state.successful_trades.push(opportunity.clone());
                    risk_manager.record_trade(true, actual_pnl, opportunity.trade_amount_sol);
                    log_to_file(&format!("Trade successful: ${:.3} P&L", actual_pnl));
                    
                    // Send Telegram alert for successful trade
                    let tx1_clone = sig1.clone();
                    let tx2_clone = sig2.clone();
                    let token_sym = base_token_info.symbol.clone();
                    tokio::spawn(async move {
                        alert_trade_executed(true, actual_pnl, &tx1_clone, &tx2_clone, &token_sym).await;
                    });
                    
                    break;
                }
                Err(e) => {
                    println!(" Execution attempt {} failed: {}", attempt, e);
                    log_to_file(&format!("Trade attempt {} failed: {}", attempt, e));

                    market_state.failed_executions.push((
                        opportunity.sell_dex.clone(),
                        opportunity.buy_dex. clone(),
                        chrono::Local::now(),
                    ));

                    if attempt < MAX_RETRIES {
                        println!("    Retrying in 2s...");
                        tokio::time::sleep(Duration::from_secs(2)).await;
                    }
                }
            }
        }

        if ! trade_success {
            risk_manager.record_failure();
            println!(" All execution attempts failed.");
        }

        // === INSERT: MULTI-TOKEN / TRIANGULAR SCAN ===
        if scan_count % 5 == 0 { // Check triangular every 5th scan to avoid rate limits
            println!("\n    Scanning Triangular Routes (SOL -> X -> USDC -> SOL)...");
            
            let targets = vec![
                (JUP_MINT, "JUP"),
                (BONK_MINT, "BONK"),
                (WIF_MINT, "WIF"),
                (RAY_MINT, "RAY")
            ];

            for (mint, symbol) in targets {
                if let Some(tri_opp) = check_triangular_arbitrage(trade_amount_base, base_price_usd, mint, symbol).await {
                    println!("\n    TRIANGULAR OPPORTUNITY: {}", tri_opp.route_description);
                    println!("      Profit: ${:.4} ({:.2}%)", tri_opp.net_profit_usd, tri_opp.profit_pct);
                    // Add execution logic here if desired
                }
            }
        }

        // === UPDATED SLEEP INTERVAL ===
        let wait_time_ms = if trade_success { 
            30000 // 30s after success
        } else if !opportunities.is_empty() {
            1000 // 1s if we found opps but failed to execute (retry fast)
        } else {
            SCAN_INTERVAL_NO_OPPORTUNITY_MS // 2s default (was 20s)
        };
        
        println!(" Waiting {:.1}s before next scan...\n", wait_time_ms as f64 / 1000.0);
        tokio::time::sleep(Duration::from_millis(wait_time_ms)).await;

    }
}


// ============================================================================
// --- MENU OPTION HANDLERS ---
// ============================================================================

async fn get_sol_price_handler() -> Result<()> {
    let price = get_sol_usdc_price().await?;
    println!("\n 1 SOL = ${:.6} USDC", price);
    Ok(())
}

async fn check_wallet_value_handler() -> Result<()> {
    println!("\n");
    println!("          WALLET VALUE CHECKER                      ");
    println!("");

    let keypair = load_keypair_secure()?;
    let pubkey = keypair.pubkey();

    let solana_client = SolanaClient::new();
    let sol_balance = solana_client.get_token_balance(&pubkey, SOL_MINT)?;
    let usdc_balance = solana_client.get_token_balance(&pubkey, USDC_MINT)?;

    let sol_price_usdc = get_sol_usdc_price().await.unwrap_or(0.0);
    let total_usd_value = (sol_balance * sol_price_usdc) + usdc_balance;

    println!("\n Wallet Balances:");
    println!("  SOL Balance:   {:.6} SOL", sol_balance);
    println!("  USDC Balance:  {:.6} USDC", usdc_balance);
    if sol_price_usdc > 0.0 {
        println!("  SOL Price:     ${:.2}", sol_price_usdc);
        println!("  Total Value:   ${:.2} USD", total_usd_value);
    }
    println!("");
    Ok(())
}

async fn test_rpc_latency_handler() -> Result<()> {
    println!("\n");
    println!("       RPC LATENCY TEST (Custom Endpoints)           ");
    println!("");

    println!("\n  RPC Endpoint Selection:");
    println!("1. Test QuickNode (default)");
    println!("2. Test Default Solana RPC");
    println!("3. Test Custom RPC URL");
    println!("4. Compare Multiple RPCs");
    print!("\nChoice (1-4): ");
    io::stdout().flush()?;

    let mut choice = String::new();
    io::stdin().read_line(&mut choice)?;

    match choice.trim() {
        "1" => {
            test_single_rpc("QuickNode", QUICKNODE_RPC_URL).await?;
        }
        "2" => {
            test_single_rpc("Default Solana RPC", HARDCODED_RPC_URL).await?;
        }
        "3" => {
            println!("\n Enter Custom RPC URL:");
            println!("   Examples:");
            println!("   - https://api.mainnet-beta.solana.com");
            println!("   - https://solana-api.projectserum.com");
            println!("   - https://rpc.ankr.com/solana");
            println!("   - wss://api.mainnet-beta.solana.com (WebSocket)");
            print!("\nRPC URL: ");
            io::stdout().flush()?;

            let mut custom_url = String::new();
            io::stdin().read_line(&mut custom_url)?;
            let custom_url = custom_url.trim();

            if custom_url.is_empty() {
                println!(" No URL provided, cancelling.");
                return Ok(());
            }

            // Validate URL format
            if !custom_url.starts_with("http://") && 
               !custom_url.starts_with("https://") && 
               !custom_url.starts_with("ws://") && 
               !custom_url.starts_with("wss://") {
                println!(" Invalid URL format. Must start with http://, https://, ws://, or wss://");
                return Ok(());
            }

            print!("\n Enter a label for this RPC (or press Enter for 'Custom RPC'): ");
            io::stdout().flush()?;
            let mut label = String::new();
            io::stdin().read_line(&mut label)?;
            let label = if label.trim().is_empty() {
                "Custom RPC"
            } else {
                label.trim()
            };

            test_single_rpc(label, custom_url).await?;
        }
        "4" => {
            println!("\n Comparison Mode - Testing Multiple RPCs");
            println!("\nHow many RPC endpoints do you want to test?");
            print!("Count (1-10): ");
            io::stdout().flush()?;

            let mut count_str = String::new();
            io::stdin().read_line(&mut count_str)?;
            let count: usize = count_str.trim().parse().unwrap_or(2).min(10).max(1);

            let mut endpoints = Vec::new();

            for i in 1..=count {
                println!("\n--- Endpoint {} of {} ---", i, count);
                
                print!("Enter RPC URL: ");
                io::stdout().flush()?;
                let mut url = String::new();
                io::stdin().read_line(&mut url)?;
                let url = url.trim().to_string();

                if url.is_empty() {
                    println!("  Skipping empty URL");
                    continue;
                }

                if !url.starts_with("http://") && 
                   !url.starts_with("https://") && 
                   !url.starts_with("ws://") && 
                   !url.starts_with("wss://") {
                    println!("  Skipping invalid URL format");
                    continue;
                }

                print!("Enter label (or press Enter for 'RPC {}'): ", i);
                io::stdout().flush()?;
                let mut label = String::new();
                io::stdin().read_line(&mut label)?;
                let label = if label.trim().is_empty() {
                    format!("RPC {}", i)
                } else {
                    label.trim().to_string()
                };

                endpoints.push((label, url));
            }

            if endpoints.is_empty() {
                println!("\n No valid endpoints provided.");
                return Ok(());
            }

            compare_multiple_rpcs(endpoints).await?;
        }
        _ => {
            println!(" Invalid choice. Please enter 1-4.");
        }
    }

    Ok(())
}

async fn test_single_rpc(label: &str, rpc_url: &str) -> Result<()> {
    println!("\n  Testing {} RPC endpoint...", label);
    println!("   URL: {}", rpc_url);

    // Check if it's a WebSocket URL
    if rpc_url.starts_with("ws://") || rpc_url.starts_with("wss://") {
        println!("\n  WebSocket endpoints detected.");
        println!("   WebSocket latency testing is not supported in this mode.");
        println!("   Please provide an HTTP/HTTPS RPC endpoint.");
        return Ok(());
    }

    let client = AsyncRpcClient::new_with_commitment(
        rpc_url.to_string(),
        CommitmentConfig::confirmed(),
    );

    let mut latencies = Vec::new();
    const TEST_COUNT: u32 = 10;

    
println!("\n Running {} latency tests...\n", TEST_COUNT);

for i in 1..=TEST_COUNT {  // Keep 'i' here - it's used below
    let start_time = std::time::Instant::now();
    match client.get_latest_blockhash().await {
        Ok(_) => {
            let latency = start_time.elapsed().as_millis();
            latencies.push(latency);
            let status = if latency < 100 {
                ""
            } else if latency < 300 {
                " "
            } else {
                ""
            };
            println!("   {} Test {:2}/{}: {:4}ms", status, i, TEST_COUNT, latency);
        }
        Err(e) => {
            println!("    Test {:2}/{} failed: {}", i, TEST_COUNT, e);
        }
    }
    tokio::time::sleep(Duration::from_millis(200)).await;
}

    println!("");
    if !latencies.is_empty() {
        let avg_latency = latencies.iter().sum::<u128>() / latencies.len() as u128;
        let min_latency = latencies.iter().min().unwrap();
        let max_latency = latencies.iter().max().unwrap();
        
        // Calculate median
        let mut sorted_latencies = latencies.clone();
        sorted_latencies.sort();
        let median_latency = if sorted_latencies.len() % 2 == 0 {
            (sorted_latencies[sorted_latencies.len() / 2 - 1] + 
             sorted_latencies[sorted_latencies.len() / 2]) / 2
        } else {
            sorted_latencies[sorted_latencies.len() / 2]
        };

        // Calculate standard deviation
        let variance: f64 = latencies.iter()
            .map(|&x| {
                let diff = x as f64 - avg_latency as f64;
                diff * diff
            })
            .sum::<f64>() / latencies.len() as f64;
        let std_dev = variance.sqrt();

        println!("");
        println!("          {} STATISTICS                    ", label);
        println!("");
        println!("  Average:         {:6}ms                           ", avg_latency);
        println!("  Median:          {:6}ms                           ", median_latency);
        println!("  Min:             {:6}ms                           ", min_latency);
        println!("  Max:             {:6}ms                           ", max_latency);
        println!("  Std Deviation:   {:6.2}ms                         ", std_dev);
        println!("  Success Rate:    {}/{} ({:.1}%)                    ", 
                 latencies.len(), TEST_COUNT, 
                 (latencies.len() as f64 / TEST_COUNT as f64) * 100.0);
        println!("");

        println!("\n Performance Rating:");
        if avg_latency < 50 {
            println!("    EXCELLENT - Perfect for high-frequency arbitrage");
        } else if avg_latency < 100 {
            println!("      VERY GOOD - Suitable for competitive arbitrage");
        } else if avg_latency < 200 {
            println!("        GOOD - Acceptable for arbitrage trading");
        } else if avg_latency < 300 {
            println!("          FAIR - May miss fast opportunities");
        } else {
            println!("            POOR - Not recommended for arbitrage");
        }

        if std_dev > 100.0 {
            println!("\n     WARNING: High latency variance detected ({:.1}ms)", std_dev);
            println!("      This RPC may have inconsistent performance.");
        }
    } else {
        println!(" All connection tests failed.");
        println!("\nPossible causes:");
        println!("    Invalid RPC URL");
        println!("    Network connectivity issues");
        println!("    RPC endpoint is down");
        println!("    Firewall blocking connection");
        println!("    Rate limiting");
    }

    Ok(())
}

async fn compare_multiple_rpcs(endpoints: Vec<(String, String)>) -> Result<()> {
    println!("\n");
    println!("         MULTI-RPC COMPARISON TEST                    ");
    println!("");
    println!("\n Testing {} endpoints...\n", endpoints.len());

    let mut results = Vec::new();
    const TEST_COUNT: u32 = 5;

    for (idx, (label, url)) in endpoints.iter().enumerate() {
        println!("--- Testing {} ({}/{}) ---", label, idx + 1, endpoints.len());
        println!("    URL: {}", url);

        if url.starts_with("ws://") || url.starts_with("wss://") {
            println!("      WebSocket endpoint - skipping\n");
            continue;
        }

        let client = AsyncRpcClient::new_with_commitment(
            url.to_string(),
            CommitmentConfig::confirmed(),
        );

        let mut latencies = Vec::new();



        for _i in 1..=TEST_COUNT {  //  Add underscore since 'i' is not used in this loop
            let start_time = std::time::Instant::now();
            match client.get_latest_blockhash().await {
                Ok(_) => {
                    let latency = start_time.elapsed().as_millis();
                    latencies.push(latency);
                    print!(".");
                    io::stdout().flush().ok();
                }
                Err(_) => {
                    print!("X");
                    io::stdout().flush().ok();
                }
            }
            tokio::time::sleep(Duration::from_millis(200)).await;
        }
        println!(" Done");

        if !latencies.is_empty() {
            let avg = latencies.iter().sum::<u128>() / latencies.len() as u128;
            let min = *latencies.iter().min().unwrap();
            let max = *latencies.iter().max().unwrap();
            results.push((label.clone(), avg, min, max, latencies.len()));
            println!("     Avg: {}ms | Min: {}ms | Max: {}ms\n", avg, min, max);
        } else {
            println!("     All tests failed\n");
            results.push((label.clone(), u128::MAX, u128::MAX, u128::MAX, 0));
        }
    }

    // Sort by average latency
    results.sort_by_key(|r| r.1);

    println!("\n");
    println!("              COMPARISON RESULTS                      ");
    println!("\n");

    for (rank, (label, avg, min, max, success)) in results.iter().enumerate() {
        if *avg == u128::MAX {
            println!(" {:<20} FAILED ({}/{})", label, success, TEST_COUNT);
            continue;
        }

        let medal = match rank {
            0 => "",
            1 => "",
            2 => "",
            _ => "  ",
        };

        println!("{} {:<20} Avg: {:4}ms | Min: {:4}ms | Max: {:4}ms | {}/{}", 
                 medal, label, avg, min, max, success, TEST_COUNT);
    }

    println!("\n Recommendation:");
    if let Some((best_label, best_avg, _, _, _)) = results.first() {
        if *best_avg != u128::MAX {
            println!("   Use '{}' for best performance ({}ms average latency)", best_label, best_avg);
        } else {
            println!("    No working RPC endpoints found");
        }
    }

    Ok(())
}
async fn start_arbitrage_scan_handler() -> Result<()> {
    println!("\n");
    println!("");
    println!("     WEBSOCKET-ENHANCED ARBITRAGE SCANNER v2.0                 ");
    println!("                                                               ");
    println!("   Scans for arbitrage opportunities across DEXs             ");
    println!("   All profits calculated in USDC                            ");
    println!("   Real-time WebSocket price feeds                           ");
    println!("    MEV protection via Jito bundles                          ");
    println!("");

    println!("\n Default Configuration:");
    println!("    Quote Token:      USDC (fixed)");
    println!("    Daily Loss Limit: ${} USD", MAX_DAILY_LOSS_USD);
    println!("    Trade settings will be configured after wallet load");

    println!("\n Token Selection:");
    println!("   1. SOL (Solana) - Most liquid");
    println!("   2. Custom token (enter mint address)");
    print!("\n   Choice (1-2, default=1): ");
    io::stdout().flush()?;

    let mut token_choice = String::new();
    io::stdin().read_line(&mut token_choice)?;

    let (base_token_mint, base_token_info) = match token_choice.trim() {
        "2" => {
            println!("\n Enter Token Mint Address:");
            print!("   > ");
            io::stdout().flush()?;
            let mut mint = String::new();
            io::stdin().read_line(&mut mint)?;
            let mint = mint.trim().to_string();

            if mint.len() < 32 {
                println!(" Invalid mint address (too short)");
                return Ok(());
            }

            println!("\n Searching for token information...");

            let token_info = match search_token_by_address(&mint).await {
                Ok(info) => {
                    println!(" Token found!");
                    println!("   Name:     {}", info.name);
                    println!("   Symbol:   {}", info.symbol);
                    println!("   Decimals: {}", info.decimals);
                    if let Some(price) = info.usd_price {
                        println!("   Price:    ${:.6}", price);
                    }
                    if let Some(verified) = info.is_verified {
                        println!("   Verified: {}", if verified { " Yes" } else { " No" });
                    }
                    info
                },
                Err(e) => {
                    eprintln!(" Could not fetch token info: {}", e);
                    println!("\n Manual Entry Required:");

                    print!("   Token Symbol (e.g., BONK): ");
                    io::stdout().flush()?;
                    let mut symbol = String::new();
                    io::stdin().read_line(&mut symbol)?;
                    let symbol = symbol.trim().to_string();

                    print!("   Token Decimals (default 6): ");
                    io::stdout().flush()?;
                    let mut dec_str = String::new();
                    io::stdin().read_line(&mut dec_str)?;
                    let decimals: u32 = dec_str.trim().parse().unwrap_or(6);
                    
                    TokenInfo {
                        id: mint.clone(),
                        name: format!("{} Token", symbol),
                        symbol: symbol.clone(),
                        decimals,
                        logo_uri: None,
                        tags: None,
                        is_verified: None,
                        usd_price: None,
                        liquidity: None,
                        holder_count: None,
                    }
                }
            };

            (mint, token_info)
        },
        _ => {
            // Default: SOL
            let sol_info = TokenInfo {
                id: SOL_MINT.to_string(),
                name: "Solana".to_string(),
                symbol: "SOL".to_string(),
                decimals: 9,
                logo_uri: None,
                tags: None,
                is_verified: Some(true),
                usd_price: None,
                liquidity: None,
                holder_count: None,
            };
            println!("\n Selected: SOL (Solana)");
            (SOL_MINT.to_string(), sol_info)
        }
    };

    // USDC is ALWAYS the quote token
    let quote_token_mint = USDC_MINT.to_string();
    let quote_token_symbol = "USDC".to_string();

    println!("\n Trading Pair: {} / USDC", base_token_info.symbol);

    // 
    //  POOL DISCOVERY
    // 

    println!("\n");
    println!("");
    println!("                    POOL DISCOVERY                               ");
    println!("");

    print!("\n   Max pools to monitor (1-20, default 10): ");
    io::stdout().flush()?;
    let mut max_input = String::new();
    io::stdin().read_line(&mut max_input)?;
    let max_pools: usize = max_input.trim().parse().unwrap_or(10).clamp(1, 20);

    print!("   Min liquidity per pool in USD (default 50,000): ");
    io::stdout().flush()?;
    let mut min_input = String::new();
    io::stdin().read_line(&mut min_input)?;
    // Remove commas from input (e.g., "10,000" -> "10000")
    let cleaned_input = min_input.trim().replace(",", "");
    let min_liquidity: f64 = cleaned_input.parse().unwrap_or(50_000.0);

    let pool_config = PoolDiscoveryConfig {
        max_pools,
        min_liquidity_usd: min_liquidity,
        only_working_dexs: true,
    };

    println!("\n Discovering {}/USDC pools...", base_token_info.symbol);

    let discovered_pools = discover_pools_for_arbitrage(
        &base_token_mint,
        &quote_token_mint,
        pool_config,
    ).await?;

    if discovered_pools.is_empty() {
        println!("\n No qualifying pools found!");
        println!("   Try lowering the minimum liquidity requirement");
        println!("   Or check if the token has USDC trading pairs");
        return Ok(());
    }

    // Convert to format needed by WebSocket manager
    let mut pools_for_ws: Vec<(String, String)> = discovered_pools
        .iter()
        .map(|p| (p.dex_name.clone(), p.pool_address.clone()))
        .collect();

    // Remove duplicates
    deduplicate_pools(&mut pools_for_ws);

    let total_liq: f64 = discovered_pools.iter().map(|p| p.liquidity_usd).sum();

    println!("\n");
    println!("                    DISCOVERED POOLS                             ");
    println!("");
    println!("  Pair:            {} / USDC", base_token_info.symbol);
    println!("  Pools Found:     {}", pools_for_ws.len());
    println!("  Total Liquidity: ${:.0}", total_liq);
    println!("");
    
    for (i, pool) in discovered_pools.iter().enumerate().take(10) {
        println!("  {}. {:<20} ${:>12.0}", i + 1, pool.dex_name, pool.liquidity_usd);
    }
    println!("");

    // 
    //  WALLET & BALANCE CHECK
    // 

    println!("\n Loading wallet...");
    let keypair = load_keypair_secure()?;
    let pubkey = keypair.pubkey();
    let solana_client = SolanaClient::new();

    // Check base token balance
    let base_balance = if base_token_mint == SOL_MINT {
        solana_client.get_token_balance(&pubkey, SOL_MINT)?
    } else {
        solana_client.get_token_balance(&keypair.pubkey(), &base_token_mint)?
    };

    // Check USDC balance (for buying back)
    let usdc_balance = solana_client.get_token_balance(&pubkey, USDC_MINT)?;

    // Get token price in USDC
    let one_token_amount = 10u64.pow(base_token_info.decimals);
    let base_price_usd = match get_token_price_in_usdc(&base_token_mint, one_token_amount).await {
        Ok(price) => price,
        Err(_) => 0.0,
    };

    println!("\n");
    println!("                    WALLET BALANCE                               ");
    println!("");
    println!("  Address: {}...{}", &pubkey.to_string()[..8], &pubkey.to_string()[36..]);
    println!("");
    println!("  {}:  {:.6}", base_token_info.symbol, base_balance);
    if base_price_usd > 0.01 {
        println!("        (${:.2} USD)", base_balance * base_price_usd);
    }
    println!("  USDC:   {:.2}", usdc_balance);
    println!("");

    // 
    //  TRADING PARAMETERS
    // 

    println!("\n");
    println!("                 TRADING PARAMETERS                              ");
    println!("");

    // Ask for maximum trade value
    print!("\n    Maximum trade value in USD (default {}): ", MAX_TRADE_AMOUNT_USD);
    io::stdout().flush()?;
    let mut max_trade_input = String::new();
    io::stdin().read_line(&mut max_trade_input)?;
    let max_trade_usd: f64 = max_trade_input.trim().parse().unwrap_or(MAX_TRADE_AMOUNT_USD);
    
    // Validate max trade doesn't exceed balance
    let max_possible_trade = if base_price_usd > 0.01 {
        base_balance * base_price_usd * 0.95  // 95% of balance to leave room for fees
    } else {
        MAX_TRADE_AMOUNT_USD
    };
    
    let max_trade_usd = max_trade_usd.min(max_possible_trade);
    if max_trade_usd < max_trade_input.trim().parse().unwrap_or(MAX_TRADE_AMOUNT_USD) {
        println!("     Adjusted to ${:.2} based on your balance", max_trade_usd);
    }

    // Ask for minimum profit target
    print!("    Minimum profit target in USD (default {}): ", DESIRED_NET_PROFIT_USD);
    io::stdout().flush()?;
    let mut min_profit_input = String::new();
    io::stdin().read_line(&mut min_profit_input)?;
    let min_profit_usd: f64 = min_profit_input.trim().parse().unwrap_or(DESIRED_NET_PROFIT_USD);

    println!("\n    Trade Settings Configured:");
    println!("       Max Trade:    ${:.2} USD", max_trade_usd);
    println!("       Min Profit:   ${:.2} USD", min_profit_usd);
    
    // Calculate tokens per trade
    let tokens_per_trade = if base_price_usd > 0.01 {
        max_trade_usd / base_price_usd
    } else {
        0.2
    };
    println!("       Per Trade:    {:.6} {}", tokens_per_trade, base_token_info.symbol);

    // 
    //  FINAL CONFIRMATION
    // 

    println!("\n");
    println!("                      FINAL CONFIRMATION                      ");
    println!("");
    println!("  This bot will trade REAL MONEY on Solana mainnet!            ");
    println!("");
    println!("  Trading Pair:  {} / USDC", base_token_info.symbol);
    println!("  Max Trade:     ${:.2} USD per trade", max_trade_usd);
    println!("  Min Profit:    ${:.2} USD target", min_profit_usd);
    println!("  Loss Limit:    ${} USD daily", MAX_DAILY_LOSS_USD);
    println!("  Pools:         {} active pools", pools_for_ws.len());
    println!("");
    println!("  Profits will be calculated and tracked in USDC               ");
    println!("");

    println!("\n Type 'START' (all caps) to begin trading:");
    print!("   > ");
    io::stdout().flush()?;
    let mut confirmation = String::new();
    io::stdin().read_line(&mut confirmation)?;

    if confirmation.trim() != "START" {
        println!(" Cancelled.");
        return Ok(());
    }

    println!("\n Launching WebSocket-Enhanced Arbitrage Scanner...");
    println!("   Press Ctrl+C to stop\n");
    
    run_arbitrage_scanner_websocket(
        &keypair,
        &solana_client,
        &base_token_mint,
        &base_token_info,
        &quote_token_mint,
        &quote_token_symbol,
        pools_for_ws,
        max_trade_usd,
        min_profit_usd,
    ).await?;

    Ok(())
}

async fn start_ultra_swap_tool() -> Result<()> {
    println!("\n");
    println!("   Jupiter Ultra V1 Swap Tool (Authenticated)      ");
    println!("");

    let rpc_url = HARDCODED_RPC_URL.to_string();

    let wallet = match load_keypair_secure() {
        Ok(kp) => kp,
        Err(e) => {
            eprintln!("[X] Failed to load keypair: {}", e);
            return Ok(());
        }
    };

    println!("\n[OK] Wallet loaded successfully!");
    println!("   Address: {}", wallet.pubkey());
    let client = match JupiterUltraV1Client::new(&rpc_url, wallet) {
        Ok(c) => c,
        Err(e) => {
            eprintln!("[X] Failed to initialize Jupiter Ultra V1 Client: {}", e);
            return Ok(());
        }
    };

    println!("\n[OK] Connected to Solana network");
    println!("   RPC: {}", rpc_url);
    println!("   Ultra API: {} (Authenticated)", JUPITER_ULTRA_API);

    loop {
        println!("\n[MENU] Swap Tool Options:");
        println!("   1. View Wallet Balance");
        println!("   2. Swap SOL -> USDC");
        println!("   3. Swap USDC -> SOL");
        println!("   4. Return to Main Menu");
        print!("\nEnter choice (1-4): ");
        io::stdout().flush()?;
        let choice = {
            let mut s = String::new();
            io::stdin().read_line(&mut s).unwrap();
            s.trim().to_string()
        };
        match choice.as_str() {
            "1" => {
                match client.get_balances().await {
                    Ok(balance) => balance.display(),
                    Err(e) => eprintln!("[X] Failed to fetch balances: {}", e),
                }
            }
            "2" => {
                println!("\n[SWAP] SOL -> USDC");
                if let Err(e) = handle_ultra_swap_execution(
                    &client,
                    SOL_MINT,
                    USDC_MINT,
                    "Enter amount of SOL to swap: ",
                    LAMPORTS_PER_SOL,
                ).await {
                    eprintln!("[X] Swap failed: {}", e);
                }
            }
            "3" => {
                println!("\n[SWAP] USDC -> SOL");
                if let Err(e) = handle_ultra_swap_execution(
                    &client,
                    USDC_MINT,
                    SOL_MINT,
                    "Enter amount of USDC to swap: ",
                    10u64.pow(USDC_DECIMALS),
                ).await {
                    eprintln!("[X] Swap failed: {}", e);
                }
            }
            "4" => {
                println!("\nReturning to main menu.");
                return Ok(());
            }
            _ => {
                println!("[X] Invalid choice. Please enter 1-4.");
            }
        }
    }
}

async fn handle_ultra_swap_execution(
    client: &JupiterUltraV1Client,
    input_mint: &str,
    output_mint: &str,
    amount_prompt: &str,
    decimals: u64,
) -> Result<()> {
    print!("\n{}", amount_prompt);
    io::stdout().flush()?;

    let amount_str = {
        let mut s = String::new();
        io::stdin().read_line(&mut s).unwrap();
        s.trim().to_string()
    };
    let amount_f64: f64 = amount_str.parse().context("Invalid amount. Please enter a number.")?;
    if amount_f64 <= 0.0 {
        return Err(anyhow!("Amount must be greater than 0"));
    }

    let amount = (amount_f64 * decimals as f64) as u64;
    print!("\nSlippage tolerance in % (press Enter for auto): ");
    io::stdout().flush()?;
    let slippage_str = {
        let mut s = String::new();
        io::stdin().read_line(&mut s).unwrap();
        s.trim().to_string()
    };

    let slippage_bps = if slippage_str.is_empty() {
        println!("[INFO] Using auto-slippage");
        None
    } else {
        let slippage_pct: f64 = slippage_str.parse().context("Invalid slippage percentage")?;
        let bps = (slippage_pct * 100.0) as u16;
        println!("[INFO] Using {}% slippage ({} bps)", slippage_pct, bps);
        Some(bps)
    };

    let order = client.get_order(input_mint, output_mint, amount, slippage_bps).await?;

    print!("\n[?] Proceed with this swap? (yes/no): ");
    io::stdout().flush()?;
    let confirmation = {
        let mut s = String::new();
        io::stdin().read_line(&mut s).unwrap();
        s.trim().to_string()
    };

    if confirmation.to_lowercase() != "yes" && confirmation.to_lowercase() != "y" {
        println!("[X] Swap cancelled.");
        return Ok(());
    }

    client.execute_order(order).await?;

    Ok(())
}

/// Get quote for custom token pair from specific DEX
async fn get_custom_token_quote_from_dex(
    input_mint: &str,
    output_mint: &str,
    amount: u64,
    dex_label: &str,
) -> Result<f64> {
    let quote = get_quote_from_dex(
        input_mint,
        output_mint,
        amount,
        50, // 0.5% slippage
        dex_label
    ).await?;
    
    let out_amount: u64 = quote.out_amount.parse()
        .map_err(|_| anyhow!("Failed to parse output amount"))?;
    
    // Determine output token decimals
    let decimals = if output_mint == USDC_MINT {
        6
    } else if output_mint == SOL_MINT {
        9
    } else {
        // Default to 6 for unknown tokens (can be improved)
        6
    };
    
    Ok(out_amount as f64 / 10u64.pow(decimals) as f64)
}



// ============================================================================
// --- DEX LIQUIDITY POOL FINDER ---
// ============================================================================

#[derive(Debug, Deserialize, Serialize, Clone)]
struct DexScreenerPair {
    #[serde(rename = "pairAddress")]
    pair_address: String,
    #[serde(rename = "dexId")]
    dex_id: String,
    #[serde(rename = "baseToken")]
    base_token: DexScreenerToken,
    #[serde(rename = "quoteToken")]
    quote_token: DexScreenerToken,
    liquidity: Option<DexScreenerLiquidity>,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
struct DexScreenerToken {
    address: String,
    name: Option<String>,
    symbol: Option<String>,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
struct DexScreenerLiquidity {
    usd: Option<f64>,
}

#[derive(Debug, Deserialize, Serialize)]
struct DexScreenerApiResponse {
    pairs: Option<Vec<DexScreenerPair>>,
}

async fn get_pairs_for_token(token_address: &str) -> Result<Vec<DexScreenerPair>> {
    let url = format!("https://api.dexscreener.com/latest/dex/tokens/{}", token_address);
    
    let client = reqwest::Client::new();
    let response = client.get(&url).send().await?;
    let data: DexScreenerApiResponse = response.json().await?;
    
    match data.pairs {
        Some(pairs) => Ok(pairs),
        None => Ok(Vec::new()),
    }
}

fn find_matching_pairs(token1: &str, token2: &str, pairs: Vec<DexScreenerPair>) -> Vec<DexScreenerPair> {
    pairs
        .into_iter()
        .filter(|pair| {
            let base_addr = pair.base_token.address.to_lowercase();
            let quote_addr = pair.quote_token.address.to_lowercase();
            let token1_lower = token1.to_lowercase();
            let token2_lower = token2.to_lowercase();
            
            (base_addr == token1_lower && quote_addr == token2_lower) ||
            (base_addr == token2_lower && quote_addr == token1_lower)
        })
        .collect()
}

fn get_top_liquid_pairs(mut pairs: Vec<DexScreenerPair>, limit: usize) -> Vec<DexScreenerPair> {
    // Sort by liquidity (descending)
    pairs.sort_by(|a, b| {
        let liq_a = a.liquidity.as_ref().and_then(|l| l.usd).unwrap_or(0.0);
        let liq_b = b.liquidity.as_ref().and_then(|l| l.usd).unwrap_or(0.0);
        liq_b.partial_cmp(&liq_a).unwrap_or(std::cmp::Ordering::Equal)
    });
    
    pairs.into_iter().take(limit).collect()
}

fn format_number_with_commas(num: f64) -> String {
    let s = format!("{:.2}", num);
    let parts: Vec<&str> = s.split('.').collect();
    let integer_part = parts[0];
    let decimal_part = if parts.len() > 1 { parts[1] } else { "00" };
    
    let mut result = String::new();
    let chars: Vec<char> = integer_part.chars().collect();
    let len = chars.len();
    
    for (i, c) in chars.iter().enumerate() {
        if i > 0 && (len - i) % 3 == 0 {
            result.push(',');
        }
        result.push(*c);
    }
    
    format!("{}.{}", result, decimal_part)
}

fn format_liquidity(liquidity: Option<&DexScreenerLiquidity>) -> String {
    match liquidity.and_then(|l| l.usd) {
        Some(usd) => format!("${}", format_number_with_commas(usd)),
        None => "N/A".to_string(),
    }
}

async fn dex_liquidity_pool_finder() -> Result<()> {
    println!("\n=== DEX Liquidity Pool Finder ===\n");
    
    // Get Token 1 address
    print!("Enter Token 1 mint address: ");
    io::stdout().flush()?;
    let mut token1 = String::new();
    io::stdin().read_line(&mut token1)?;
    let token1 = token1.trim();
    
    // Get Token 2 address
    print!("Enter Token 2 mint address: ");
    io::stdout().flush()?;
    let mut token2 = String::new();
    io::stdin().read_line(&mut token2)?;
    let token2 = token2.trim();
    
    println!("\nSearching for liquidity pools...\n");
    
    // Fetch pairs for both tokens
    let pairs1_result = get_pairs_for_token(token1).await;
    let pairs2_result = get_pairs_for_token(token2).await;
    
    match (pairs1_result, pairs2_result) {
        (Ok(pairs1), Ok(pairs2)) => {
            // Combine and deduplicate pairs
            let mut all_pairs = pairs1;
            all_pairs.extend(pairs2);
            
            // Find pairs that match both tokens
            let matching_pairs = find_matching_pairs(token1, token2, all_pairs);
            
            if matching_pairs.is_empty() {
                println!("No liquidity pools found for this token pair.");
                return Ok(());
            }
            
            // Get top 5 by liquidity
            let top_pairs = get_top_liquid_pairs(matching_pairs, 5);
            
            println!("Top {} DEXes by Liquidity:\n", top_pairs.len());
            println!("{:<5} {:<20} {:<20} {:<50}", "Rank", "DEX", "Liquidity", "Pool Address");
            println!("{}", "=".repeat(100));
            
            for (index, pair) in top_pairs.iter().enumerate() {
                let rank = index + 1;
                let dex_name = pair.dex_id.clone();
                let liquidity_str = format_liquidity(pair.liquidity.as_ref());
                let pool_addr = &pair.pair_address;
                
                println!("{:<5} {:<20} {:<20} {:<50}", 
                    rank, 
                    dex_name, 
                    liquidity_str, 
                    pool_addr
                );
            }
            
            println!("\n{}", "=".repeat(100));
            println!("\nToken Pair Details:");
            if let Some(first_pair) = top_pairs.first() {
                println!("  Token 1: {} ({})", 
                    first_pair.base_token.symbol.as_ref().unwrap_or(&"Unknown".to_string()),
                    first_pair.base_token.address
                );
                println!("  Token 2: {} ({})", 
                    first_pair.quote_token.symbol.as_ref().unwrap_or(&"Unknown".to_string()),
                    first_pair.quote_token.address
                );
            }
        }
        (Err(e), _) | (_, Err(e)) => {
            eprintln!("Error fetching data: {}", e);
            println!("Failed to fetch liquidity pool information.");
        }
    }
    
    Ok(())
}


// ============================================================================
// --- ENHANCED OPTION 8: POOL DISCOVERY FOR ARBITRAGE (UP TO 10 POOLS) ---
// ============================================================================

/// Configuration for pool discovery
#[derive(Debug, Clone)]
pub struct PoolDiscoveryConfig {
    pub max_pools: usize,
    pub min_liquidity_usd: f64,
    pub only_working_dexs: bool,
}

impl Default for PoolDiscoveryConfig {
    fn default() -> Self {
        Self {
            max_pools: 10,
            min_liquidity_usd: 100_000.0,
            only_working_dexs: true,
        }
    }
}

/// Enhanced pool discovery result with full metadata
#[derive(Debug, Clone)]
pub struct DiscoveredPool {
    pub dex_name: String,
    pub pool_address: String,
    pub liquidity_usd: f64,
    pub dex_type: String,
    pub base_token: String,
    pub quote_token: String,
}

/// Get top liquid pairs with minimum liquidity threshold
fn get_top_liquid_pairs_filtered(
    mut pairs: Vec<DexScreenerPair>, 
    max_limit: usize,
    min_liquidity_usd: f64,
) -> Vec<DexScreenerPair> {
    
    // Sort by liquidity (descending)
    pairs.sort_by(|a, b| {
        let liq_a = a.liquidity. as_ref().and_then(|l| l. usd). unwrap_or(0.0);
        let liq_b = b.liquidity.as_ref().and_then(|l| l.usd).unwrap_or(0.0);
        liq_b.partial_cmp(&liq_a). unwrap()
    });
    
    // Filter by minimum liquidity and take max_limit
    pairs.into_iter()
        .filter(|pair| {
            let liquidity = pair.liquidity
                .as_ref()
                .and_then(|l| l.usd)
                . unwrap_or(0.0);
            
            liquidity >= min_liquidity_usd
        })
        .take(max_limit)
        .collect()
}


/// Filter pairs to only include DEXs with working parsers - EXPANDED
fn filter_working_dexs(pairs: Vec<DexScreenerPair>) -> Vec<DexScreenerPair> {
// ALL POPULAR DEXs - Comprehensive list for 2024
let working_dex_ids = vec![
        // === RAYDIUM ===
        "raydium",
        "raydium-clmm",
        "raydium_clmm",
        "raydium-amm",
        "raydium_amm",
        "raydium-cpmm",
        "raydium_cpmm",

        // === ORCA ===
        "orca",
        "orca-v2",
        "orca_v2",
        "whirlpool",

        // === METEORA ===
        "meteora",
        "meteora-dlmm",
        "meteora_dlmm",
        "meteora-damm",
        "meteora_damm",
        "meteora-damm-v1",
        "meteora_damm_v1",
        "meteora-damm-v2",
        "meteora_damm_v2",
        "meteora-dbc",
        "meteora_dbc",

        // === PUMP.FUN ===
        "pumpfun",
        "pump-fun",
        "pump_fun",
        "pumpswap",

        // === JUPITER ===
        "jupiter",

        // === PHOENIX ===
        "phoenix",

        // === LIFINITY ===
        "lifinity",
        "lifinity-v2",
        "lifinity_v2",

        // === OPENBOOK ===
        "openbook",
        "openbook-v2",
        "openbook_v2",

        // === FLUXBEAM ===
        "fluxbeam",

        // === INVARIANT ===
        "invariant",

        // === GOOSEFX ===
        "goosefx",

        // === SAROS ===
        "saros",

        // === ALDRIN ===
        "aldrin",

        // === CREMA ===
        "crema",

        // === CROPPER ===
        "cropper",

        // === STEPN ===
        "stepn",

        // === SABER ===
        "saber",
    ];

    let filtered_pairs: Vec<DexScreenerPair> = pairs
        .into_iter()
        .filter(|pair| {
            let dex_id_lower = pair.dex_id.to_lowercase();

            // keep only pools whose dex_id contains one of the working ids
            working_dex_ids
                .iter()
                .any(|&working| dex_id_lower.contains(working))
        })
        .collect();

    filtered_pairs
}


/// Get DEX type identifier for parser routing - EXPANDED
fn get_dex_type(dex_name: &str) -> String {
    let name_lower = dex_name.to_lowercase();
    
    // Raydium
    if name_lower.contains("raydium") && name_lower.contains("clmm") {
        "raydium_clmm". to_string()
    } else if name_lower.contains("raydium") && name_lower.contains("cpmm") {
        "raydium_cpmm". to_string()
    } else if name_lower.contains("raydium") {
        "raydium_amm".to_string()
    }
    // Orca
    else if name_lower.contains("orca") && name_lower.contains("whirlpool") {
        "orca_whirlpool".to_string()
    } else if name_lower.contains("orca") {
        "orca_v2".to_string()
    }
    // Meteora
    else if name_lower. contains("meteora") && name_lower.contains("dlmm") {
        "meteora_dlmm".to_string()
    } else if name_lower.contains("meteora") && name_lower.contains("dbc") {
        "meteora_dbc".to_string()
    } else if name_lower.contains("meteora") && name_lower.contains("v2") {
        "meteora_damm_v2". to_string()
    } else if name_lower.contains("meteora") {
        "meteora_damm".to_string()
    }
    // Pump.fun
    else if name_lower. contains("pump") {
        "pumpfun".to_string()
    }
    // Other DEXs
    else if name_lower. contains("phoenix") {
        "phoenix".to_string()
    } else if name_lower.contains("lifinity") {
        "lifinity". to_string()
    } else if name_lower.contains("openbook") {
        "openbook". to_string()
    } else if name_lower.contains("fluxbeam") {
        "fluxbeam".to_string()
    } else {
        "unknown". to_string()
    }
}

/// Main enhanced pool discovery function for arbitrage
pub async fn discover_pools_for_arbitrage(
    token1: &str,
    token2: &str,
    config: PoolDiscoveryConfig,
) -> Result<Vec<DiscoveredPool>> {
    
    println!("\n");
    println!("   ENHANCED POOL DISCOVERY (Option 8)            ");
    println!("");
    println!("   Token Pair:");
    println!("     Token 1: {}.. .", &token1[..16.min(token1.len())]);
    println!("     Token 2: {}...", &token2[..16.min(token2.len())]);
    println!("    Configuration:");
    println!("     Max pools: {}", config.max_pools);
    println!("     Min liquidity: ${:.0}", config.min_liquidity_usd);
    println!("     Filter working DEXs: {}", config. only_working_dexs);
    println!("\n");
    
    println!(" Step 1: Fetching pools from DexScreener...");
    let pairs1_result = get_pairs_for_token(token1). await;
    let pairs2_result = get_pairs_for_token(token2).await;
    
    match (pairs1_result, pairs2_result) {
        (Ok(pairs1), Ok(pairs2)) => {
            let mut all_pairs = pairs1;
            all_pairs.extend(pairs2);
            
            println!("    Fetched {} total pairs", all_pairs.len());
            
            println!("\n Step 2: Filtering for exact token pair match...");
            let matching_pairs = find_matching_pairs(token1, token2, all_pairs);
            println!("    Found {} matching pairs", matching_pairs. len());
            
            if matching_pairs.is_empty() {
                println!("\n  No pools found for this token pair");
                return Ok(Vec::new());
            }
            
            let filtered_pairs = if config.only_working_dexs {
                println!("\n Step 3: Filtering to working DEXs...");
                let working = filter_working_dexs(matching_pairs);
                println! ("    Filtered to {} pools", working.len());
                working
            } else {
                matching_pairs
            };
            
            if filtered_pairs.is_empty() {
                println!("\n  No pools with working parsers found");
                return Ok(Vec::new());
            }
            
            println!("\n Step 4: Applying liquidity filter (${:.0} min)...", 
         config.min_liquidity_usd);
            let top_pools = get_top_liquid_pairs_filtered(
                filtered_pairs,
                config.max_pools,
                config.min_liquidity_usd,
            );
            
            if top_pools.is_empty() {
                println!("\n  No pools meet minimum liquidity");
                return Ok(Vec::new());
            }
            
            println!("    Selected {} qualifying pools", top_pools.len());
            
            let mut results: Vec<DiscoveredPool> = top_pools
                .into_iter()
                .map(|pair| {
                    let dex_name = normalize_dex_name(&pair. dex_id);
                    let dex_type = get_dex_type(&dex_name);
                    let liquidity_usd = pair.liquidity
                        .as_ref()
                        .and_then(|l| l.usd)
                        .unwrap_or(0.0);
                    
                    DiscoveredPool {
                        dex_name,
                        pool_address: pair.pair_address,
                        liquidity_usd,
                        dex_type,
                        base_token: pair.base_token. address,
                        quote_token: pair.quote_token.address,
                    }
                })
                .collect();
            
            // Deduplicate by pool address
            let original_count = results.len();
            let mut seen_addresses = std::collections::HashSet::new();
            results.retain(|pool| {
                if seen_addresses.contains(&pool.pool_address) {
                    false
                } else {
                    seen_addresses.insert(pool.pool_address.clone());
                    true
                }
            });
            if results.len() < original_count {
                println!("    Removed {} duplicate(s), {} unique pools", 
                    original_count - results.len(), results.len());
            }
            
            println!("\n");
            println!("              DISCOVERED POOLS (TOP {} BY LIQUIDITY)              ", results.len());
            println! ("");
            
            for (i, pool) in results.iter().enumerate() {
                println! (" {:2}. {:<25} ${:>12.0} {:16}...  ",         
                i + 1,
                         if pool.dex_name.len() > 25 { 
                             format!("{}...", &pool. dex_name[..22]) 
                         } else { 
                             pool.dex_name.clone() 
                         },
                         pool.liquidity_usd,
                         &pool.pool_address[..16]);
            }
            
            println!("");
            
            let total_liquidity: f64 = results.iter(). map(|p| p.liquidity_usd).sum();
            println!("\n Summary: {} pools | ${:.0} total liquidity\n",         
            results. len(), total_liquidity);
            
            Ok(results)
        }
        (Err(e), _) | (_, Err(e)) => {
            eprintln!("\n Error fetching from DexScreener: {}", e);
            Ok(Vec::new())
        }
    }
}

/// Interactive pool discovery for manual selection
pub async fn discover_pools_interactive() -> Result<Vec<DiscoveredPool>> {
    println! ("\n");
    println!("   INTERACTIVE POOL DISCOVERY (Enhanced)         ");
    println!("\n");
    
    print!("Enter Token 1 (base) mint address: ");
    io::stdout().flush()?;
    let mut token1 = String::new();
    io::stdin().read_line(&mut token1)?;
    let token1 = token1.trim(). to_string();
    
    print!("Enter Token 2 (quote) mint address: ");
    io::stdout().flush()? ;
    let mut token2 = String::new();
    io::stdin().read_line(&mut token2)?;
    let token2 = token2.trim(). to_string();
    
    print!("\nMax pools to discover (1-20, default 10): ");
    io::stdout().flush()?;
    let mut max_input = String::new();
    io::stdin().read_line(&mut max_input)?;
    let max_pools: usize = max_input.trim().parse(). unwrap_or(10). clamp(1, 20);
    
    print!("Min liquidity in USD (default 100,000): ");
    io::stdout().flush()?;
    let mut min_input = String::new();
    io::stdin().read_line(&mut min_input)?;
    // Remove commas from input (e.g., "10,000" -> "10000")
    let cleaned_input = min_input.trim().replace(",", "");
    let min_liquidity: f64 = cleaned_input.parse().unwrap_or(100_000.0);
    
    print!("Only working DEXs?  (Y/n): ");
    io::stdout().flush()?;
    let mut filter_input = String::new();
    io::stdin().read_line(&mut filter_input)?;
    let only_working = ! filter_input.trim().eq_ignore_ascii_case("n");
    
    let config = PoolDiscoveryConfig {
        max_pools,
        min_liquidity_usd: min_liquidity,
        only_working_dexs: only_working,
    };
    
    discover_pools_for_arbitrage(&token1, &token2, config).await
}


/// Remove duplicate pool addresses from the list
fn deduplicate_pools(pools: &mut Vec<(String, String)>) {
    let mut seen = HashSet::new();
    let original_len = pools.len();
    
    pools.retain(|(dex, addr)| {
        if seen.contains(addr) {
            println!("[!] Skipping duplicate pool: {}... ({})", &addr[..12], dex);
            false
        } else {
            seen.insert(addr.clone());
            true
        }
    });
    
    let removed = original_len - pools.len();
    if removed > 0 {
        println!("[INFO] Removed {} duplicate pool(s)", removed);
        println!("[INFO] Using {} unique pools", pools.len());
    }
}


/// Fetch pool addresses for a token pair from DexScreener for WebSocket subscriptions
/// Returns a vector of (dex_name, pool_address) tuples
/// FILTERED: Only returns working parsers (Orca, Raydium)
async fn fetch_pools_for_pair(token1: &str, token2: &str) -> Result<Vec<(String, String)>> {
    println!("\n Fetching liquidity pools from DexScreener...");
    
    // Fetch pairs for both tokens
    let pairs1_result = get_pairs_for_token(token1).await;
    let pairs2_result = get_pairs_for_token(token2).await;
    
    match (pairs1_result, pairs2_result) {
        (Ok(pairs1), Ok(pairs2)) => {
            // Combine pairs
            let mut all_pairs = pairs1;
            all_pairs.extend(pairs2);
            
            // Find pairs that match both tokens
            let matching_pairs = find_matching_pairs(token1, token2, all_pairs);
            
            if matching_pairs.is_empty() {
                println!("  No liquidity pools found for this token pair on DexScreener.");
                return Ok(Vec::new());
            }
            
        // Get TOP 10 pools by liquidity (before filtering)
let top_pairs = get_top_liquid_pairs(matching_pairs, 10);

// Save count BEFORE moving top_pairs
let all_count = top_pairs.len();

// ===== FILTER TO ONLY WORKING DEX PARSERS =====
let working_dex_ids = vec![
    // Orca
    "orca", 
    // Raydium
    "raydium", "raydium-clmm", "raydium_clmm",
    // Meteora - All Pool Types
    "meteora", "meteora-dlmm", "meteora_dlmm", 
    "meteora-amm", "meteora_amm",
    "meteora-damm", "meteora_damm",
    "meteora-damm-v1", "meteora_damm_v1",
    "meteora-damm-v2", "meteora_damm_v2",
    "meteora-cp-amm", "meteora_cp_amm",
    "meteora-memecoin", "meteora_memecoin",
];

let filtered_pairs: Vec<DexScreenerPair> = top_pairs
    . into_iter()  // Now we can safely move
    .filter(|pair| {
        let dex_id_lower = pair.dex_id.to_lowercase();
        working_dex_ids.iter(). any(|&working| dex_id_lower.contains(working))
    })
    .collect();

if filtered_pairs.is_empty() {
    println!("  No pools found with working parsers");
    println!("  Supported DEXs: Orca, Raydium, Meteora DLMM");
    return Ok(Vec::new());
}

// Limit to top 5 AFTER filtering
let final_pairs: Vec<DexScreenerPair> = filtered_pairs. into_iter().take(5).collect();

println!(" Top {} Pools (Working Parsers Only):\n", final_pairs.len());
println!("{:<5} {:<25} {:<20} {:<50}", "Rank", "DEX", "Liquidity", "Pool Address");
println!("{}", "=".repeat(105));

let mut pools: Vec<(String, String)> = Vec::new();

for (index, pair) in final_pairs. iter().enumerate() {
    let rank = index + 1;
    let dex_name = normalize_dex_name(&pair. dex_id);
    let liquidity_str = format_liquidity(pair.liquidity. as_ref());
    let pool_addr = &pair.pair_address;
    
    println!("{:<5} {:<25} {:<20} {:<50}", 
        rank, 
        &dex_name, 
        liquidity_str, 
        pool_addr
    );
    
    pools.push((dex_name, pool_addr.clone()));
}

println!("{}", "=".repeat(105));

// Show token details
if let Some(first_pair) = final_pairs.first() {
    println!("\n Token Pair:");
    println!("   Base:  {} ({})", 
        first_pair.base_token. symbol. as_ref().unwrap_or(&"Unknown". to_string()),
        &first_pair.base_token. address[..16]
    );
    println! ("   Quote: {} ({})", 
        first_pair.quote_token.symbol.as_ref().unwrap_or(&"Unknown".to_string()),
        &first_pair.quote_token. address[..16]
    );
}

// Show which DEXs were filtered out (using saved all_count)
let filtered_count = all_count - final_pairs.len();
if filtered_count > 0 {
    println!("\n  Filtered out {} pool(s) with unsupported parsers", filtered_count);
    println!("   Supported: Orca Whirlpool, Raydium CLMM, Raydium AMM V4, Meteora DLMM");
}

Ok(pools)
        }
        (Err(e), _) | (_, Err(e)) => {
            eprintln!(" Error fetching pool data: {}", e);
            Ok(Vec::new())
        }
    }
}

/// Normalize DEX names - EXPANDED for all popular DEXs
fn normalize_dex_name(dex_id: &str) -> String {
    match dex_id. to_lowercase().as_str() {
        // === RAYDIUM ===
        "raydium" => "Raydium AMM V4".to_string(),
        "raydium_amm" | "raydium-amm" => "Raydium AMM V4".to_string(),
        "raydium_clmm" | "raydium-clmm" => "Raydium CLMM". to_string(),
        "raydium_cpmm" | "raydium-cpmm" => "Raydium CPMM".to_string(),
        
        // === ORCA ===
        "orca" => "Orca". to_string(),
        "orca_v2" | "orca-v2" | "whirlpool" => "Orca Whirlpool".to_string(),
        
        // === METEORA ===
        "meteora" => "Meteora". to_string(),
        "meteora_dlmm" | "meteora-dlmm" => "Meteora DLMM".to_string(),
        "meteora_damm" | "meteora-damm" => "Meteora DAMM".to_string(),
        "meteora_damm_v1" | "meteora-damm-v1" => "Meteora DAMM V1".to_string(),
        "meteora_damm_v2" | "meteora-damm-v2" => "Meteora DAMM V2". to_string(),
        "meteora_dbc" | "meteora-dbc" => "Meteora DBC".to_string(),
        
        // === PUMP.FUN ===
        "pumpfun" | "pump-fun" | "pump_fun" | "pump.fun" => "Pump. fun".to_string(),
        "pumpswap" => "PumpSwap".to_string(),
        
        // === OTHER POPULAR DEXs ===
        "jupiter" => "Jupiter".to_string(),
        "phoenix" => "Phoenix".to_string(),
        "lifinity" | "lifinity_v2" | "lifinity-v2" => "Lifinity V2".to_string(),
        "openbook" | "openbook_v2" | "openbook-v2" => "OpenBook V2".to_string(),
        "fluxbeam" => "FluxBeam".to_string(),
        "invariant" => "Invariant".to_string(),
        "goosefx" => "GooseFX".to_string(),
        "saros" => "Saros".to_string(),
        "aldrin" => "Aldrin". to_string(),
        "crema" => "Crema".to_string(),
        "cropper" => "Cropper".to_string(),
        "stepn" => "StepN".to_string(),
        "saber" => "Saber".to_string(),
        
        // Fallback: Capitalize first letter
        other => {
            other.split(&['-', '_'][..])
                . map(|word| {
                    let mut chars = word. chars();
                    match chars.next() {
                        None => String::new(),
                        Some(first) => first. to_uppercase().chain(chars).collect(),
                    }
                })
                . collect::<Vec<_>>()
                .join(" ")
        }
    }
}

// ============================================================================
// --- UNIVERSAL POOL PARSERS (Work with Any Token Pair) ---
// ============================================================================

/// Identify pool type from owner program - EXPANDED
fn identify_pool_type(owner: &str, size: usize) -> &'static str {
    match owner {
        // === RAYDIUM ===
        "675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8" => "Raydium AMM V4",
        "CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C" => "Raydium CPMM",
        "CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK" => "Raydium CLMM",
        "5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h" => "Raydium Stable Swap",
        
        // === ORCA ===
        "whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc" => "Orca Whirlpool",
        
        // === METEORA ===
        "LBUZKhRxPF3XUpBCjp4YzTKgLccjZhTSDM9YuVaPwxo" => "Meteora DLMM",
        "Eo7WjKq67rjJQSZxS6z3YkapzY3eMj6Xy8X5EQVn5UaB" => "Meteora DAMM V1",
        "cpamdpZCGKUy5JxQXB4dcpGPiikHawvSWAd6mEn1sGG" => "Meteora DAMM V2",
        "dbcij3LWUppWqq96dh6gJWwBifmcGfLSB5D4DuSMaqN" => "Meteora DBC",
        
        // === PUMP.FUN ===
        "6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P" => "Pump.fun Bonding Curve",
        
        // === PHOENIX ===
        "PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY" => "Phoenix",
        
        // === LIFINITY ===
        "2wT8Yq49kHgDzXuPxZSaeLaH1qbmGXtEyPy64bL7aD3c" => "Lifinity V2",
        
        // === OPENBOOK ===
        "opnb2LAfJYbRMAHHvqjCwQxanZn7ReEHp1k81EQfH" => "OpenBook V2",
        
        // === FLUXBEAM ===
        "FLUXubRmkEi2q6K3Y9kBPg9248ggaZVsoSFhtJHSrm1X" => "FluxBeam",
        
        // Fallback by size
        _ => match size {
            700..=800 => "Raydium AMM V4 (by size)",
            1500..=1600 => "Raydium CLMM (by size)",
            600..=699 => "Orca Whirlpool (by size)",
            850..=950 => "Meteora DAMM V1 (by size)",
            1050..=1200 => "Meteora DLMM (by size)",
            200..=400 => "Meteora DAMM V2 (by size)",
            _ => "Unknown",
        }
    }
}


/// Identify pool type from data patterns
fn identify_pool_type_from_data(data: &[u8]) -> &'static str {
    if data.len() < 8 {
        return "unknown";
    }
    
    let discriminator = &data[0..8];
    
    match discriminator {
        // Orca
        [0x3f, 0x95, 0xd1, 0x0c, 0xe1, 0x80, 0x63, 0x09] => "orca_whirlpool",
        // Meteora DLMM discriminators
        [0xf1, 0x9a, 0x6d, 0x04, 0x11, 0xb1, 0x6d, 0xbc] => "meteora_dlmm",
        [0x21, 0x0b, 0x31, 0x62, 0xb5, 0x65, 0xb1, 0x0d] => "meteora_dlmm",
        // Raydium CLMM
        [0xf7, 0xed, 0xe3, 0xf5, 0xd7, 0xc3, 0xde, 0x46] => "raydium_clmm",
        // Meteora DAMM V1 discriminators
        [0x62, 0x1e, 0x5f, 0x4e, 0xd7, 0x8c, 0x02, 0x3e] => "meteora_damm_v1",
        [0x5d, 0x8f, 0x91, 0x2a, 0xc4, 0x7b, 0x88, 0x2e] => "meteora_damm_v1",
        // Note: DAMM V2 discriminators may vary - identify by program owner instead
        _ => {
            match data.len() {
                700..=800 => "Raydium AMM V4 (by size)",
                1500..=1600 => "Raydium CLMM (by size)",
                600..=699 => "Orca Whirlpool (by size)",
                850..=950 => "meteora_damm_v1",
                1050..=1200 => "meteora_dlmm",
                200..=400 => "meteora_damm_v2",
                _ => "unknown"
            }
        }
    }
}

/// Main universal parser - routes to specific parser based on pool type
async fn parse_pool_universal(
    data: &[u8],
    dex_name: &str,
    pool_address: &str,
    base_decimals: u8,
    quote_decimals: u8,
    reference_price: f64,
    pair_name: &str,
    token_a_mint: &str,  //  ADD THIS PARAMETER
    token_b_mint: &str,  //  ADD THIS PARAMETER
    rpc: &AsyncRpcClient,
) -> Option<EnhancedPriceUpdate> {
    let pool_type = identify_pool_type_from_data(data);
    
    println!("   Detected pool type: {}", pool_type);
    println!("   Pair: {}", pair_name);
    println!("   Decimals: {} / {}", base_decimals, quote_decimals);
    if reference_price > 0.0 {
        println!("   Reference price: {:.8}", reference_price);
    }
    
    match pool_type {
        "raydium_amm_v4" => {
            parse_raydium_amm_universal(data, dex_name, pool_address, base_decimals, quote_decimals, reference_price, pair_name, rpc).await
        }
        "raydium_clmm" | "orca_whirlpool" => {
            parse_clmm_universal(data, dex_name, pool_address, base_decimals, quote_decimals, reference_price, pair_name). await
        }
        // Meteora DLMM (Dynamic Liquidity Market Maker)
        "meteora_dlmm" => {
            println!("   [Meteora DLMM] Routing to DLMM parser...");
            parse_meteora_binary(data, dex_name, pool_address, token_a_mint, token_b_mint, rpc).await
        }
        // Meteora DAMM V1 (Dynamic AMM V1 / Legacy)
        "meteora_damm_v1" | "meteora_amm" => {
            println!("   [Meteora DAMM V1] Routing to DAMM V1 parser...");
            parse_meteora_binary(data, dex_name, pool_address, token_a_mint, token_b_mint, rpc).await
        }
        // Meteora DAMM V2 (Dynamic AMM V2 / CP-AMM)
        "meteora_damm_v2" | "meteora_cp_amm" | "meteora_memecoin" => {
            println!("   [Meteora DAMM V2] Routing to DAMM V2 parser...");
            parse_meteora_binary(data, dex_name, pool_address, token_a_mint, token_b_mint, rpc).await
        }
        _ => {
            println! ("   Unknown pool type, trying all parsers...");
            try_all_parsers_universal(data, dex_name, pool_address, base_decimals, quote_decimals, reference_price, pair_name, token_a_mint, token_b_mint, rpc).await
        }
    }
}


/// Universal Raydium AMM parser - fetches actual vault balances
async fn parse_raydium_amm_universal(
    data: &[u8],
    dex_name: &str,
    pool_address: &str,
    base_decimals: u8,
    quote_decimals: u8,
    reference_price: f64,
    pair_name: &str,
    rpc: &AsyncRpcClient,
) -> Option<EnhancedPriceUpdate> {
    println!("   [Raydium AMM] Parsing for {}...", pair_name);
    
    if data.len() < 400 {
        println!("   [X] Data too small: {}", data.len());
        return None;
    }
    
    // Try multiple vault offset strategies
    let vault_offsets = [
        (336, 368, "Standard V4"),
        (400, 432, "Extended V4"),
        (72, 104, "Legacy V4"),
        (264, 296, "Alt V4"),
    ];
    
    for (base_offset, quote_offset, strategy) in vault_offsets {
        if base_offset + 32 > data.len() || quote_offset + 32 > data. len() {
            continue;
        }
        
        let base_vault_bytes = &data[base_offset..base_offset + 32];
        let quote_vault_bytes = &data[quote_offset..quote_offset + 32];
        
        let base_vault = match Pubkey::try_from(base_vault_bytes) {
            Ok(pk) if pk != Pubkey::default() => pk,
            _ => continue,
        };
        
        let quote_vault = match Pubkey::try_from(quote_vault_bytes) {
            Ok(pk) if pk != Pubkey::default() => pk,
            _ => continue,
        };
        
        println!("   [{}] Trying vault offsets {}/{}", strategy, base_offset, quote_offset);
        
        // Fetch actual token balances from vaults
        let base_balance = match rpc.get_token_account_balance(&base_vault). await {
            Ok(bal) => bal.amount. parse::<u64>().unwrap_or(0),
            Err(_) => continue,
        };
        
        let quote_balance = match rpc.get_token_account_balance(&quote_vault).await {
            Ok(bal) => bal. amount.parse::<u64>().unwrap_or(0),
            Err(_) => continue,
        };
        
        if base_balance == 0 || quote_balance == 0 {
            continue;
        }
        
        // Calculate price using dynamic decimals
        let base_amount = base_balance as f64 / 10_f64.powi(base_decimals as i32);
        let quote_amount = quote_balance as f64 / 10_f64.powi(quote_decimals as i32);
        let price = quote_amount / base_amount;
        
        println!("      Base: {:.6}, Quote: {:.6}, Price: {:.8}", base_amount, quote_amount, price);

        // Validate against reference price if available
        if reference_price > 0.0 {
            let deviation = ((price - reference_price) / reference_price). abs();
            println!("      Deviation: {:.2}%", deviation * 100.0);
            if deviation > 0.5 {  // 50% max deviation
                continue;
            }
        }
        
        println!("   [OK] Valid price found: {:.8}", price);
        
        return Some(EnhancedPriceUpdate {
            dex: dex_name. to_string(),
            token_pair: pair_name.to_string(),
            price,
            timestamp: TokioInstant::now(),
            liquidity: Some(base_amount * price * 2.0),
            data_source: DataSource::WebSocket,
            pool_address: pool_address.to_string(),
            reserve_token_a: Some(base_balance),
            reserve_token_b: Some(quote_balance),
        });
    }
    
    None
}

/// Universal CLMM parser (sqrt_price based) - works for Raydium CLMM and Orca
async fn parse_clmm_universal(
    data: &[u8],
    dex_name: &str,
    pool_address: &str,
    base_decimals: u8,
    quote_decimals: u8,
    reference_price: f64,
    pair_name: &str,
) -> Option<EnhancedPriceUpdate> {
    println!("   [CLMM] Parsing sqrt_price for {}.. .", pair_name);
    
    let sqrt_price_offsets = [253, 245, 261, 269, 237, 229, 197, 205, 213, 65, 57, 73, 81, 89];
    
    let mut best_match: Option<(f64, f64, usize)> = None;
    let decimal_adj = 10_f64.powi((base_decimals as i32) - (quote_decimals as i32));
    
    for offset in sqrt_price_offsets {
        if let Some(sqrt_price_x64) = read_u128_le(data, offset) {
            if sqrt_price_x64 == 0 || sqrt_price_x64 > (1u128 << 127) {
                continue;
            }
            
            let sqrt_price = sqrt_price_x64 as f64 / ((1_u128 << 64) as f64);
            let raw_price = sqrt_price * sqrt_price;
            
            // Try both normal and inverted
            for (price, _desc) in [
                (raw_price * decimal_adj, "normal"),
                (decimal_adj / raw_price, "inverted"),
            ] {
                if price <= 0.0 || price. is_nan() || price.is_infinite() {
                    continue;
                }
                
                let deviation = if reference_price > 0.0 {
                    ((price - reference_price) / reference_price).abs()
                } else {
                    0.0
                };
                
                if reference_price > 0.0 && deviation < 0.5 {
                    if best_match.is_none() || deviation < best_match. unwrap().1 {
                        best_match = Some((price, deviation, offset));
                    }
                } else if reference_price == 0.0 && price > 0.0000001 && price < 1_000_000_000.0 {
                    best_match = Some((price, 0.0, offset));
                    break;
                }
            }
        }
    }
    
    if let Some((price, deviation, offset)) = best_match {
        println!("   [OK] Best price at offset {}: {:.8} (dev: {:.1}%)", offset, price, deviation * 100.0);
        
        return Some(EnhancedPriceUpdate {
            dex: dex_name.to_string(),
            token_pair: pair_name. to_string(),
            price,
            timestamp: TokioInstant::now(),
            liquidity: None,
            data_source: DataSource::WebSocket,
            pool_address: pool_address.to_string(),
            reserve_token_a: None,
            reserve_token_b: None,
        });
    }
    
    None
}

/// Universal AMM reserve scanner - finds reserve pairs in data
async fn parse_amm_reserves_universal(
    data: &[u8],
    dex_name: &str,
    pool_address: &str,
    base_decimals: u8,
    quote_decimals: u8,
    reference_price: f64,
    pair_name: &str,
) -> Option<EnhancedPriceUpdate> {
    println!("   [AMM Reserves] Scanning for {} reserves...", pair_name);
    
    let mut candidates: Vec<(usize, f64, u64, u64, f64)> = Vec::new();
    
    for offset in (8..data.len(). saturating_sub(16)).step_by(8) {
        if let (Some(val_a), Some(val_b)) = (read_u64_le(data, offset), read_u64_le(data, offset + 8)) {
            if val_a < 1000 || val_b < 1000 {
                continue;
            }
            if val_a > 1_000_000_000_000_000_000 || val_b > 1_000_000_000_000_000_000 {
                continue;
            }
            
            let reserve_a = val_a as f64 / 10_f64.powi(base_decimals as i32);
            let reserve_b = val_b as f64 / 10_f64.powi(quote_decimals as i32);
            
            // Skip very unbalanced reserves
            if reserve_a / reserve_b > 1_000_000.0 || reserve_b / reserve_a > 1_000_000.0 {    
            continue;
            }
            
            let price_normal = reserve_b / reserve_a;
            let price_inv = reserve_a / reserve_b;
            
            if reference_price > 0.0 {
                let dev_normal = ((price_normal - reference_price) / reference_price).abs();
                let dev_inv = ((price_inv - reference_price) / reference_price).abs();
                
                if dev_normal < 0.3 {
                    candidates. push((offset, price_normal, val_a, val_b, dev_normal));
                }
                if dev_inv < 0.3 {
                    candidates.push((offset, price_inv, val_b, val_a, dev_inv));
                }
            } else if reserve_a > 0.01 && reserve_b > 0.01 {
                candidates.push((offset, price_normal, val_a, val_b, 0.0));
            }
        }
    }
    
    if candidates.is_empty() {
        return None;
    }
    
    // Sort by deviation (best first)
    candidates.sort_by(|a, b| a.4.partial_cmp(&b.4). unwrap());
    
    let (offset, price, reserve_a, reserve_b, deviation) = candidates[0];
    println!("   [OK] Found at offset {}: {:.8} (dev: {:.1}%)", offset, price, deviation * 100.0);
    let base_amount = reserve_a as f64 / 10_f64. powi(base_decimals as i32);
    
    Some(EnhancedPriceUpdate {
        dex: dex_name. to_string(),
        token_pair: pair_name.to_string(),
        price,
        timestamp: TokioInstant::now(),
        liquidity: Some(base_amount * price * 2.0),
        data_source: DataSource::WebSocket,
        pool_address: pool_address.to_string(),
        reserve_token_a: Some(reserve_a),
        reserve_token_b: Some(reserve_b),
    })
}

/// Universal DLMM parser - works with Meteora DLMM
async fn parse_dlmm_universal(
    data: &[u8],
    dex_name: &str,
    pool_address: &str,
    base_decimals: u8,
    quote_decimals: u8,
    reference_price: f64,
    pair_name: &str,
) -> Option<EnhancedPriceUpdate> {
    println!("   [DLMM] Parsing bin parameters for {}...", pair_name);
    
    let mut candidates: Vec<(u16, i32, f64, f64)> = Vec::new();
    let decimal_adj = 10_f64. powi((base_decimals as i32) - (quote_decimals as i32));
    
    for bs_offset in (8..200).step_by(2) {
        if let Some(bin_step) = read_u16_le(data, bs_offset) {
            if bin_step == 0 || bin_step > 10000 {
                continue;
            }
            
            for aid_offset in ((bs_offset + 2). min(data.len())..((bs_offset + 40).min(data. len()))).step_by(4) {
                if let Some(active_id) = read_i32_le(data, aid_offset) {
                    if active_id == 0 || active_id. abs() > 100000 {
                        continue;
                    }
                    
                    let bin_step_decimal = bin_step as f64 / 10000.0;
                    let price_raw = (1.0 + bin_step_decimal).powi(active_id);
                    let price = price_raw * decimal_adj;
                    
                    if reference_price > 0.0 {
                        let deviation = ((price - reference_price) / reference_price).abs();
                        if deviation < 0.3 {
                            candidates.push((bin_step, active_id, price, deviation));
                        }
                    } else if price > 0.0000001 && price < 1_000_000_000.0 {
                        candidates.push((bin_step, active_id, price, 0.0));
                    }
                }
            }
        }
    }
    
    if candidates.is_empty() {
        return None;
    }
    
    candidates.sort_by(|a, b| a.3.partial_cmp(&b.3). unwrap());
    
    let (bin_step, active_id, price, deviation) = candidates[0];
    println! ("   [OK] Found: bin_step={}, active_id={} -> {:.8} (dev: {:.1}%)", 
        bin_step, active_id, price, deviation * 100.0);
    
    Some(EnhancedPriceUpdate {
        dex: dex_name. to_string(),
        token_pair: pair_name.to_string(),
        price,
        timestamp: TokioInstant::now(),
        liquidity: None,
        data_source: DataSource::WebSocket,
        pool_address: pool_address.to_string(),
        reserve_token_a: None,
        reserve_token_b: None,
    })
}

/// Try all parsers and return the best match

async fn try_all_parsers_universal(
    data: &[u8],
    dex_name: &str,
    pool_address: &str,
    base_decimals: u8,
    quote_decimals: u8,
    reference_price: f64,
    pair_name: &str,
    token_a_mint: &str,  //  ADD THIS
    token_b_mint: &str,  //  ADD THIS
    rpc: &AsyncRpcClient,
) -> Option<EnhancedPriceUpdate> {
    let mut results: Vec<(EnhancedPriceUpdate, f64)> = Vec::new();
    
    // Try each parser
    if let Some(update) = parse_raydium_amm_universal(data, dex_name, pool_address, base_decimals, quote_decimals, reference_price, pair_name, rpc). await {
        let dev = if reference_price > 0.0 { ((update.price - reference_price) / reference_price).abs() } else { 0.0 };
        results.push((update, dev));
    }
    
    if let Some(update) = parse_clmm_universal(data, dex_name, pool_address, base_decimals, quote_decimals, reference_price, pair_name).await {
        let dev = if reference_price > 0.0 { ((update.price - reference_price) / reference_price).abs() } else { 0.0 };
        results.push((update, dev));
    }
    
    if let Some(update) = parse_amm_reserves_universal(data, dex_name, pool_address, base_decimals, quote_decimals, reference_price, pair_name). await {
        let dev = if reference_price > 0.0 { ((update.price - reference_price) / reference_price).abs() } else { 0.0 };
        results.push((update, dev));
    }
    
    if let Some(update) = parse_dlmm_universal(data, dex_name, pool_address, base_decimals, quote_decimals, reference_price, pair_name).await {
        let dev = if reference_price > 0.0 { ((update.price - reference_price) / reference_price).abs() } else { 0.0 };
        results.push((update, dev));
    }
    
    //  ADD METEORA PARSER
    if let Some(update) = parse_meteora_binary(data, dex_name, pool_address, token_a_mint, token_b_mint, rpc).await {
        let dev = if reference_price > 0.0 { ((update.price - reference_price) / reference_price).abs() } else { 0.0 };
        results. push((update, dev));
    }
    
    if results.is_empty() {
        return None;
    }
    
    results.sort_by(|a, b| a.1.partial_cmp(&b.1).unwrap());
    println!("   [OK] Best from {} parsers: {:.8}", results.len(), results[0].0.price);
    
    Some(results. remove(0). 0)
}

/// Diagnostic scan when parsing fails
fn run_diagnostic_scan_universal(
    data: &[u8],
    base_decimals: u8,
    quote_decimals: u8,
    reference_price: f64,
    context: &TokenPairContext,
) {
    println!("\n[SCAN] DIAGNOSTIC SCAN FOR {}", context.pair_name);
    
    let decimal_adj = 10_f64.powi((base_decimals as i32) - (quote_decimals as i32));
    
    println!("\n   [sqrt_price candidates]");
    let mut found_sqrt = 0;
    for offset in (0..data.len(). saturating_sub(16)).step_by(8) {
        if let Some(val) = read_u128_le(data, offset) {
            if val > 0 && val < (1u128 << 100) {
                let sqrt_price = val as f64 / ((1_u128 << 64) as f64);
                let price = sqrt_price * sqrt_price * decimal_adj;
                
                if price > 0.0000001 && price < 1_000_000_000.0 {
                    let deviation = if reference_price > 0.0 {    
                    ((price - reference_price) / reference_price * 100.0). abs()
                    } else {
                        0.0
                    };
                    
                    if reference_price == 0.0 || deviation < 100.0 {
                        println!("      Offset {:4}: {:.8} {} (dev: {:.1}%)", 
                            offset, price, context.quote_token. symbol, deviation);
                        found_sqrt += 1;
                        if found_sqrt >= 10 { break; }
                    }
                }
            }
        }
    }
    
    println! ("\n   [Reserve pair candidates]");
    let mut found_reserves = 0;
    for offset in (0..data.len(). saturating_sub(16)).step_by(8) {
        if let (Some(a), Some(b)) = (read_u64_le(data, offset), read_u64_le(data, offset + 8)) {
            if a > 1_000_000 && b > 1_000_000 && a < 1_000_000_000_000_000 && b < 1_000_000_000_000_000 {
                let ra = a as f64 / 10_f64.powi(base_decimals as i32);
                let rb = b as f64 / 10_f64.powi(quote_decimals as i32);
                let price = rb / ra;
                
                if price > 0.0000001 && price < 1_000_000_000.0 {
                    let deviation = if reference_price > 0.0 {
                        ((price - reference_price) / reference_price * 100.0).abs()
                    } else {
                        0.0
                    };
                    
                    if reference_price == 0.0 || deviation < 100.0 {
                        println!("      Offset {:4}: {:.4} {} / {:.4} {} = {:.8} (dev: {:.1}%)",
                            offset, ra, context.base_token.symbol, rb, context.quote_token.symbol, price, deviation);
                        found_reserves += 1;
                        if found_reserves >= 10 { break; }
                    }
                }
            }
        }
    }
}


// ============================================================================
// --- OPTION 9: COMPREHENSIVE DEX PROGRAM ID REFERENCE ---
// ============================================================================

/// Display all supported DEX program IDs and official documentation links
async fn display_dex_program_ids() {
    println!("");
    println!("                    SOLANA DEX PROGRAM ID REFERENCE (2024)                      ");
    println!("");
    println!("  Complete listing of all major Solana DEX program addresses.                    ");
    println!("  Program IDs are permanent for each protocol version.                          ");
    println! ("");
    
    // ==================== RAYDIUM ====================
    println! ("\n");
    println!("   RAYDIUM                                                                      ");
    println!("");
    println!("  AMM V4 (Legacy):     675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8              ");
    println!("  Standard AMM (CPMM): CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C              ");
    println!("  CLMM:                CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK              ");
    println!("  Stable Swap:         5quBtoiQqxF9Jv6KYKctB59NT3gtJD2Y65kdnB1Uev3h              ");
    println!("  AMM Routing:         routeUGWgWzqBWFcrCfv8tritsqukccJPu3q5GPP3xS               ");
    println!("  Staking:             EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q              ");
    println!("  Farm Staking:        9KEPoZmtHUrBbhWN1v1KWLMkkvwY6WLtAVUCPRtRjP4z              ");
    println!("  LaunchLab:           LanMV9sAd7wArD4vJFi2qDdfnVhFxYSUg6eADduJ3uj               ");
    println!("");
    println!("  Docs:    https://docs.raydium.io                                               ");
    println!("  GitHub:  https://github.com/raydium-io/raydium-clmm                            ");
    println!("           https://github.com/raydium-io/raydium-amm                             ");
    println!("  Twitter: https://twitter. com/RaydiumProtocol                                   ");
    println!("");
    
    // ==================== ORCA ====================
    println!("\n");
    println!("   ORCA                                                                         ");
    println!("");
    println!("  Whirlpool:           whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc               ");
    println!("");
    println!("  Docs:    https://docs.orca.so                                                  ");
    println! ("  GitHub:  https://github. com/orca-so/whirlpools                                 ");
    println! ("  Twitter: https://twitter.com/orca_so                                           ");
    println!("");
    
    // ==================== METEORA ====================
    println!("\n");
    println!("   METEORA                                                                       ");
    println!("");
    println!("  DLMM:                LBUZKhRxPF3XUpBCjp4YzTKgLccjZhTSDM9YuVaPwxo               ");
    println!("  DAMM V2:             cpamdpZCGKUy5JxQXB4dcpGPiikHawvSWAd6mEn1sGG               ");
    println!("  DBC (Bonding Curve): dbcij3LWUppWqq96dh6gJWwBifmcGfLSB5D4DuSMaqN               ");
    println!("  DAMM V1 (Legacy):    Eo7WjKq67rjJQSZxS6z3YkapzY3eMj6Xy8X5EQVn5UaB              ");
    println!("");
    println!("  Docs:    https://docs.meteora.ag                                               ");
    println!("  GitHub:  https://github.com/MeteoraAg/dlmm-sdk                                 ");
    println!("  Twitter: https://twitter. com/MeteoraAG                                         ");
    println!("");
    
    // ==================== PUMP.FUN ====================
    println!("\n");
    println!("   PUMP. FUN                                                                     ");
    println!("");
    println!("  Bonding Curve:       6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P               ");
    println!("");
    println!("  Notes:                                                                          ");
    println!("   Tokens are created via bonding curve mechanism                               ");
    println!("   Upon graduation, tokens migrate to Raydium AMM or PumpSwap                   ");
    println!("   Each token has its own mint address (contract address)                       ");
    println!("   Migration pools use Raydium AMM V4: 675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24w...   ");
    println!("");
    println!("  Website: https://pump.fun                                                      ");
    println!("  Twitter: https://twitter.com/pumpdotfun                                        ");
    println!("");
    
    // ==================== JUPITER ====================
    println!("\n");
    println! ("   JUPITER (Aggregator)                                                         ");
    println!("");
    println!("  V6 Aggregator:       JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4                ");
    println!("  Limit Order V2:      j1o2qRpjcyUwEvwtcfhS9NCHT98QQRK2Q8WNdzCvaGp               ");
    println!("  DCA:                 DCA265Vj8a9CEuX1eb1LWRnDT7uK6q1xMipnNyatn23M               ");
    println!("  Perpetuals:          PERPHjGBqRHArX4DySjwM6UJHiR3sWAatqfdBS2qQJu                ");
    println!("");
    println!("  Docs:    https://station.jup.ag/docs                                           ");
    println!("  GitHub:  https://github.com/jup-ag                                             ");
    println!("  Twitter: https://twitter. com/JupiterExchange                                   ");
    println!("");
    
    // ==================== PHOENIX ====================
    println!("\n");
    println!("   PHOENIX (On-chain Orderbook)                                                 ");
    println!("");
    println!("  Program:             PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY               ");
    println!("");
    println! ("  Docs:    https://docs.ellipsis.finance/phoenix                                 ");
    println!("  GitHub:  https://github.com/Ellipsis-Labs/phoenix-v1                           ");
    println!("");
    
    // ==================== LIFINITY ====================
    println!("\n");
    println!("   LIFINITY (Proactive Market Maker)                                            ");
    println!("");
    println!("  V2:                  2wT8Yq49kHgDzXuPxZSaeLaH1qbmGXtEyPy64bL7aD3c               ");
    println!("");
    println! ("  Docs:    https://docs.lifinity.io                                              ");
    println!("  Twitter: https://twitter. com/Lifinity_io                                       ");
    println!("");
    
    // ==================== OPENBOOK ====================
    println!("\n");
    println!("   OPENBOOK (CLOB)                                                              ");
    println!("");
    println!("  V2:                  opnb2LAfJYbRMAHHvqjCwQxanZn7ReEHp1k81EQfH                  ");
    println!("  V1 (Serum):          srmqPvymJeFKQ4zGQed1GFppgkRHL9kaELCbyksJtPX                ");
    println!("");
    println!("  Docs:    https://docs.openbook.com                                             ");
    println!("  GitHub:  https://github.com/openbook-dex                                       ");
    println!("");
    
    // ==================== FLUXBEAM ====================
    println!("\n");
    println!("   FLUXBEAM                                                                      ");
    println!("");
    println!("  Program:             FLUXubRmkEi2q6K3Y9kBPg9248ggaZVsoSFhtJHSrm1X               ");
    println!("");
    println!("  Website: https://fluxbeam.xyz                                                  ");
    println! ("");
    
    // ==================== OTHER DEXs ====================
    println!("\n");
    println!("   OTHER POPULAR DEXs                                                           ");
    println!("");
    println!("  Invariant:           HyaB3W9q6XdA5xwpU4XnSZV94htfmbmqJXZcEbRaJutt               ");
    println!("  GooseFX:             GFXsSL5sSaDfNFQUYsHekbWBW1TsFdjDYzACh62tEHxn               ");
    println!("  Saber:               SSwpkEEcbUqx4vtoEByFjSkhKdCT862DNVb52nZg1UZ                ");
    println!("  Aldrin:              AMM55ShdkoGRB5jVYPjWziwk8m5MpwyDgsMWHaMSQWH6               ");
    println!("  Crema:               CLMM9tUoggJu2wagPkkqs9eFG4BWhVBZWkP1qv3Sp7tR               ");
    println!("  Cropper:             CTMAxxk34HjKWxQ3QLZK1HpaLXmBveao3ESePXbiyfzh               ");
    println!("");
    
    // ==================== POOL IDENTIFICATION BY SIZE ====================
    println! ("\n");
    println!("   POOL TYPE IDENTIFICATION BY DATA SIZE                                        ");
    println! ("");
    println! ("  Raydium AMM V4:      700 - 800  bytes                                          ");
    println!("  Raydium CLMM:        1500 - 1600 bytes                                         ");
    println!("  Orca Whirlpool:      600 - 699  bytes                                          ");
    println! ("  Meteora DLMM:        1050 - 1200 bytes                                         ");
    println!("  Meteora DAMM V1:     850 - 950  bytes                                          ");
    println! ("  Meteora DAMM V2:     200 - 400  bytes                                          ");
    println!("  Pump.fun (Bonding):  Variable (token-specific)                                 ");
    println!("");
    
    // ==================== QUICK REFERENCE TABLE ====================
    println! ("\n");
    println!("   QUICK REFERENCE TABLE                                                        ");
    println!("");
    println! (" DEX             Program ID                                         Type        ");
    println!("");
    println!(" Raydium AMM V4  675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8      AMM         ");
    println!(" Raydium CPMM    CPMMoo8L3F4NbTegBCKVNunggL7H1ZpdTHKxQB5qKP1C      AMM         ");
    println!(" Raydium CLMM    CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK      CLMM        ");
    println!(" Orca Whirlpool  whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc       CLMM        ");
    println!(" Meteora DLMM    LBUZKhRxPF3XUpBCjp4YzTKgLccjZhTSDM9YuVaPwxo       DLMM        ");
    println!(" Meteora DAMM    cpamdpZCGKUy5JxQXB4dcpGPiikHawvSWAd6mEn1sGG       AMM         ");
    println!(" Meteora DBC     dbcij3LWUppWqq96dh6gJWwBifmcGfLSB5D4DuSMaqN       Bonding     ");
    println!(" Pump.fun        6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P       Bonding     ");
    println!(" Jupiter V6      JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4       Aggregator  ");
    println!(" Phoenix         PhoeNiXZ8ByJGLkxNfZRnkUfjvmuYqLR89jjFHGqdXY       Orderbook   ");
    println!(" Lifinity V2     2wT8Yq49kHgDzXuPxZSaeLaH1qbmGXtEyPy64bL7aD3c      PMM         ");
    println!(" OpenBook V2     opnb2LAfJYbRMAHHvqjCwQxanZn7ReEHp1k81EQfH         CLOB        ");
    println!(" FluxBeam        FLUXubRmkEi2q6K3Y9kBPg9248ggaZVsoSFhtJHSrm1X      AMM         ");
    println!("");
    
    println!("\n Official Documentation Sources:");
    println! ("    Raydium:  https://docs. raydium.io/raydium/protocol/developers/addresses");
    println! ("    Meteora:  https://docs. meteora.ag/developer-guide/home");
    println! ("    Orca:     https://docs.orca. so");
    println!("    Jupiter:  https://station.jup.ag/docs");
    println!("    Pump.fun: https://pump.fun (token migration to Raydium)");
    println! ("");
}

// ============================================================================
// --- MAIN FUNCTION ---
// ============================================================================

#[tokio::main]
async fn main() -> Result<()> {
    println!("");
    println!("  SOLANA DEFI TOOLKIT (WebSocket Enhanced v2.0)    ");
    println!("");

    loop {
        println!("\n--- Main Menu ---");
        println!("1. Show SOL value in USDC (Live Quote)");
        println!("2. Check wallet value in SOL and USD (Requires Key)");
        println!("3. Compare SOL prices across DEXs (WebSocket Real-Time)");
        println!("4. Start WebSocket-Enhanced Arbitrage Scanner v2.0");
        println!("5. Start Ultra Swap Tool (Authenticated)");
        println!("6. Test RPC Latency (QuickNode vs Default)");
        println!("7. Debug Account Parsing (Test Mode)");
        println!("8. DEX Liquidity Pool Finder");
        println!("9. DEX Program ID Reference");
        println!("10. Exit");
        println!("");
        print!("Enter choice (1-10): ");
        io::stdout().flush()?;

        let mut choice = String::new();
        io::stdin().read_line(&mut choice)?;

        match choice.trim() {
            "1" => get_sol_price_handler().await?,
            "2" => check_wallet_value_handler().await?,
            "3" => {
    println!("\n");
    println!("   DEX PRICE COMPARISON (Dynamic Pool Discovery)           ");
    println!("");
    
    // Show current DEX Program IDs that will be used for price checks
    println!("  Checking supported DEX Program IDs for price parsing...\n");
    display_dex_program_ids().await;
    
    println!("\n  Press Enter to continue with price comparison...");
    let mut _pause = String::new();
    io::stdin().read_line(&mut _pause)?;
    
    // Token selection
    println!("\n Token Selection:");
    println!("1. SOL/USDC (default pools)");
    println!("2. Custom token pair (discover pools via DexScreener)");
    print!("\nChoice (1-2, or press Enter for SOL/USDC): ");
    io::stdout().flush()?;
    
    let mut token_choice = String::new();
    io::stdin().read_line(&mut token_choice)?;
    
    let price_cache = create_enhanced_price_cache();
    
    let (mut pools, base_mint, quote_mint) = match token_choice.trim() {
        "2" => {
            // Custom token pair - use enhanced pool discovery
            println!("\n");
            println!("                 CUSTOM TOKEN PAIR CONFIGURATION                 ");
            println!("\n");
            
            print!("Enter Token 1 (base) mint address: ");
            io::stdout().flush()?;
            let mut token1 = String::new();
            io::stdin().read_line(&mut token1)?;
            let token1 = token1.trim().to_string();
            
            print!("Enter Token 2 (quote) mint address: ");
            io::stdout().flush()?;
            let mut token2 = String::new();
            io::stdin().read_line(&mut token2)?;
            let token2 = token2.trim().to_string();
            
            // Pool discovery configuration (same as Option 4 and 8)
            print!("\nMax pools to monitor (1-20, default 10): ");
            io::stdout().flush()?;
            let mut max_input = String::new();
            io::stdin().read_line(&mut max_input)?;
            let max_pools: usize = max_input.trim().parse().unwrap_or(10).clamp(1, 20);
            
            print!("Min liquidity per pool in USD (default 10,000): ");
            io::stdout().flush()?;
            let mut min_input = String::new();
            io::stdin().read_line(&mut min_input)?;
            let cleaned_input = min_input.trim().replace(",", "");
            let min_liquidity: f64 = cleaned_input.parse().unwrap_or(10_000.0);
            
            let pool_config = PoolDiscoveryConfig {
                max_pools,
                min_liquidity_usd: min_liquidity,
                only_working_dexs: true,
            };
            
            // Use enhanced pool discovery (same as Option 4 and 8)
            let discovered = discover_pools_for_arbitrage(&token1, &token2, pool_config).await?;
            
            if discovered.is_empty() {
                println!("\n No pools found with working parsers.");
                println!("   Try lowering the minimum liquidity requirement.");
                println!("   Falling back to API-only mode (no WebSocket).");
                (Vec::new(), token1, token2)
            } else {
                // Convert DiscoveredPool to (String, String) format
                let pools: Vec<(String, String)> = discovered
                    .iter()
                    .map(|p| (p.dex_name.clone(), p.pool_address.clone()))
                    .collect();
                println!("\n Using {} pools with working parsers", pools.len());
                (pools, token1, token2)
            }
        },
        _ => {
            // Default: SOL/USDC - use enhanced pool discovery
            println!("\n");
            println!("                    SOL/USDC POOL DISCOVERY                       ");
            println!("\n");
            
            // Pool discovery configuration
            print!("Max pools to monitor (1-20, default 10): ");
            io::stdout().flush()?;
            let mut max_input = String::new();
            io::stdin().read_line(&mut max_input)?;
            let max_pools: usize = max_input.trim().parse().unwrap_or(10).clamp(1, 20);
            
            print!("Min liquidity per pool in USD (default 50,000): ");
            io::stdout().flush()?;
            let mut min_input = String::new();
            io::stdin().read_line(&mut min_input)?;
            let cleaned_input = min_input.trim().replace(",", "");
            let min_liquidity: f64 = cleaned_input.parse().unwrap_or(50_000.0);
            
            let pool_config = PoolDiscoveryConfig {
                max_pools,
                min_liquidity_usd: min_liquidity,
                only_working_dexs: true,
            };
            
            println!("\n Discovering SOL/USDC pools...");
            
            // Use enhanced pool discovery (same as Option 4 and 8)
            let discovered = discover_pools_for_arbitrage(SOL_MINT, USDC_MINT, pool_config).await?;
            
            if discovered.is_empty() {
                println!("\n  DexScreener unavailable. Using fallback pools.");
                
                // Fallback: Working parsers including Meteora
                let default_pools = vec![
                    ("Orca".to_string(), "HJPjoWUrhoZzkNfRpHuieeFk9WcZWjwy6PBjZ81ngndJ".to_string()),
                    ("Raydium".to_string(), "61R1ndXxvsWXXkWSyNkCxnzwd3zUNB8Q2ibmkiLPC8ht".to_string()),
                    ("Raydium".to_string(), "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2".to_string()),
                    ("Meteora".to_string(), "VANAy7EfFregN3N6vL3RXE8qKhdvua5eo71o8qmE76Z".to_string()),
                    ("Meteora".to_string(), "83v8iPyZihDEjDdY8RdZddyZNyUtXngz69Lgo9Kt5d6d".to_string()),
                ];
                
                println!("   Using {} verified fallback pools:", default_pools.len());
                for (dex, addr) in &default_pools {
                    println!("    {} ({}...)", dex, &addr[..12]);
                }
                
                (default_pools, SOL_MINT.to_string(), USDC_MINT.to_string())
            } else {
                // Convert DiscoveredPool to (String, String) format
                let pools: Vec<(String, String)> = discovered
                    .iter()
                    .map(|p| (p.dex_name.clone(), p.pool_address.clone()))
                    .collect();
                println!("\n Using {} pools from DexScreener", pools.len());
                (pools, SOL_MINT.to_string(), USDC_MINT.to_string())
            }
        }
    };
    
    // Deduplicate pools before creating subscription manager
    deduplicate_pools(&mut pools);
    
    // Safety check
    if pools.is_empty() {
        println!("\n No working pools available. Cannot start WebSocket monitoring.");
        println!("   Please try again or use a different token pair.");
        continue;
    }
    
    // Create subscription manager with discovered pools and token mints
    let discovered_pools = pools. clone();
    
    // Fetch token info for the base token
    let base_token_info = match search_token_with_fallback(&base_mint). await {
        Ok(info) => info,
        Err(_) => {
            // Create a default TokenInfo if search fails
            TokenInfo {
                id: base_mint.clone(),
                name: if base_mint == SOL_MINT { "Solana".to_string() } else { "Token".to_string() },
                symbol: if base_mint == SOL_MINT { "SOL".to_string() } else { "??? ".to_string() },
                decimals: if base_mint == SOL_MINT { 9 } else { 6 },
                logo_uri: None,
                tags: None,
                is_verified: None,
                usd_price: None,
                liquidity: None,
                holder_count: None,
            }
        }
    };
    
    // Create subscription manager
    let subscription_manager = if pools.is_empty() {
        EnhancedWebSocketSubscriptionManager::new(price_cache. clone())
    } else {
        EnhancedWebSocketSubscriptionManager::with_pools_and_tokens(
            price_cache.clone(), 
            pools, 
            &base_mint, 
            &quote_mint
        )
    };

    // Start subscriptions in background
    tokio::spawn(async move {
        subscription_manager.start(). await;
    });

    // Wait for warmup
    println!("\n Establishing WebSocket connections...");
    tokio::time::sleep(Duration::from_secs(3)).await;

    // Run enhanced ticker
    compare_all_dex_prices_handler_websocket_dynamic(
        price_cache, 
        &base_mint, 
        &quote_mint,
        base_token_info. clone(),
        discovered_pools,
    ).await? ;
}
            "4" => start_arbitrage_scan_handler().await?,
            "5" => start_ultra_swap_tool().await?,
            "6" => test_rpc_latency_handler().await?,
            "7" => {
    println!("\n");
    println!("   ENHANCED ACCOUNT PARSING DEBUG (Universal - Any Token) ");
    println!("");
    
    println!("\n Enter token pair to analyze (works with ANY tokens):");
    
    // Get base token
    print!("Base token mint address (or press Enter for SOL): ");
    io::stdout().flush()?;
    let mut token1_input = String::new();
    io::stdin().read_line(&mut token1_input)?;
    let token1 = if token1_input. trim().is_empty() {
        SOL_MINT. to_string()
    } else {
        token1_input.trim().to_string()
    };
    
    // Get quote token
    print!("Quote token mint address (or press Enter for USDC): ");
    io::stdout(). flush()?;
    let mut token2_input = String::new();
    io::stdin().read_line(&mut token2_input)?;
    let token2 = if token2_input.trim().is_empty() {
        USDC_MINT.to_string()
    } else {
        token2_input.trim().to_string()
    };
    
    // Fetch token info from Jupiter Ultra API
    println!("\n Fetching token information from Jupiter Ultra API...");
    
    let base_token_info = match fetch_token_info_ultra(&token1).await {
        Ok(info) => {
            display_token_info_ultra(&info);
            info
        }
        Err(e) => {
            println!("  Could not fetch base token info: {}", e);
            create_fallback_token_info(&token1, 9)
        }
    };
    
    let quote_token_info = match fetch_token_info_ultra(&token2).await {
        Ok(info) => {
            display_token_info_ultra(&info);
            info
        }
        Err(e) => {
            println! ("  Could not fetch quote token info: {}", e);
            create_fallback_token_info(&token2, 6)
        }
    };
    
    // Calculate expected price from USD values
    let expected_price = calculate_expected_price(&base_token_info, &quote_token_info);
    
    if let Some(price) = expected_price {
        println! ("\n EXPECTED PRICE RATIO (from Jupiter):");
        println! ("   1 {} = {:.8} {}", 
            base_token_info.symbol, 
            price, 
            quote_token_info.symbol);
        
        if let Some(base_usd) = base_token_info.usd_price {
            let price_fmt = if base_usd < 0.01 {
                format!("${:.10}", base_usd)
            } else {
                format!("${:.6}", base_usd)
            };
            println! ("   1 {} = {} USD", base_token_info.symbol, price_fmt);
        }
    }
    
    // Discover pools from DexScreener
    println! ("\n Discovering liquidity pools.. .");
    let discovered_pools = fetch_pools_for_pair(&token1, &token2). await?;
    
    if discovered_pools.is_empty() {
        println!(" No pools found for {} / {}", 
            base_token_info. symbol, quote_token_info. symbol);
        println!("\n Suggestions:");
        println! ("   - Check if the token addresses are correct");
        println!("   - This pair may not have direct liquidity pools");
        println! ("   - Try routing through SOL or USDC");
        continue;
    }
    
    // Display pools for selection
    println!("\n Select a pool to debug:");
    for (i, (dex_name, pool_addr)) in discovered_pools.iter().enumerate() {
          println!("   {}. {} ({}...)", i + 1, dex_name, &pool_addr[..16.min(pool_addr.len())]);
    }
    print!("\nChoice (1-{}): ", discovered_pools.len());
    io::stdout().flush()? ;
    
    let mut choice_input = String::new();
    io::stdin().read_line(&mut choice_input)?;
    
    let choice_num: usize = match choice_input.trim().parse() {
        Ok(n) if n >= 1 && n <= discovered_pools. len() => n,
        _ => {
            println!(" Invalid choice");
            continue;
        }
    };
    
    let (dex, pool) = &discovered_pools[choice_num - 1];
    
    // Create token pair context
    let pair_context = TokenPairContext {
        base_token: base_token_info. clone(),
        quote_token: quote_token_info.clone(),
        expected_price,
        pair_name: format! ("{}/{}", base_token_info. symbol, quote_token_info.symbol),
    };
    
    // Fetch account data
    println!("\n DEX: {}", dex);
    println!(" Pool: {}", pool);
    
    let client = AsyncRpcClient::new_with_commitment(
        QUICKNODE_RPC_URL. to_string(),
        CommitmentConfig::confirmed(),
    );
    
    let pubkey = Pubkey::from_str(pool)? ;
    let account = match client.get_account(&pubkey).await {
        Ok(acc) => acc,
        Err(e) => {
            println!(" Failed to fetch account: {}", e);
            continue;
        }
    };
    
    println!("\n ACCOUNT METADATA:");
    println! ("   Size:     {} bytes", account.data.len());
    println!("   Owner:    {}", account.owner);
    
    let pool_type = identify_pool_type(&account.owner. to_string(), account.data.len());
    println!("   Type:     {}", pool_type);
    
    // Show discriminator
    if account.data.len() >= 8 {
        println!("   Discriminator: {:02x? }", &account.data[0..8]);
    }
    
    // Show raw data
    println! ("\n RAW DATA (first 100 bytes):");
    for (i, chunk) in account.data.chunks(20).take(5).enumerate() {
        print!("   [{:03}]: ", i * 20);
        for byte in chunk {
            print!("{:02x} ", byte);
        }
        println! ();
    }
    
    // Parse with universal parser
    let base_decimals = pair_context.base_token.decimals as u8;
    let quote_decimals = pair_context. quote_token.decimals as u8;
    let reference_price = pair_context.expected_price.unwrap_or(0.0);
    
    println!("\n PARSING ATTEMPT:");
    println! ("   Using decimals: base={}, quote={}", base_decimals, quote_decimals);
    
    let parse_result = parse_pool_universal(
    &account.data,
    dex,
    pool,
    base_decimals,
    quote_decimals,
    reference_price,
    &pair_context.pair_name,
    &token1,  //  ADD THIS
    &token2,  //  ADD THIS
    &client,
).await;    
    match parse_result {
        Some(update) => {
            println!("\n PARSE SUCCESSFUL!");
            println!("");
            
            // Format price based on magnitude
            let price_str = if update.price < 0.0001 {
                format! ("{:.10} {}", update.price, pair_context.quote_token.symbol)
            } else if update.price < 1.0 {
                format!("{:.6} {}", update.price, pair_context.quote_token.symbol)
            } else {
                format!("{:.4} {}", update.price, pair_context.quote_token.symbol)
            };
            println! (" Parsed Price:    {:<42} ", price_str);
            
            if let Some(liq) = update. liquidity {
                println!(" Liquidity:       ${:<42} ", format_number_with_commas(liq));
            }
            
            // Compare with reference
            if reference_price > 0.0 {
                let deviation = ((update.price - reference_price) / reference_price * 100.0). abs();
                let status = if deviation < 1.0 { " Excellent" } 
                    else if deviation < 5.0 { " Good" }
                    else if deviation < 10.0 { " Acceptable" }
                    else { " Poor" };
                
                let ref_str = if reference_price < 0.0001 {
                    format!("{:.10} {}", reference_price, pair_context. quote_token.symbol)
                } else if reference_price < 1.0 {
                    format!("{:.6} {}", reference_price, pair_context. quote_token.symbol)
                } else {
                    format!("{:.4} {}", reference_price, pair_context. quote_token.symbol)
                };
                println!(" Expected:        {:<42} ", ref_str);
                println!(" Deviation:       {:<42} ", format! ("{:.2}% ({})", deviation, status));
            }
            
            // Show USD value if available
            if let Some(quote_usd) = pair_context. quote_token.usd_price {
                let price_in_usd = update.price * quote_usd;
                let usd_str = if price_in_usd < 0.01 {
                    format!("${:.10}", price_in_usd)
                } else {
                    format! ("${:.6}", price_in_usd)
                };
                println!(" USD Value:       {:<42} ", usd_str);
            }
            
            println!("");
        }
        None => {
            println!("\n PARSE FAILED");
            println!("   Running diagnostic scan for {} pair...", pair_context.pair_name);
            run_diagnostic_scan_universal(
                &account.data,
                base_decimals,
                quote_decimals,
                reference_price,
                &pair_context,
            );
        }
    }
}
            "8" => {
    println!("\n");
    println!("    DEX LIQUIDITY POOL FINDER (Enhanced)         ");
    println!("");
    println!("\nDiscovers liquidity pools for any token pair.");
    println!("Supports: Orca, Raydium, and Meteora (DLMM, DAMM V1, DAMM V2, Memecoin)");
    println!("Now supports up to 20 pools with liquidity filtering.\n");
    
    // Show current DEX Program IDs that will be used for pool identification
    println!("  Checking supported DEX Program IDs for pool discovery...\n");
    display_dex_program_ids().await;
    
    println!("\n  Press Enter to continue with pool discovery...");
    let mut _pause = String::new();
    io::stdin().read_line(&mut _pause)?;
    
    match discover_pools_interactive().await {
        Ok(pools) if ! pools.is_empty() => {
            println!("\n Discovery complete! Found {} pool(s)", pools.len());
        }
        Ok(_) => {
            println!("\n  No pools found");
        }
        Err(e) => {
            eprintln!("\n Error: {}", e);
        }
    }
}
            "9" => {
    println!("\n");
    println!("    DEX PROGRAM ID REFERENCE                      ");
    println!("");
    println!("  Shows all supported DEX program IDs and official documentation links.");
    println!("  Use this to verify current program IDs or check for updates.\n");
    
    display_dex_program_ids().await;
}
            "10" => {
                println!("\n Goodbye!");
                return Ok(());
            }
            _ => {
                println!(" Invalid choice. Please enter 1-10.");
            }
        }
    }
}



// ========== ADDITIONAL METEORA AMM VAULT FETCHING FUNCTIONS ==========

/// Parse Meteora AMM v1 by fetching vault accounts
async fn parse_meteora_amm_v1_with_vaults(
    rpc: &AsyncRpcClient,
    pool_address: &str,
    pool_data: &[u8],
    base_decimals: u8,
    quote_decimals: u8,
    reference_price: f64,
    pair_name: &str,
    dex_name: &str,
) -> Option<EnhancedPriceUpdate> {
    println!("   [Meteora AMM v1] Fetching vault accounts for {}...", pair_name);
    
    if pool_data.len() < 200 {
        println!("   [X] Pool data too small");
        return None;
    }
    
    // Meteora AMM v1 pool structure:
    // [0-8]: discriminator
    // [8-40]: tokenAMint (32 bytes)
    // [40-72]: tokenBMint (32 bytes)
    // [72-104]: aVault (32 bytes) - THIS is what we need!
    // [104-136]: bVault (32 bytes) - THIS is what we need!
    
    let a_vault_offset = 72;
    let b_vault_offset = 104;
    
    // Extract vault public keys
    let a_vault_bytes = &pool_data[a_vault_offset..a_vault_offset + 32];
    let b_vault_bytes = &pool_data[b_vault_offset..b_vault_offset + 32];
    
    let a_vault = match Pubkey::try_from(a_vault_bytes) {
        Ok(pk) => pk,
        Err(_) => {
            println!("   [X] Failed to parse aVault pubkey");
            return None;
        }
    };
    
    let b_vault = match Pubkey::try_from(b_vault_bytes) {
        Ok(pk) => pk,
        Err(_) => {
            println!("   [X] Failed to parse bVault pubkey");
            return None;
        }
    };
    
    println!("   [Meteora AMM v1] aVault: {}", a_vault);
    println!("   [Meteora AMM v1] bVault: {}", b_vault);
    
    // Fetch vault accounts
    let a_vault_account = match rpc.get_account(&a_vault).await {
        Ok(acc) => acc,
        Err(e) => {
            println!("   [X] Failed to fetch aVault: {:?}", e);
            return None;
        }
    };
    
    let b_vault_account = match rpc.get_account(&b_vault).await {
        Ok(acc) => acc,
        Err(e) => {
            println!("   [X] Failed to fetch bVault: {:?}", e);
            return None;
        }
    };
    
    // Parse SPL Token Account structure
    // Token account layout: amount is at offset 64 (u64, 8 bytes)
    if a_vault_account.data.len() < 72 || b_vault_account.data.len() < 72 {
        println!("   [X] Vault accounts too small");
        return None;
    }
    
    let reserve_a = u64::from_le_bytes(
        a_vault_account.data[64..72].try_into().unwrap()
    );
    
    let reserve_b = u64::from_le_bytes(
        b_vault_account.data[64..72].try_into().unwrap()
    );
    
    if reserve_a == 0 || reserve_b == 0 {
        println!("   [X] Zero reserves detected");
        return None;
    }
    
    // Calculate price
    let reserve_a_f = reserve_a as f64 / 10_f64.powi(base_decimals as i32);
    let reserve_b_f = reserve_b as f64 / 10_f64.powi(quote_decimals as i32);
    let price = reserve_b_f / reserve_a_f;
    
    // Validate against reference price
    if reference_price > 0.0 {
        let deviation = ((price - reference_price) / reference_price).abs();
        println!("   [Meteora AMM v1] Price: {:.8}, Deviation: {:.2}%", price, deviation * 100.0);
        
        if deviation > 0.5 {
            println!("   [X] Deviation too high (>50%)");
            return None;
        }
    } else {
        println!("   [Meteora AMM v1] Price: {:.8}", price);
    }
    
    let liquidity = reserve_a_f * price * 2.0;
    
    println!("   [OK] Meteora AMM v1 parsed successfully");
    
    Some(EnhancedPriceUpdate {
        dex: dex_name.to_string(),
        token_pair: pair_name.to_string(),
        price,
        timestamp: TokioInstant::now(),
        liquidity: Some(liquidity),
        data_source: DataSource::WebSocket,
        pool_address: pool_address.to_string(),
        reserve_token_a: Some(reserve_a),
        reserve_token_b: Some(reserve_b),
    })
}

/// Parse Meteora AMM v2 using sqrt_price
fn parse_meteora_amm_v2_sqrt_price(
    pool_data: &[u8],
    base_decimals: u8,
    quote_decimals: u8,
    reference_price: f64,
    pair_name: &str,
    dex_name: &str,
    pool_address: &str,
) -> Option<EnhancedPriceUpdate> {
    println!("   [Meteora AMM v2] Parsing sqrt_price for {}...", pair_name);
    
    if pool_data.len() < 200 {
        println!("   [X] Pool data too small");
        return None;
    }
    
    // DAMM v2 structure (from research):
    // sqrt_price is stored as u128 Q64.64 fixed point
    // Need to find the correct offset - try common positions
    
    let sqrt_price_offsets = vec![
        136, 140, 144, 148, 152, 156, 160, 164, 168, 172, 176, 180
    ];
    
    for offset in sqrt_price_offsets {
        if offset + 16 > pool_data.len() {
            continue;
        }
        
        let sqrt_price_bytes: [u8; 16] = pool_data[offset..offset + 16].try_into().unwrap();
        let sqrt_price = u128::from_le_bytes(sqrt_price_bytes);
        
        if sqrt_price == 0 {
            continue;
        }
        
        // Convert Q64.64 fixed point to f64
        let sqrt_price_f64 = sqrt_price as f64 / 2_f64.powi(64);
        let price_raw = sqrt_price_f64 * sqrt_price_f64;
        
        // Apply decimal adjustment
        let decimal_adj = 10_f64.powi((quote_decimals as i32) - (base_decimals as i32));
        let price = price_raw * decimal_adj;
        
        // Validate
        if price < 0.0000001 || price > 1_000_000_000.0 {
            continue;
        }
        
        if reference_price > 0.0 {
            let deviation = ((price - reference_price) / reference_price).abs();
            
            if deviation < 0.3 {
                println!("   [OK] Meteora AMM v2 at offset {}: {:.8} (dev: {:.2}%)", 
                    offset, price, deviation * 100.0);
                
                return Some(EnhancedPriceUpdate {
                    dex: dex_name.to_string(),
                    token_pair: pair_name.to_string(),
                    price,
                    timestamp: TokioInstant::now(),
                    liquidity: None,
                    data_source: DataSource::WebSocket,
                    pool_address: pool_address.to_string(),
                    reserve_token_a: None,
                    reserve_token_b: None,
                });
            }
        } else if price > 0.0 {
            println!("   [OK] Meteora AMM v2 at offset {}: {:.8}", offset, price);
            
            return Some(EnhancedPriceUpdate {
                dex: dex_name.to_string(),
                token_pair: pair_name.to_string(),
                price,
                timestamp: TokioInstant::now(),
                liquidity: None,
                data_source: DataSource::WebSocket,
                pool_address: pool_address.to_string(),
                reserve_token_a: None,
                reserve_token_b: None,
            });
        }
    }
    
    println!("   [X] Meteora AMM v2 sqrt_price parsing failed");
    None
}

// ========== END OF ADDITIONAL FUNCTIONS ==========
